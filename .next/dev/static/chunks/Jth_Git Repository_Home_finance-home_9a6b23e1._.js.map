{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["// app/actions.ts\r\n\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// Evita instanciar múltiples clientes en desarrollo\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- LEER TODOS LOS DATOS ---\r\nexport async function getFinanceData() {\r\n  const accounts = await prisma.account.findMany();\r\n  const categories = await prisma.category.findMany();\r\n  const transactions = await prisma.transaction.findMany({\r\n    orderBy: { date: 'desc' }\r\n  });\r\n  const fixedRules = await prisma.fixedRule.findMany();\r\n  const simulatorItems = await prisma.simulatorItem.findMany();\r\n\r\n  // Convertimos datos complejos para que React los entienda (Fechas y JSON)\r\n  const parsedCategories = categories.map(c => ({\r\n    ...c,\r\n    subCategories: c.subCategories ? JSON.parse(c.subCategories) : []\r\n  }));\r\n\r\n  const parsedTransactions = transactions.map(t => ({\r\n    ...t,\r\n    date: t.date.toISOString(), // React prefiere strings para fechas\r\n    accountId: t.accountId,\r\n    categoryId: t.categoryId\r\n  }));\r\n\r\n  return {\r\n    accounts,\r\n    categories: parsedCategories,\r\n    transactions: parsedTransactions,\r\n    fixedRules,\r\n    simulatorItems\r\n  };\r\n}\r\n\r\n// --- ACCIONES DE TRANSACCIONES ---\r\nexport async function createTransaction(data: any) {\r\n  // Convertimos la fecha string a Date real para la DB\r\n  await prisma.transaction.create({\r\n    data: {\r\n        type: data.type,\r\n        amount: data.amount,\r\n        budgetedAmount: data.budgetedAmount,\r\n        accountId: data.accountId,\r\n        categoryId: data.categoryId,\r\n        description: data.description,\r\n        date: new Date(data.date), \r\n        isFixed: data.isFixed || false,\r\n        isSavings: data.isSavings || false\r\n    }\r\n  });\r\n\r\n  // Actualizar Saldo de la Cuenta\r\n  const multiplier = data.type === 'income' ? 1 : -1;\r\n  await prisma.account.update({\r\n      where: { id: data.accountId },\r\n      data: { balance: { increment: data.amount * multiplier } }\r\n  });\r\n\r\n  revalidatePath('/'); // Recarga la página automáticamente\r\n}\r\n\r\n// --- ACCIONES DE CUENTAS ---\r\nexport async function createAccount(data: any) {\r\n  await prisma.account.create({ data });\r\n  revalidatePath('/');\r\n}\r\n\r\nexport async function deleteAccount(id: string) {\r\n  await prisma.account.delete({ where: { id } });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE CATEGORIAS ---\r\nexport async function createCategory(data: any) {\r\n  await prisma.category.create({\r\n    data: {\r\n        name: data.name,\r\n        type: data.type,\r\n        subCategories: JSON.stringify(data.subCategories || [])\r\n    }\r\n  });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE SIMULADOR ---\r\nexport async function saveSimulatorItem(data: any) {\r\n    // Si existe ID lo actualiza, si no, crea uno nuevo\r\n    const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } });\r\n    if (existing) {\r\n        await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } });\r\n    } else {\r\n        await prisma.simulatorItem.create({ data });\r\n    }\r\n    revalidatePath('/simulator');\r\n}\r\n\r\nexport async function deleteSimulatorItem(id: string) {\r\n    await prisma.simulatorItem.delete({ where: { id } });\r\n    revalidatePath('/simulator');\r\n}\r\n\r\n// --- REGLAS FIJAS ---\r\nexport async function createFixedRule(data: any) {\r\n    await prisma.fixedRule.create({ data });\r\n    revalidatePath('/');\r\n}"],"names":[],"mappings":";;;;;;;IAYsB,iBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 19, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["// app/actions.ts\r\n\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// Evita instanciar múltiples clientes en desarrollo\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- LEER TODOS LOS DATOS ---\r\nexport async function getFinanceData() {\r\n  const accounts = await prisma.account.findMany();\r\n  const categories = await prisma.category.findMany();\r\n  const transactions = await prisma.transaction.findMany({\r\n    orderBy: { date: 'desc' }\r\n  });\r\n  const fixedRules = await prisma.fixedRule.findMany();\r\n  const simulatorItems = await prisma.simulatorItem.findMany();\r\n\r\n  // Convertimos datos complejos para que React los entienda (Fechas y JSON)\r\n  const parsedCategories = categories.map(c => ({\r\n    ...c,\r\n    subCategories: c.subCategories ? JSON.parse(c.subCategories) : []\r\n  }));\r\n\r\n  const parsedTransactions = transactions.map(t => ({\r\n    ...t,\r\n    date: t.date.toISOString(), // React prefiere strings para fechas\r\n    accountId: t.accountId,\r\n    categoryId: t.categoryId\r\n  }));\r\n\r\n  return {\r\n    accounts,\r\n    categories: parsedCategories,\r\n    transactions: parsedTransactions,\r\n    fixedRules,\r\n    simulatorItems\r\n  };\r\n}\r\n\r\n// --- ACCIONES DE TRANSACCIONES ---\r\nexport async function createTransaction(data: any) {\r\n  // Convertimos la fecha string a Date real para la DB\r\n  await prisma.transaction.create({\r\n    data: {\r\n        type: data.type,\r\n        amount: data.amount,\r\n        budgetedAmount: data.budgetedAmount,\r\n        accountId: data.accountId,\r\n        categoryId: data.categoryId,\r\n        description: data.description,\r\n        date: new Date(data.date), \r\n        isFixed: data.isFixed || false,\r\n        isSavings: data.isSavings || false\r\n    }\r\n  });\r\n\r\n  // Actualizar Saldo de la Cuenta\r\n  const multiplier = data.type === 'income' ? 1 : -1;\r\n  await prisma.account.update({\r\n      where: { id: data.accountId },\r\n      data: { balance: { increment: data.amount * multiplier } }\r\n  });\r\n\r\n  revalidatePath('/'); // Recarga la página automáticamente\r\n}\r\n\r\n// --- ACCIONES DE CUENTAS ---\r\nexport async function createAccount(data: any) {\r\n  await prisma.account.create({ data });\r\n  revalidatePath('/');\r\n}\r\n\r\nexport async function deleteAccount(id: string) {\r\n  await prisma.account.delete({ where: { id } });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE CATEGORIAS ---\r\nexport async function createCategory(data: any) {\r\n  await prisma.category.create({\r\n    data: {\r\n        name: data.name,\r\n        type: data.type,\r\n        subCategories: JSON.stringify(data.subCategories || [])\r\n    }\r\n  });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE SIMULADOR ---\r\nexport async function saveSimulatorItem(data: any) {\r\n    // Si existe ID lo actualiza, si no, crea uno nuevo\r\n    const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } });\r\n    if (existing) {\r\n        await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } });\r\n    } else {\r\n        await prisma.simulatorItem.create({ data });\r\n    }\r\n    revalidatePath('/simulator');\r\n}\r\n\r\nexport async function deleteSimulatorItem(id: string) {\r\n    await prisma.simulatorItem.delete({ where: { id } });\r\n    revalidatePath('/simulator');\r\n}\r\n\r\n// --- REGLAS FIJAS ---\r\nexport async function createFixedRule(data: any) {\r\n    await prisma.fixedRule.create({ data });\r\n    revalidatePath('/');\r\n}"],"names":[],"mappings":";;;;;;;IA4CsB,oBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["// app/actions.ts\r\n\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// Evita instanciar múltiples clientes en desarrollo\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- LEER TODOS LOS DATOS ---\r\nexport async function getFinanceData() {\r\n  const accounts = await prisma.account.findMany();\r\n  const categories = await prisma.category.findMany();\r\n  const transactions = await prisma.transaction.findMany({\r\n    orderBy: { date: 'desc' }\r\n  });\r\n  const fixedRules = await prisma.fixedRule.findMany();\r\n  const simulatorItems = await prisma.simulatorItem.findMany();\r\n\r\n  // Convertimos datos complejos para que React los entienda (Fechas y JSON)\r\n  const parsedCategories = categories.map(c => ({\r\n    ...c,\r\n    subCategories: c.subCategories ? JSON.parse(c.subCategories) : []\r\n  }));\r\n\r\n  const parsedTransactions = transactions.map(t => ({\r\n    ...t,\r\n    date: t.date.toISOString(), // React prefiere strings para fechas\r\n    accountId: t.accountId,\r\n    categoryId: t.categoryId\r\n  }));\r\n\r\n  return {\r\n    accounts,\r\n    categories: parsedCategories,\r\n    transactions: parsedTransactions,\r\n    fixedRules,\r\n    simulatorItems\r\n  };\r\n}\r\n\r\n// --- ACCIONES DE TRANSACCIONES ---\r\nexport async function createTransaction(data: any) {\r\n  // Convertimos la fecha string a Date real para la DB\r\n  await prisma.transaction.create({\r\n    data: {\r\n        type: data.type,\r\n        amount: data.amount,\r\n        budgetedAmount: data.budgetedAmount,\r\n        accountId: data.accountId,\r\n        categoryId: data.categoryId,\r\n        description: data.description,\r\n        date: new Date(data.date), \r\n        isFixed: data.isFixed || false,\r\n        isSavings: data.isSavings || false\r\n    }\r\n  });\r\n\r\n  // Actualizar Saldo de la Cuenta\r\n  const multiplier = data.type === 'income' ? 1 : -1;\r\n  await prisma.account.update({\r\n      where: { id: data.accountId },\r\n      data: { balance: { increment: data.amount * multiplier } }\r\n  });\r\n\r\n  revalidatePath('/'); // Recarga la página automáticamente\r\n}\r\n\r\n// --- ACCIONES DE CUENTAS ---\r\nexport async function createAccount(data: any) {\r\n  await prisma.account.create({ data });\r\n  revalidatePath('/');\r\n}\r\n\r\nexport async function deleteAccount(id: string) {\r\n  await prisma.account.delete({ where: { id } });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE CATEGORIAS ---\r\nexport async function createCategory(data: any) {\r\n  await prisma.category.create({\r\n    data: {\r\n        name: data.name,\r\n        type: data.type,\r\n        subCategories: JSON.stringify(data.subCategories || [])\r\n    }\r\n  });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE SIMULADOR ---\r\nexport async function saveSimulatorItem(data: any) {\r\n    // Si existe ID lo actualiza, si no, crea uno nuevo\r\n    const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } });\r\n    if (existing) {\r\n        await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } });\r\n    } else {\r\n        await prisma.simulatorItem.create({ data });\r\n    }\r\n    revalidatePath('/simulator');\r\n}\r\n\r\nexport async function deleteSimulatorItem(id: string) {\r\n    await prisma.simulatorItem.delete({ where: { id } });\r\n    revalidatePath('/simulator');\r\n}\r\n\r\n// --- REGLAS FIJAS ---\r\nexport async function createFixedRule(data: any) {\r\n    await prisma.fixedRule.create({ data });\r\n    revalidatePath('/');\r\n}"],"names":[],"mappings":";;;;;;;IAuEsB,gBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 49, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["// app/actions.ts\r\n\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// Evita instanciar múltiples clientes en desarrollo\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- LEER TODOS LOS DATOS ---\r\nexport async function getFinanceData() {\r\n  const accounts = await prisma.account.findMany();\r\n  const categories = await prisma.category.findMany();\r\n  const transactions = await prisma.transaction.findMany({\r\n    orderBy: { date: 'desc' }\r\n  });\r\n  const fixedRules = await prisma.fixedRule.findMany();\r\n  const simulatorItems = await prisma.simulatorItem.findMany();\r\n\r\n  // Convertimos datos complejos para que React los entienda (Fechas y JSON)\r\n  const parsedCategories = categories.map(c => ({\r\n    ...c,\r\n    subCategories: c.subCategories ? JSON.parse(c.subCategories) : []\r\n  }));\r\n\r\n  const parsedTransactions = transactions.map(t => ({\r\n    ...t,\r\n    date: t.date.toISOString(), // React prefiere strings para fechas\r\n    accountId: t.accountId,\r\n    categoryId: t.categoryId\r\n  }));\r\n\r\n  return {\r\n    accounts,\r\n    categories: parsedCategories,\r\n    transactions: parsedTransactions,\r\n    fixedRules,\r\n    simulatorItems\r\n  };\r\n}\r\n\r\n// --- ACCIONES DE TRANSACCIONES ---\r\nexport async function createTransaction(data: any) {\r\n  // Convertimos la fecha string a Date real para la DB\r\n  await prisma.transaction.create({\r\n    data: {\r\n        type: data.type,\r\n        amount: data.amount,\r\n        budgetedAmount: data.budgetedAmount,\r\n        accountId: data.accountId,\r\n        categoryId: data.categoryId,\r\n        description: data.description,\r\n        date: new Date(data.date), \r\n        isFixed: data.isFixed || false,\r\n        isSavings: data.isSavings || false\r\n    }\r\n  });\r\n\r\n  // Actualizar Saldo de la Cuenta\r\n  const multiplier = data.type === 'income' ? 1 : -1;\r\n  await prisma.account.update({\r\n      where: { id: data.accountId },\r\n      data: { balance: { increment: data.amount * multiplier } }\r\n  });\r\n\r\n  revalidatePath('/'); // Recarga la página automáticamente\r\n}\r\n\r\n// --- ACCIONES DE CUENTAS ---\r\nexport async function createAccount(data: any) {\r\n  await prisma.account.create({ data });\r\n  revalidatePath('/');\r\n}\r\n\r\nexport async function deleteAccount(id: string) {\r\n  await prisma.account.delete({ where: { id } });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE CATEGORIAS ---\r\nexport async function createCategory(data: any) {\r\n  await prisma.category.create({\r\n    data: {\r\n        name: data.name,\r\n        type: data.type,\r\n        subCategories: JSON.stringify(data.subCategories || [])\r\n    }\r\n  });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE SIMULADOR ---\r\nexport async function saveSimulatorItem(data: any) {\r\n    // Si existe ID lo actualiza, si no, crea uno nuevo\r\n    const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } });\r\n    if (existing) {\r\n        await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } });\r\n    } else {\r\n        await prisma.simulatorItem.create({ data });\r\n    }\r\n    revalidatePath('/simulator');\r\n}\r\n\r\nexport async function deleteSimulatorItem(id: string) {\r\n    await prisma.simulatorItem.delete({ where: { id } });\r\n    revalidatePath('/simulator');\r\n}\r\n\r\n// --- REGLAS FIJAS ---\r\nexport async function createFixedRule(data: any) {\r\n    await prisma.fixedRule.create({ data });\r\n    revalidatePath('/');\r\n}"],"names":[],"mappings":";;;;;;;IA4EsB,gBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["// app/actions.ts\r\n\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// Evita instanciar múltiples clientes en desarrollo\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- LEER TODOS LOS DATOS ---\r\nexport async function getFinanceData() {\r\n  const accounts = await prisma.account.findMany();\r\n  const categories = await prisma.category.findMany();\r\n  const transactions = await prisma.transaction.findMany({\r\n    orderBy: { date: 'desc' }\r\n  });\r\n  const fixedRules = await prisma.fixedRule.findMany();\r\n  const simulatorItems = await prisma.simulatorItem.findMany();\r\n\r\n  // Convertimos datos complejos para que React los entienda (Fechas y JSON)\r\n  const parsedCategories = categories.map(c => ({\r\n    ...c,\r\n    subCategories: c.subCategories ? JSON.parse(c.subCategories) : []\r\n  }));\r\n\r\n  const parsedTransactions = transactions.map(t => ({\r\n    ...t,\r\n    date: t.date.toISOString(), // React prefiere strings para fechas\r\n    accountId: t.accountId,\r\n    categoryId: t.categoryId\r\n  }));\r\n\r\n  return {\r\n    accounts,\r\n    categories: parsedCategories,\r\n    transactions: parsedTransactions,\r\n    fixedRules,\r\n    simulatorItems\r\n  };\r\n}\r\n\r\n// --- ACCIONES DE TRANSACCIONES ---\r\nexport async function createTransaction(data: any) {\r\n  // Convertimos la fecha string a Date real para la DB\r\n  await prisma.transaction.create({\r\n    data: {\r\n        type: data.type,\r\n        amount: data.amount,\r\n        budgetedAmount: data.budgetedAmount,\r\n        accountId: data.accountId,\r\n        categoryId: data.categoryId,\r\n        description: data.description,\r\n        date: new Date(data.date), \r\n        isFixed: data.isFixed || false,\r\n        isSavings: data.isSavings || false\r\n    }\r\n  });\r\n\r\n  // Actualizar Saldo de la Cuenta\r\n  const multiplier = data.type === 'income' ? 1 : -1;\r\n  await prisma.account.update({\r\n      where: { id: data.accountId },\r\n      data: { balance: { increment: data.amount * multiplier } }\r\n  });\r\n\r\n  revalidatePath('/'); // Recarga la página automáticamente\r\n}\r\n\r\n// --- ACCIONES DE CUENTAS ---\r\nexport async function createAccount(data: any) {\r\n  await prisma.account.create({ data });\r\n  revalidatePath('/');\r\n}\r\n\r\nexport async function deleteAccount(id: string) {\r\n  await prisma.account.delete({ where: { id } });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE CATEGORIAS ---\r\nexport async function createCategory(data: any) {\r\n  await prisma.category.create({\r\n    data: {\r\n        name: data.name,\r\n        type: data.type,\r\n        subCategories: JSON.stringify(data.subCategories || [])\r\n    }\r\n  });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE SIMULADOR ---\r\nexport async function saveSimulatorItem(data: any) {\r\n    // Si existe ID lo actualiza, si no, crea uno nuevo\r\n    const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } });\r\n    if (existing) {\r\n        await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } });\r\n    } else {\r\n        await prisma.simulatorItem.create({ data });\r\n    }\r\n    revalidatePath('/simulator');\r\n}\r\n\r\nexport async function deleteSimulatorItem(id: string) {\r\n    await prisma.simulatorItem.delete({ where: { id } });\r\n    revalidatePath('/simulator');\r\n}\r\n\r\n// --- REGLAS FIJAS ---\r\nexport async function createFixedRule(data: any) {\r\n    await prisma.fixedRule.create({ data });\r\n    revalidatePath('/');\r\n}"],"names":[],"mappings":";;;;;;;IAkFsB,iBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 79, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["// app/actions.ts\r\n\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// Evita instanciar múltiples clientes en desarrollo\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- LEER TODOS LOS DATOS ---\r\nexport async function getFinanceData() {\r\n  const accounts = await prisma.account.findMany();\r\n  const categories = await prisma.category.findMany();\r\n  const transactions = await prisma.transaction.findMany({\r\n    orderBy: { date: 'desc' }\r\n  });\r\n  const fixedRules = await prisma.fixedRule.findMany();\r\n  const simulatorItems = await prisma.simulatorItem.findMany();\r\n\r\n  // Convertimos datos complejos para que React los entienda (Fechas y JSON)\r\n  const parsedCategories = categories.map(c => ({\r\n    ...c,\r\n    subCategories: c.subCategories ? JSON.parse(c.subCategories) : []\r\n  }));\r\n\r\n  const parsedTransactions = transactions.map(t => ({\r\n    ...t,\r\n    date: t.date.toISOString(), // React prefiere strings para fechas\r\n    accountId: t.accountId,\r\n    categoryId: t.categoryId\r\n  }));\r\n\r\n  return {\r\n    accounts,\r\n    categories: parsedCategories,\r\n    transactions: parsedTransactions,\r\n    fixedRules,\r\n    simulatorItems\r\n  };\r\n}\r\n\r\n// --- ACCIONES DE TRANSACCIONES ---\r\nexport async function createTransaction(data: any) {\r\n  // Convertimos la fecha string a Date real para la DB\r\n  await prisma.transaction.create({\r\n    data: {\r\n        type: data.type,\r\n        amount: data.amount,\r\n        budgetedAmount: data.budgetedAmount,\r\n        accountId: data.accountId,\r\n        categoryId: data.categoryId,\r\n        description: data.description,\r\n        date: new Date(data.date), \r\n        isFixed: data.isFixed || false,\r\n        isSavings: data.isSavings || false\r\n    }\r\n  });\r\n\r\n  // Actualizar Saldo de la Cuenta\r\n  const multiplier = data.type === 'income' ? 1 : -1;\r\n  await prisma.account.update({\r\n      where: { id: data.accountId },\r\n      data: { balance: { increment: data.amount * multiplier } }\r\n  });\r\n\r\n  revalidatePath('/'); // Recarga la página automáticamente\r\n}\r\n\r\n// --- ACCIONES DE CUENTAS ---\r\nexport async function createAccount(data: any) {\r\n  await prisma.account.create({ data });\r\n  revalidatePath('/');\r\n}\r\n\r\nexport async function deleteAccount(id: string) {\r\n  await prisma.account.delete({ where: { id } });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE CATEGORIAS ---\r\nexport async function createCategory(data: any) {\r\n  await prisma.category.create({\r\n    data: {\r\n        name: data.name,\r\n        type: data.type,\r\n        subCategories: JSON.stringify(data.subCategories || [])\r\n    }\r\n  });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE SIMULADOR ---\r\nexport async function saveSimulatorItem(data: any) {\r\n    // Si existe ID lo actualiza, si no, crea uno nuevo\r\n    const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } });\r\n    if (existing) {\r\n        await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } });\r\n    } else {\r\n        await prisma.simulatorItem.create({ data });\r\n    }\r\n    revalidatePath('/simulator');\r\n}\r\n\r\nexport async function deleteSimulatorItem(id: string) {\r\n    await prisma.simulatorItem.delete({ where: { id } });\r\n    revalidatePath('/simulator');\r\n}\r\n\r\n// --- REGLAS FIJAS ---\r\nexport async function createFixedRule(data: any) {\r\n    await prisma.fixedRule.create({ data });\r\n    revalidatePath('/');\r\n}"],"names":[],"mappings":";;;;;;;IA8FsB,oBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 94, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["// app/actions.ts\r\n\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// Evita instanciar múltiples clientes en desarrollo\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- LEER TODOS LOS DATOS ---\r\nexport async function getFinanceData() {\r\n  const accounts = await prisma.account.findMany();\r\n  const categories = await prisma.category.findMany();\r\n  const transactions = await prisma.transaction.findMany({\r\n    orderBy: { date: 'desc' }\r\n  });\r\n  const fixedRules = await prisma.fixedRule.findMany();\r\n  const simulatorItems = await prisma.simulatorItem.findMany();\r\n\r\n  // Convertimos datos complejos para que React los entienda (Fechas y JSON)\r\n  const parsedCategories = categories.map(c => ({\r\n    ...c,\r\n    subCategories: c.subCategories ? JSON.parse(c.subCategories) : []\r\n  }));\r\n\r\n  const parsedTransactions = transactions.map(t => ({\r\n    ...t,\r\n    date: t.date.toISOString(), // React prefiere strings para fechas\r\n    accountId: t.accountId,\r\n    categoryId: t.categoryId\r\n  }));\r\n\r\n  return {\r\n    accounts,\r\n    categories: parsedCategories,\r\n    transactions: parsedTransactions,\r\n    fixedRules,\r\n    simulatorItems\r\n  };\r\n}\r\n\r\n// --- ACCIONES DE TRANSACCIONES ---\r\nexport async function createTransaction(data: any) {\r\n  // Convertimos la fecha string a Date real para la DB\r\n  await prisma.transaction.create({\r\n    data: {\r\n        type: data.type,\r\n        amount: data.amount,\r\n        budgetedAmount: data.budgetedAmount,\r\n        accountId: data.accountId,\r\n        categoryId: data.categoryId,\r\n        description: data.description,\r\n        date: new Date(data.date), \r\n        isFixed: data.isFixed || false,\r\n        isSavings: data.isSavings || false\r\n    }\r\n  });\r\n\r\n  // Actualizar Saldo de la Cuenta\r\n  const multiplier = data.type === 'income' ? 1 : -1;\r\n  await prisma.account.update({\r\n      where: { id: data.accountId },\r\n      data: { balance: { increment: data.amount * multiplier } }\r\n  });\r\n\r\n  revalidatePath('/'); // Recarga la página automáticamente\r\n}\r\n\r\n// --- ACCIONES DE CUENTAS ---\r\nexport async function createAccount(data: any) {\r\n  await prisma.account.create({ data });\r\n  revalidatePath('/');\r\n}\r\n\r\nexport async function deleteAccount(id: string) {\r\n  await prisma.account.delete({ where: { id } });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE CATEGORIAS ---\r\nexport async function createCategory(data: any) {\r\n  await prisma.category.create({\r\n    data: {\r\n        name: data.name,\r\n        type: data.type,\r\n        subCategories: JSON.stringify(data.subCategories || [])\r\n    }\r\n  });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE SIMULADOR ---\r\nexport async function saveSimulatorItem(data: any) {\r\n    // Si existe ID lo actualiza, si no, crea uno nuevo\r\n    const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } });\r\n    if (existing) {\r\n        await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } });\r\n    } else {\r\n        await prisma.simulatorItem.create({ data });\r\n    }\r\n    revalidatePath('/simulator');\r\n}\r\n\r\nexport async function deleteSimulatorItem(id: string) {\r\n    await prisma.simulatorItem.delete({ where: { id } });\r\n    revalidatePath('/simulator');\r\n}\r\n\r\n// --- REGLAS FIJAS ---\r\nexport async function createFixedRule(data: any) {\r\n    await prisma.fixedRule.create({ data });\r\n    revalidatePath('/');\r\n}"],"names":[],"mappings":";;;;;;;IAyGsB,sBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 109, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["// app/actions.ts\r\n\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// Evita instanciar múltiples clientes en desarrollo\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- LEER TODOS LOS DATOS ---\r\nexport async function getFinanceData() {\r\n  const accounts = await prisma.account.findMany();\r\n  const categories = await prisma.category.findMany();\r\n  const transactions = await prisma.transaction.findMany({\r\n    orderBy: { date: 'desc' }\r\n  });\r\n  const fixedRules = await prisma.fixedRule.findMany();\r\n  const simulatorItems = await prisma.simulatorItem.findMany();\r\n\r\n  // Convertimos datos complejos para que React los entienda (Fechas y JSON)\r\n  const parsedCategories = categories.map(c => ({\r\n    ...c,\r\n    subCategories: c.subCategories ? JSON.parse(c.subCategories) : []\r\n  }));\r\n\r\n  const parsedTransactions = transactions.map(t => ({\r\n    ...t,\r\n    date: t.date.toISOString(), // React prefiere strings para fechas\r\n    accountId: t.accountId,\r\n    categoryId: t.categoryId\r\n  }));\r\n\r\n  return {\r\n    accounts,\r\n    categories: parsedCategories,\r\n    transactions: parsedTransactions,\r\n    fixedRules,\r\n    simulatorItems\r\n  };\r\n}\r\n\r\n// --- ACCIONES DE TRANSACCIONES ---\r\nexport async function createTransaction(data: any) {\r\n  // Convertimos la fecha string a Date real para la DB\r\n  await prisma.transaction.create({\r\n    data: {\r\n        type: data.type,\r\n        amount: data.amount,\r\n        budgetedAmount: data.budgetedAmount,\r\n        accountId: data.accountId,\r\n        categoryId: data.categoryId,\r\n        description: data.description,\r\n        date: new Date(data.date), \r\n        isFixed: data.isFixed || false,\r\n        isSavings: data.isSavings || false\r\n    }\r\n  });\r\n\r\n  // Actualizar Saldo de la Cuenta\r\n  const multiplier = data.type === 'income' ? 1 : -1;\r\n  await prisma.account.update({\r\n      where: { id: data.accountId },\r\n      data: { balance: { increment: data.amount * multiplier } }\r\n  });\r\n\r\n  revalidatePath('/'); // Recarga la página automáticamente\r\n}\r\n\r\n// --- ACCIONES DE CUENTAS ---\r\nexport async function createAccount(data: any) {\r\n  await prisma.account.create({ data });\r\n  revalidatePath('/');\r\n}\r\n\r\nexport async function deleteAccount(id: string) {\r\n  await prisma.account.delete({ where: { id } });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE CATEGORIAS ---\r\nexport async function createCategory(data: any) {\r\n  await prisma.category.create({\r\n    data: {\r\n        name: data.name,\r\n        type: data.type,\r\n        subCategories: JSON.stringify(data.subCategories || [])\r\n    }\r\n  });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE SIMULADOR ---\r\nexport async function saveSimulatorItem(data: any) {\r\n    // Si existe ID lo actualiza, si no, crea uno nuevo\r\n    const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } });\r\n    if (existing) {\r\n        await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } });\r\n    } else {\r\n        await prisma.simulatorItem.create({ data });\r\n    }\r\n    revalidatePath('/simulator');\r\n}\r\n\r\nexport async function deleteSimulatorItem(id: string) {\r\n    await prisma.simulatorItem.delete({ where: { id } });\r\n    revalidatePath('/simulator');\r\n}\r\n\r\n// --- REGLAS FIJAS ---\r\nexport async function createFixedRule(data: any) {\r\n    await prisma.fixedRule.create({ data });\r\n    revalidatePath('/');\r\n}"],"names":[],"mappings":";;;;;;;IA+GsB,kBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 124, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/context/FinanceContext.tsx"],"sourcesContent":["// context/FinanceContext.tsx\r\n\"use client\";\r\nimport React, { createContext, useContext, useEffect, useState } from 'react';\r\nimport { Account, Category, Transaction, FixedExpenseRule } from '@/types';\r\n// Importamos las acciones del servidor\r\nimport { getFinanceData, createTransaction, createAccount, deleteAccount, createCategory, saveSimulatorItem, deleteSimulatorItem, createFixedRule } from '@/app/actions';\r\n\r\ninterface SimulatorItem {\r\n    id: string;\r\n    name: string;\r\n    amount: number;\r\n    type: 'income' | 'expense';\r\n    isFixed: boolean;\r\n}\r\n\r\ninterface FinanceContextType {\r\n  accounts: Account[];\r\n  transactions: Transaction[];\r\n  categories: Category[];\r\n  fixedRules: FixedExpenseRule[];\r\n  simulatorItems: SimulatorItem[];\r\n  \r\n  addTransaction: (t: any) => Promise<void>;\r\n  addAccount: (a: any) => Promise<void>;\r\n  deleteAccountAction: (id: string) => Promise<void>;\r\n  addCategory: (c: any) => Promise<void>;\r\n  addFixedRule: (r: any) => Promise<void>;\r\n  \r\n  // Simulador\r\n  addSimItem: (item: any) => Promise<void>;\r\n  removeSimItem: (id: string) => Promise<void>;\r\n  \r\n  // Placeholders para evitar errores en otros componentes viejos\r\n  updateTransaction: (t: any) => void;\r\n  deleteTransaction: (id: string) => void;\r\n  updateAccount: (a: any) => void;\r\n  deleteCategory: (id: string) => void;\r\n  addSubCategory: (id: string, sub: string) => void;\r\n  removeSubCategory: (id: string, sub: string) => void;\r\n  updateFixedRule: (r: any) => void;\r\n  deleteFixedRule: (id: string) => void;\r\n  markRuleAsPaid: (id: string, date: string) => void;\r\n}\r\n\r\nconst FinanceContext = createContext<FinanceContextType | undefined>(undefined);\r\n\r\nexport const FinanceProvider = ({ children }: { children: React.ReactNode }) => {\r\n  const [accounts, setAccounts] = useState<Account[]>([]);\r\n  const [transactions, setTransactions] = useState<Transaction[]>([]);\r\n  const [categories, setCategories] = useState<Category[]>([]);\r\n  const [fixedRules, setFixedRules] = useState<FixedExpenseRule[]>([]);\r\n  const [simulatorItems, setSimulatorItems] = useState<SimulatorItem[]>([]);\r\n\r\n  // 1. CARGAR DATOS REALES AL INICIO\r\n  useEffect(() => {\r\n    const initData = async () => {\r\n        try {\r\n            const data = await getFinanceData();\r\n            // @ts-ignore\r\n            setAccounts(data.accounts);\r\n            // @ts-ignore\r\n            setTransactions(data.transactions);\r\n            // @ts-ignore\r\n            setCategories(data.categories);\r\n            // @ts-ignore\r\n            setFixedRules(data.fixedRules);\r\n            // @ts-ignore\r\n            setSimulatorItems(data.simulatorItems);\r\n        } catch (e) {\r\n            console.error(\"Error cargando BDD:\", e);\r\n        }\r\n    };\r\n    initData();\r\n  }, []);\r\n\r\n  // 2. FUNCIONES CONECTADAS A LA DB\r\n\r\n  const addTransaction = async (t: any) => {\r\n      // Actualización optimista (se ve rápido en pantalla)\r\n      setTransactions(prev => [t, ...prev]); \r\n      // Guardado real\r\n      await createTransaction(t);\r\n  };\r\n\r\n  const addAccount = async (a: any) => {\r\n      setAccounts(prev => [...prev, a]);\r\n      await createAccount(a);\r\n  };\r\n\r\n  const deleteAccountAction = async (id: string) => {\r\n      setAccounts(prev => prev.filter(x => x.id !== id));\r\n      await deleteAccount(id);\r\n  };\r\n\r\n  const addCategory = async (c: any) => {\r\n      setCategories(prev => [...prev, c]);\r\n      await createCategory(c);\r\n  };\r\n\r\n  const addFixedRule = async (r: any) => {\r\n      setFixedRules(prev => [...prev, r]);\r\n      await createFixedRule(r);\r\n  };\r\n\r\n  const addSimItem = async (item: any) => {\r\n      setSimulatorItems(prev => {\r\n          const exists = prev.find(i => i.id === item.id);\r\n          if (exists) return prev.map(i => i.id === item.id ? item : i);\r\n          return [...prev, item];\r\n      });\r\n      await saveSimulatorItem(item);\r\n  };\r\n\r\n  const removeSimItem = async (id: string) => {\r\n      setSimulatorItems(prev => prev.filter(i => i.id !== id));\r\n      await deleteSimulatorItem(id);\r\n  };\r\n\r\n  return (\r\n    <FinanceContext.Provider value={{\r\n      accounts, transactions, categories, fixedRules, simulatorItems,\r\n      addTransaction, addAccount, deleteAccountAction, addCategory, addFixedRule,\r\n      addSimItem, removeSimItem,\r\n      // Funciones vacías por compatibilidad temporal\r\n      updateTransaction: () => {}, deleteTransaction: () => {}, updateAccount: () => {}, \r\n      deleteCategory: () => {}, addSubCategory: () => {}, removeSubCategory: () => {}, \r\n      updateFixedRule: () => {}, deleteFixedRule: () => {}, markRuleAsPaid: () => {}\r\n    }}>\r\n      {children}\r\n    </FinanceContext.Provider>\r\n  );\r\n};\r\n\r\nexport const useFinance = () => {\r\n    const context = useContext(FinanceContext);\r\n    if (!context) throw new Error(\"useFinance Error\");\r\n    return context;\r\n};"],"names":[],"mappings":"AAAA,6BAA6B;;;;;;;;AAE7B;AAEA,uCAAuC;AACvC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAJA;;;AA2CA,MAAM,+BAAiB,IAAA,mOAAa,EAAiC;AAE9D,MAAM,kBAAkB,CAAC,EAAE,QAAQ,EAAiC;;IACzE,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,8NAAQ,EAAY,EAAE;IACtD,MAAM,CAAC,cAAc,gBAAgB,GAAG,IAAA,8NAAQ,EAAgB,EAAE;IAClE,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,8NAAQ,EAAa,EAAE;IAC3D,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,8NAAQ,EAAqB,EAAE;IACnE,MAAM,CAAC,gBAAgB,kBAAkB,GAAG,IAAA,8NAAQ,EAAkB,EAAE;IAExE,mCAAmC;IACnC,IAAA,+NAAS;qCAAC;YACR,MAAM;sDAAW;oBACb,IAAI;wBACA,MAAM,OAAO,MAAM,IAAA,qNAAc;wBACjC,aAAa;wBACb,YAAY,KAAK,QAAQ;wBACzB,aAAa;wBACb,gBAAgB,KAAK,YAAY;wBACjC,aAAa;wBACb,cAAc,KAAK,UAAU;wBAC7B,aAAa;wBACb,cAAc,KAAK,UAAU;wBAC7B,aAAa;wBACb,kBAAkB,KAAK,cAAc;oBACzC,EAAE,OAAO,GAAG;wBACR,QAAQ,KAAK,CAAC,uBAAuB;oBACzC;gBACJ;;YACA;QACF;oCAAG,EAAE;IAEL,kCAAkC;IAElC,MAAM,iBAAiB,OAAO;QAC1B,qDAAqD;QACrD,gBAAgB,CAAA,OAAQ;gBAAC;mBAAM;aAAK;QACpC,gBAAgB;QAChB,MAAM,IAAA,wNAAiB,EAAC;IAC5B;IAEA,MAAM,aAAa,OAAO;QACtB,YAAY,CAAA,OAAQ;mBAAI;gBAAM;aAAE;QAChC,MAAM,IAAA,oNAAa,EAAC;IACxB;IAEA,MAAM,sBAAsB,OAAO;QAC/B,YAAY,CAAA,OAAQ,KAAK,MAAM,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;QAC9C,MAAM,IAAA,oNAAa,EAAC;IACxB;IAEA,MAAM,cAAc,OAAO;QACvB,cAAc,CAAA,OAAQ;mBAAI;gBAAM;aAAE;QAClC,MAAM,IAAA,qNAAc,EAAC;IACzB;IAEA,MAAM,eAAe,OAAO;QACxB,cAAc,CAAA,OAAQ;mBAAI;gBAAM;aAAE;QAClC,MAAM,IAAA,sNAAe,EAAC;IAC1B;IAEA,MAAM,aAAa,OAAO;QACtB,kBAAkB,CAAA;YACd,MAAM,SAAS,KAAK,IAAI,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,KAAK,EAAE;YAC9C,IAAI,QAAQ,OAAO,KAAK,GAAG,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,KAAK,EAAE,GAAG,OAAO;YAC3D,OAAO;mBAAI;gBAAM;aAAK;QAC1B;QACA,MAAM,IAAA,wNAAiB,EAAC;IAC5B;IAEA,MAAM,gBAAgB,OAAO;QACzB,kBAAkB,CAAA,OAAQ,KAAK,MAAM,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;QACpD,MAAM,IAAA,0NAAmB,EAAC;IAC9B;IAEA,qBACE,kPAAC,eAAe,QAAQ;QAAC,OAAO;YAC9B;YAAU;YAAc;YAAY;YAAY;YAChD;YAAgB;YAAY;YAAqB;YAAa;YAC9D;YAAY;YACZ,+CAA+C;YAC/C,mBAAmB,KAAO;YAAG,mBAAmB,KAAO;YAAG,eAAe,KAAO;YAChF,gBAAgB,KAAO;YAAG,gBAAgB,KAAO;YAAG,mBAAmB,KAAO;YAC9E,iBAAiB,KAAO;YAAG,iBAAiB,KAAO;YAAG,gBAAgB,KAAO;QAC/E;kBACG;;;;;;AAGP;GArFa;KAAA;AAuFN,MAAM,aAAa;;IACtB,MAAM,UAAU,IAAA,gOAAU,EAAC;IAC3B,IAAI,CAAC,SAAS,MAAM,IAAI,MAAM;IAC9B,OAAO;AACX;IAJa"}},
    {"offset": {"line": 280, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/lib/utils.ts"],"sourcesContent":["import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,GAAG,GAAG,MAAoB;IACxC,OAAO,IAAA,8NAAO,EAAC,IAAA,qMAAI,EAAC;AACtB"}},
    {"offset": {"line": 298, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/components/dashboard/RealisticAccountCard.tsx"],"sourcesContent":["\"use client\";\r\nimport { Account } from '@/types';\r\nimport { Wallet, Building2, Banknote, CreditCard } from 'lucide-react';\r\nimport { cn } from '@/lib/utils';\r\n\r\nexport default function RealisticAccountCard({ account }: { account: Account }) {\r\n  // Icono dinámico\r\n  const Icon = account.type === 'wallet' ? Wallet : \r\n               account.type === 'cash' ? Banknote : \r\n               account.type === 'bond' ? CreditCard : Building2;\r\n\r\n  // Color de borde y cuadrado basado en la elección del usuario\r\n  const cardColor = account.color || '#52525b'; // Zinc-600 default\r\n\r\n  return (\r\n    <div \r\n        className=\"relative overflow-hidden rounded-xl p-4 bg-zinc-900 border border-zinc-800 shadow-md transition-all hover:scale-[1.02]\"\r\n        style={{ borderLeft: `4px solid ${cardColor}` }}\r\n    >\r\n      <div className=\"flex justify-between items-start mb-3\">\r\n        <div className=\"flex items-center gap-3\">\r\n            {/* Cuadro de color pequeño */}\r\n            <div className=\"w-3 h-3 rounded-sm shadow-[0_0_10px_rgba(0,0,0,0.5)]\" style={{ backgroundColor: cardColor }} />\r\n            \r\n            {/* Nombre de la Cuenta (GRANDE) */}\r\n            <div>\r\n                <h3 className=\"text-lg font-bold text-white leading-tight\">{account.name}</h3>\r\n                {/* Detalles (Pequeño) */}\r\n                <p className=\"text-xs text-zinc-500 font-medium\">\r\n                    {account.bank} • <span className=\"text-zinc-400\">{account.owner}</span>\r\n                </p>\r\n            </div>\r\n        </div>\r\n        <Icon className=\"text-zinc-600 opacity-50\" size={20} />\r\n      </div>\r\n\r\n      <div className=\"flex justify-end items-end\">\r\n         <div className=\"text-right\">\r\n            <p className=\"text-[10px] text-zinc-600 uppercase tracking-wider font-bold\">Saldo Actual</p>\r\n            {/* Valor con color condicional */}\r\n            <p className={cn(\r\n                \"text-xl font-mono font-bold tracking-tight\",\r\n                account.balance >= 0 ? \"text-emerald-400\" : \"text-rose-400\"\r\n            )}>\r\n                ${account.balance.toLocaleString('es-CO')}\r\n            </p>\r\n         </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}"],"names":[],"mappings":";;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAHA;;;;AAKe,SAAS,qBAAqB,EAAE,OAAO,EAAwB;IAC5E,iBAAiB;IACjB,MAAM,OAAO,QAAQ,IAAI,KAAK,WAAW,wQAAM,GAClC,QAAQ,IAAI,KAAK,SAAS,8QAAQ,GAClC,QAAQ,IAAI,KAAK,SAAS,wRAAU,GAAG,qRAAS;IAE7D,8DAA8D;IAC9D,MAAM,YAAY,QAAQ,KAAK,IAAI,WAAW,mBAAmB;IAEjE,qBACE,kPAAC;QACG,WAAU;QACV,OAAO;YAAE,YAAY,CAAC,UAAU,EAAE,WAAW;QAAC;;0BAEhD,kPAAC;gBAAI,WAAU;;kCACb,kPAAC;wBAAI,WAAU;;0CAEX,kPAAC;gCAAI,WAAU;gCAAuD,OAAO;oCAAE,iBAAiB;gCAAU;;;;;;0CAG1G,kPAAC;;kDACG,kPAAC;wCAAG,WAAU;kDAA8C,QAAQ,IAAI;;;;;;kDAExE,kPAAC;wCAAE,WAAU;;4CACR,QAAQ,IAAI;4CAAC;0DAAG,kPAAC;gDAAK,WAAU;0DAAiB,QAAQ,KAAK;;;;;;;;;;;;;;;;;;;;;;;;kCAI3E,kPAAC;wBAAK,WAAU;wBAA2B,MAAM;;;;;;;;;;;;0BAGnD,kPAAC;gBAAI,WAAU;0BACZ,cAAA,kPAAC;oBAAI,WAAU;;sCACZ,kPAAC;4BAAE,WAAU;sCAA+D;;;;;;sCAE5E,kPAAC;4BAAE,WAAW,IAAA,0KAAE,EACZ,8CACA,QAAQ,OAAO,IAAI,IAAI,qBAAqB;;gCAC7C;gCACG,QAAQ,OAAO,CAAC,cAAc,CAAC;;;;;;;;;;;;;;;;;;;;;;;;AAMjD;KA7CwB"}},
    {"offset": {"line": 446, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/components/ui/button.tsx"],"sourcesContent":["import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-primary text-primary-foreground hover:bg-primary/90\",\n        destructive:\n          \"bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60\",\n        outline:\n          \"border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50\",\n        secondary:\n          \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        ghost:\n          \"hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-9 px-4 py-2 has-[>svg]:px-3\",\n        sm: \"h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5\",\n        lg: \"h-10 rounded-md px-6 has-[>svg]:px-4\",\n        icon: \"size-9\",\n        \"icon-sm\": \"size-8\",\n        \"icon-lg\": \"size-10\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nfunction Button({\n  className,\n  variant = \"default\",\n  size = \"default\",\n  asChild = false,\n  ...props\n}: React.ComponentProps<\"button\"> &\n  VariantProps<typeof buttonVariants> & {\n    asChild?: boolean\n  }) {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      data-slot=\"button\"\n      data-variant={variant}\n      data-size={size}\n      className={cn(buttonVariants({ variant, size, className }))}\n      {...props}\n    />\n  )\n}\n\nexport { Button, buttonVariants }\n"],"names":[],"mappings":";;;;;;;AACA;AACA;AAEA;;;;;AAEA,MAAM,iBAAiB,IAAA,+NAAG,EACxB,+bACA;IACE,UAAU;QACR,SAAS;YACP,SAAS;YACT,aACE;YACF,SACE;YACF,WACE;YACF,OACE;YACF,MAAM;QACR;QACA,MAAM;YACJ,SAAS;YACT,IAAI;YACJ,IAAI;YACJ,MAAM;YACN,WAAW;YACX,WAAW;QACb;IACF;IACA,iBAAiB;QACf,SAAS;QACT,MAAM;IACR;AACF;AAGF,SAAS,OAAO,EACd,SAAS,EACT,UAAU,SAAS,EACnB,OAAO,SAAS,EAChB,UAAU,KAAK,EACf,GAAG,OAIF;IACD,MAAM,OAAO,UAAU,gOAAI,GAAG;IAE9B,qBACE,kPAAC;QACC,aAAU;QACV,gBAAc;QACd,aAAW;QACX,WAAW,IAAA,0KAAE,EAAC,eAAe;YAAE;YAAS;YAAM;QAAU;QACvD,GAAG,KAAK;;;;;;AAGf;KArBS"}},
    {"offset": {"line": 513, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/components/dashboard/AccountsSidebar.tsx"],"sourcesContent":["// components/dashboard/AccountsSidebar.tsx\r\n\"use client\";\r\nimport { useState } from 'react';\r\nimport { useFinance } from '@/context/FinanceContext';\r\nimport RealisticAccountCard from './RealisticAccountCard';\r\nimport { Button } from '@/components/ui/button';\r\nimport { ChevronRight, Wallet, Home, Calculator, Settings } from 'lucide-react';\r\nimport Link from 'next/link'; \r\nimport { cn } from '@/lib/utils';\r\nimport { usePathname } from 'next/navigation'; \r\n\r\ninterface Props {\r\n    className?: string;\r\n}\r\n\r\nexport default function AccountsSidebar({ className }: Props) {\r\n  const { accounts } = useFinance();\r\n  const [isOpen, setIsOpen] = useState(false);\r\n  const visibleAccounts = accounts.filter(a => !a.isHidden);\r\n  const totalBalance = visibleAccounts.reduce((sum, acc) => sum + acc.balance, 0);\r\n  \r\n  const pathname = usePathname();\r\n\r\n  const navClass = (path: string) => cn(\r\n      \"flex items-center gap-3 p-3 rounded-lg transition-colors font-medium text-sm\",\r\n      pathname === path ? \"bg-indigo-900/50 text-indigo-400\" : \"text-zinc-400 hover:bg-zinc-900 hover:text-zinc-100\"\r\n  );\r\n\r\n  return (\r\n    <>\r\n      <Button \r\n        variant=\"default\" size=\"icon\" onClick={() => setIsOpen(!isOpen)}\r\n        className={cn(\r\n            \"fixed top-24 right-0 z-50 rounded-l-xl rounded-r-none shadow-xl transition-all duration-300 bg-indigo-600 w-8 h-12 md:hidden\", \r\n            isOpen ? \"mr-[320px]\" : \"mr-0\"\r\n        )}\r\n      >\r\n        {isOpen ? <ChevronRight /> : <Wallet className=\"h-4 w-4\" />}\r\n      </Button>\r\n\r\n      {isOpen && <div className=\"fixed inset-0 bg-black/50 z-40 md:hidden\" onClick={() => setIsOpen(false)} />}\r\n\r\n      <aside className={cn(\r\n          \"fixed top-0 bottom-0 right-0 z-50 w-[320px] bg-zinc-950 border-l border-zinc-800 shadow-2xl transition-transform duration-300 ease-in-out flex flex-col\",\r\n          isOpen ? \"translate-x-0\" : \"translate-x-full md:translate-x-0\", // Siempre visible en Desktop\r\n          className \r\n      )}>\r\n        \r\n        {/* NAVEGACIÓN DESKTOP Y MOBILE */}\r\n        <div className=\"p-4 border-b border-zinc-900 bg-zinc-950\">\r\n            <h2 className=\"text-xs font-bold text-zinc-600 uppercase tracking-widest mb-2 px-2\">Menú</h2>\r\n            <nav className=\"space-y-1\">\r\n                <Link href=\"/\" className={navClass('/')}>\r\n                    <Home size={18} /> Resumen General\r\n                </Link>\r\n                <Link href=\"/simulator\" className={navClass('/simulator')}>\r\n                    <Calculator size={18} /> Simulador Mensual\r\n                </Link>\r\n                <Link href=\"/admin\" className={navClass('/admin')}>\r\n                    <Settings size={18} /> Configuración\r\n                </Link>\r\n            </nav>\r\n        </div>\r\n\r\n        <div className=\"p-4 border-b border-zinc-900 bg-zinc-950\">\r\n           <h2 className=\"text-sm font-bold text-zinc-400 flex items-center gap-2 mb-4 px-2\">\r\n                <Wallet className=\"text-indigo-500 h-4 w-4\" /> Cuentas Activas\r\n            </h2>\r\n            <div className=\"p-4 bg-zinc-900/50 rounded-xl border border-zinc-800/50 text-center\">\r\n                <p className=\"text-[10px] text-zinc-500 uppercase tracking-widest font-bold\">Patrimonio Total</p>\r\n                <p className={cn(\"text-2xl font-extrabold mt-1\", totalBalance >= 0 ? \"text-emerald-400\" : \"text-rose-400\")}>\r\n                    ${totalBalance.toLocaleString('es-CO')}\r\n                </p>\r\n            </div>\r\n        </div>\r\n\r\n        <div className=\"flex-1 overflow-y-auto p-4 space-y-3 pb-20 scrollbar-thin scrollbar-thumb-zinc-800\">\r\n          {visibleAccounts.length === 0 && <p className=\"text-center text-xs text-zinc-600 mt-10\">No hay cuentas creadas aún.</p>}\r\n          {visibleAccounts.map(acc => (\r\n            <RealisticAccountCard key={acc.id} account={acc} />\r\n          ))}\r\n        </div>\r\n      </aside>\r\n    </>\r\n  );\r\n}"],"names":[],"mappings":"AAAA,2CAA2C;;;;;;AAE3C;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;AARA;;;;;;;;;AAce,SAAS,gBAAgB,EAAE,SAAS,EAAS;;IAC1D,MAAM,EAAE,QAAQ,EAAE,GAAG,IAAA,gMAAU;IAC/B,MAAM,CAAC,QAAQ,UAAU,GAAG,IAAA,8NAAQ,EAAC;IACrC,MAAM,kBAAkB,SAAS,MAAM,CAAC,CAAA,IAAK,CAAC,EAAE,QAAQ;IACxD,MAAM,eAAe,gBAAgB,MAAM,CAAC,CAAC,KAAK,MAAQ,MAAM,IAAI,OAAO,EAAE;IAE7E,MAAM,WAAW,IAAA,yMAAW;IAE5B,MAAM,WAAW,CAAC,OAAiB,IAAA,0KAAE,EACjC,gFACA,aAAa,OAAO,qCAAqC;IAG7D,qBACE;;0BACE,kPAAC,6LAAM;gBACL,SAAQ;gBAAU,MAAK;gBAAO,SAAS,IAAM,UAAU,CAAC;gBACxD,WAAW,IAAA,0KAAE,EACT,gIACA,SAAS,eAAe;0BAG3B,uBAAS,kPAAC,8RAAY;;;;yCAAM,kPAAC,wQAAM;oBAAC,WAAU;;;;;;;;;;;YAGhD,wBAAU,kPAAC;gBAAI,WAAU;gBAA2C,SAAS,IAAM,UAAU;;;;;;0BAE9F,kPAAC;gBAAM,WAAW,IAAA,0KAAE,EAChB,2JACA,SAAS,kBAAkB,qCAC3B;;kCAIF,kPAAC;wBAAI,WAAU;;0CACX,kPAAC;gCAAG,WAAU;0CAAsE;;;;;;0CACpF,kPAAC;gCAAI,WAAU;;kDACX,kPAAC,+NAAI;wCAAC,MAAK;wCAAI,WAAW,SAAS;;0DAC/B,kPAAC,mQAAI;gDAAC,MAAM;;;;;;4CAAM;;;;;;;kDAEtB,kPAAC,+NAAI;wCAAC,MAAK;wCAAa,WAAW,SAAS;;0DACxC,kPAAC,oRAAU;gDAAC,MAAM;;;;;;4CAAM;;;;;;;kDAE5B,kPAAC,+NAAI;wCAAC,MAAK;wCAAS,WAAW,SAAS;;0DACpC,kPAAC,8QAAQ;gDAAC,MAAM;;;;;;4CAAM;;;;;;;;;;;;;;;;;;;kCAKlC,kPAAC;wBAAI,WAAU;;0CACZ,kPAAC;gCAAG,WAAU;;kDACT,kPAAC,wQAAM;wCAAC,WAAU;;;;;;oCAA4B;;;;;;;0CAElD,kPAAC;gCAAI,WAAU;;kDACX,kPAAC;wCAAE,WAAU;kDAAgE;;;;;;kDAC7E,kPAAC;wCAAE,WAAW,IAAA,0KAAE,EAAC,gCAAgC,gBAAgB,IAAI,qBAAqB;;4CAAkB;4CACtG,aAAa,cAAc,CAAC;;;;;;;;;;;;;;;;;;;kCAK1C,kPAAC;wBAAI,WAAU;;4BACZ,gBAAgB,MAAM,KAAK,mBAAK,kPAAC;gCAAE,WAAU;0CAA0C;;;;;;4BACvF,gBAAgB,GAAG,CAAC,CAAA,oBACnB,kPAAC,mNAAoB;oCAAc,SAAS;mCAAjB,IAAI,EAAE;;;;;;;;;;;;;;;;;;;AAM7C;GAtEwB;;QACD,gMAAU;QAKd,yMAAW;;;KANN"}},
    {"offset": {"line": 767, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/components/ui/sonner.tsx"],"sourcesContent":["\"use client\"\n\nimport {\n  CircleCheckIcon,\n  InfoIcon,\n  Loader2Icon,\n  OctagonXIcon,\n  TriangleAlertIcon,\n} from \"lucide-react\"\nimport { useTheme } from \"next-themes\"\nimport { Toaster as Sonner, type ToasterProps } from \"sonner\"\n\nconst Toaster = ({ ...props }: ToasterProps) => {\n  const { theme = \"system\" } = useTheme()\n\n  return (\n    <Sonner\n      theme={theme as ToasterProps[\"theme\"]}\n      className=\"toaster group\"\n      icons={{\n        success: <CircleCheckIcon className=\"size-4\" />,\n        info: <InfoIcon className=\"size-4\" />,\n        warning: <TriangleAlertIcon className=\"size-4\" />,\n        error: <OctagonXIcon className=\"size-4\" />,\n        loading: <Loader2Icon className=\"size-4 animate-spin\" />,\n      }}\n      style={\n        {\n          \"--normal-bg\": \"var(--popover)\",\n          \"--normal-text\": \"var(--popover-foreground)\",\n          \"--normal-border\": \"var(--border)\",\n          \"--border-radius\": \"var(--radius)\",\n        } as React.CSSProperties\n      }\n      {...props}\n    />\n  )\n}\n\nexport { Toaster }\n"],"names":[],"mappings":";;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAOA;AACA;;;AAVA;;;;AAYA,MAAM,UAAU,CAAC,EAAE,GAAG,OAAqB;;IACzC,MAAM,EAAE,QAAQ,QAAQ,EAAE,GAAG,IAAA,oNAAQ;IAErC,qBACE,kPAAC,2MAAM;QACL,OAAO;QACP,WAAU;QACV,OAAO;YACL,uBAAS,kPAAC,mSAAe;gBAAC,WAAU;;;;;;YACpC,oBAAM,kPAAC,0QAAQ;gBAAC,WAAU;;;;;;YAC1B,uBAAS,kPAAC,ySAAiB;gBAAC,WAAU;;;;;;YACtC,qBAAO,kPAAC,0RAAY;gBAAC,WAAU;;;;;;YAC/B,uBAAS,kPAAC,4RAAW;gBAAC,WAAU;;;;;;QAClC;QACA,OACE;YACE,eAAe;YACf,iBAAiB;YACjB,mBAAmB;YACnB,mBAAmB;QACrB;QAED,GAAG,KAAK;;;;;;AAGf;GAzBM;;QACyB,oNAAQ;;;KADjC"}}]
}