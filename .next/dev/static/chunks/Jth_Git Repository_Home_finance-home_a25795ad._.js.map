{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/components/ui/input.tsx"],"sourcesContent":["import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Input({ className, type, ...props }: React.ComponentProps<\"input\">) {\n  return (\n    <input\n      type={type}\n      data-slot=\"input\"\n      className={cn(\n        \"file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n        \"focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]\",\n        \"aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Input }\n"],"names":[],"mappings":";;;;;AAEA;;;AAEA,SAAS,MAAM,EAAE,SAAS,EAAE,IAAI,EAAE,GAAG,OAAsC;IACzE,qBACE,kPAAC;QACC,MAAM;QACN,aAAU;QACV,WAAW,IAAA,0KAAE,EACX,8bACA,iFACA,0GACA;QAED,GAAG,KAAK;;;;;;AAGf;KAdS"}},
    {"offset": {"line": 35, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    return await verifyToken(token);\r\n}\r\n\r\n// --- NUEVA ACCIÓN: CREAR USUARIO (Para el botón Admin) ---\r\nexport async function createNewUser(email: string, name: string, householdId: string) {\r\n    const currentUser = await getCurrentUser();\r\n    // Validación de seguridad básica: Solo tú puedes crear usuarios\r\n    if (currentUser?.email !== 'jhonattan.gonzalez.38@gmail.com') {\r\n        return { success: false, message: 'No autorizado' };\r\n    }\r\n\r\n    try {\r\n        const existing = await prisma.user.findUnique({ where: { email } });\r\n        if (existing) return { success: false, message: 'El usuario ya existe.' };\r\n\r\n        await prisma.user.create({\r\n            data: {\r\n                email,\r\n                name,\r\n                householdId,\r\n                token: 'INIT', // Token inicial placeholder\r\n              }\r\n          });\r\n        \r\n        return { success: true, message: 'Usuario creado exitosamente.' };\r\n    } catch (error) {\r\n        return { success: false, message: 'Error creando usuario en BD.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n\r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    if (!user || user.token !== token) {\r\n        return { success: false, message: 'Código incorrecto.' };\r\n    }\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n    \r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO (SOLICITUD) ---\r\n// Actualizada para recibir el NOMBRE también\r\nexport async function requestRegistration(email: string, name: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        // Enviamos nombre, email y familia al correo\r\n        await sendRegistrationRequestEmail(email, name, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('is_demo_mode', 'true', { path: '/' });\r\n    cookieStore.delete('auth_token');\r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' } \r\n        };\r\n    }\r\n\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; \r\n    }\r\n\r\n    const householdId = user.householdId; \r\n\r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({ \r\n        where: { householdId }, orderBy: { date: 'desc' } \r\n    });\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user,\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES Y UPDATES (Igual que antes, solo asegúrate que estén aquí) ---\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    // Forzamos la fecha para evitar desfase de zona horaria\r\n    const date = new Date(data.date);\r\n\r\n    if (data.type === 'transfer') {\r\n        // ... (Lógica de transferencia se mantiene IGUAL) ...\r\n        await prisma.transaction.create({ data: { householdId, type: 'expense', amount: data.amount, accountId: data.accountId, description: `Transferencia a: ${data.destAccountName}`, date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true } });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n        await prisma.transaction.create({ data: { householdId, type: 'income', amount: data.amount, accountId: data.relatedAccountId, description: `Recibido de: ${data.originAccountName}`, date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false } });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } else {\r\n        // Lógica de Ingreso/Gasto normal\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        \r\n        await prisma.transaction.create({\r\n            data: { \r\n                householdId, \r\n                type: data.type, \r\n                amount: data.amount, \r\n                budgetedAmount: data.budgetedAmount, \r\n                accountId: data.accountId, \r\n                categoryId: data.categoryId, \r\n                description: data.description, \r\n                date, \r\n                isFixed: data.isFixed || false, \r\n                isSavings: data.isSavings || false, \r\n                didWithdraw: data.didWithdraw ?? true \r\n            }\r\n        });\r\n\r\n        if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }\r\n\r\n        // --- LÓGICA DE AHORRO ---\r\n        if (data.isSavings) {\r\n            // ... (Lógica de ahorro se mantiene IGUAL) ...\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) {\r\n                savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            }\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n\r\n        // --- NUEVA LÓGICA: CREAR REGLA FIJA DESDE TRANSACCIÓN ---\r\n        // Si el usuario marcó \"Guardar como recurrente\"\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: {\r\n                    householdId,\r\n                    description: data.description,\r\n                    categoryId: data.categoryId,\r\n                    budgetedAmount: data.amount,\r\n                    accountIdToCharge: data.accountId,\r\n                    dayOfMonth: data.dayOfMonth || date.getDate(), // Usa el día seleccionado o el de la fecha\r\n                    isActive: true\r\n                }\r\n            });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');\r\n}\r\n\r\n// Funciones CRUD CRUD estándar\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId, name: 'Jhonattan' },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId, name: 'Jhonattan' }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId, name: 'Thannia' },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId, name: 'Thannia' }\r\n    });\r\n\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}"],"names":[],"mappings":";;;;;;;IAyEsB,cAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 50, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    return await verifyToken(token);\r\n}\r\n\r\n// --- NUEVA ACCIÓN: CREAR USUARIO (Para el botón Admin) ---\r\nexport async function createNewUser(email: string, name: string, householdId: string) {\r\n    const currentUser = await getCurrentUser();\r\n    // Validación de seguridad básica: Solo tú puedes crear usuarios\r\n    if (currentUser?.email !== 'jhonattan.gonzalez.38@gmail.com') {\r\n        return { success: false, message: 'No autorizado' };\r\n    }\r\n\r\n    try {\r\n        const existing = await prisma.user.findUnique({ where: { email } });\r\n        if (existing) return { success: false, message: 'El usuario ya existe.' };\r\n\r\n        await prisma.user.create({\r\n            data: {\r\n                email,\r\n                name,\r\n                householdId,\r\n                token: 'INIT', // Token inicial placeholder\r\n              }\r\n          });\r\n        \r\n        return { success: true, message: 'Usuario creado exitosamente.' };\r\n    } catch (error) {\r\n        return { success: false, message: 'Error creando usuario en BD.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n\r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    if (!user || user.token !== token) {\r\n        return { success: false, message: 'Código incorrecto.' };\r\n    }\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n    \r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO (SOLICITUD) ---\r\n// Actualizada para recibir el NOMBRE también\r\nexport async function requestRegistration(email: string, name: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        // Enviamos nombre, email y familia al correo\r\n        await sendRegistrationRequestEmail(email, name, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('is_demo_mode', 'true', { path: '/' });\r\n    cookieStore.delete('auth_token');\r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' } \r\n        };\r\n    }\r\n\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; \r\n    }\r\n\r\n    const householdId = user.householdId; \r\n\r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({ \r\n        where: { householdId }, orderBy: { date: 'desc' } \r\n    });\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user,\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES Y UPDATES (Igual que antes, solo asegúrate que estén aquí) ---\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    // Forzamos la fecha para evitar desfase de zona horaria\r\n    const date = new Date(data.date);\r\n\r\n    if (data.type === 'transfer') {\r\n        // ... (Lógica de transferencia se mantiene IGUAL) ...\r\n        await prisma.transaction.create({ data: { householdId, type: 'expense', amount: data.amount, accountId: data.accountId, description: `Transferencia a: ${data.destAccountName}`, date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true } });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n        await prisma.transaction.create({ data: { householdId, type: 'income', amount: data.amount, accountId: data.relatedAccountId, description: `Recibido de: ${data.originAccountName}`, date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false } });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } else {\r\n        // Lógica de Ingreso/Gasto normal\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        \r\n        await prisma.transaction.create({\r\n            data: { \r\n                householdId, \r\n                type: data.type, \r\n                amount: data.amount, \r\n                budgetedAmount: data.budgetedAmount, \r\n                accountId: data.accountId, \r\n                categoryId: data.categoryId, \r\n                description: data.description, \r\n                date, \r\n                isFixed: data.isFixed || false, \r\n                isSavings: data.isSavings || false, \r\n                didWithdraw: data.didWithdraw ?? true \r\n            }\r\n        });\r\n\r\n        if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }\r\n\r\n        // --- LÓGICA DE AHORRO ---\r\n        if (data.isSavings) {\r\n            // ... (Lógica de ahorro se mantiene IGUAL) ...\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) {\r\n                savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            }\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n\r\n        // --- NUEVA LÓGICA: CREAR REGLA FIJA DESDE TRANSACCIÓN ---\r\n        // Si el usuario marcó \"Guardar como recurrente\"\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: {\r\n                    householdId,\r\n                    description: data.description,\r\n                    categoryId: data.categoryId,\r\n                    budgetedAmount: data.amount,\r\n                    accountIdToCharge: data.accountId,\r\n                    dayOfMonth: data.dayOfMonth || date.getDate(), // Usa el día seleccionado o el de la fecha\r\n                    isActive: true\r\n                }\r\n            });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');\r\n}\r\n\r\n// Funciones CRUD CRUD estándar\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId, name: 'Jhonattan' },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId, name: 'Jhonattan' }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId, name: 'Thannia' },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId, name: 'Thannia' }\r\n    });\r\n\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}"],"names":[],"mappings":";;;;;;;IAkHsB,oBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 65, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    return await verifyToken(token);\r\n}\r\n\r\n// --- NUEVA ACCIÓN: CREAR USUARIO (Para el botón Admin) ---\r\nexport async function createNewUser(email: string, name: string, householdId: string) {\r\n    const currentUser = await getCurrentUser();\r\n    // Validación de seguridad básica: Solo tú puedes crear usuarios\r\n    if (currentUser?.email !== 'jhonattan.gonzalez.38@gmail.com') {\r\n        return { success: false, message: 'No autorizado' };\r\n    }\r\n\r\n    try {\r\n        const existing = await prisma.user.findUnique({ where: { email } });\r\n        if (existing) return { success: false, message: 'El usuario ya existe.' };\r\n\r\n        await prisma.user.create({\r\n            data: {\r\n                email,\r\n                name,\r\n                householdId,\r\n                token: 'INIT', // Token inicial placeholder\r\n              }\r\n          });\r\n        \r\n        return { success: true, message: 'Usuario creado exitosamente.' };\r\n    } catch (error) {\r\n        return { success: false, message: 'Error creando usuario en BD.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n\r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    if (!user || user.token !== token) {\r\n        return { success: false, message: 'Código incorrecto.' };\r\n    }\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n    \r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO (SOLICITUD) ---\r\n// Actualizada para recibir el NOMBRE también\r\nexport async function requestRegistration(email: string, name: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        // Enviamos nombre, email y familia al correo\r\n        await sendRegistrationRequestEmail(email, name, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('is_demo_mode', 'true', { path: '/' });\r\n    cookieStore.delete('auth_token');\r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' } \r\n        };\r\n    }\r\n\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; \r\n    }\r\n\r\n    const householdId = user.householdId; \r\n\r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({ \r\n        where: { householdId }, orderBy: { date: 'desc' } \r\n    });\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user,\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES Y UPDATES (Igual que antes, solo asegúrate que estén aquí) ---\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    // Forzamos la fecha para evitar desfase de zona horaria\r\n    const date = new Date(data.date);\r\n\r\n    if (data.type === 'transfer') {\r\n        // ... (Lógica de transferencia se mantiene IGUAL) ...\r\n        await prisma.transaction.create({ data: { householdId, type: 'expense', amount: data.amount, accountId: data.accountId, description: `Transferencia a: ${data.destAccountName}`, date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true } });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n        await prisma.transaction.create({ data: { householdId, type: 'income', amount: data.amount, accountId: data.relatedAccountId, description: `Recibido de: ${data.originAccountName}`, date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false } });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } else {\r\n        // Lógica de Ingreso/Gasto normal\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        \r\n        await prisma.transaction.create({\r\n            data: { \r\n                householdId, \r\n                type: data.type, \r\n                amount: data.amount, \r\n                budgetedAmount: data.budgetedAmount, \r\n                accountId: data.accountId, \r\n                categoryId: data.categoryId, \r\n                description: data.description, \r\n                date, \r\n                isFixed: data.isFixed || false, \r\n                isSavings: data.isSavings || false, \r\n                didWithdraw: data.didWithdraw ?? true \r\n            }\r\n        });\r\n\r\n        if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }\r\n\r\n        // --- LÓGICA DE AHORRO ---\r\n        if (data.isSavings) {\r\n            // ... (Lógica de ahorro se mantiene IGUAL) ...\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) {\r\n                savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            }\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n\r\n        // --- NUEVA LÓGICA: CREAR REGLA FIJA DESDE TRANSACCIÓN ---\r\n        // Si el usuario marcó \"Guardar como recurrente\"\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: {\r\n                    householdId,\r\n                    description: data.description,\r\n                    categoryId: data.categoryId,\r\n                    budgetedAmount: data.amount,\r\n                    accountIdToCharge: data.accountId,\r\n                    dayOfMonth: data.dayOfMonth || date.getDate(), // Usa el día seleccionado o el de la fecha\r\n                    isActive: true\r\n                }\r\n            });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');\r\n}\r\n\r\n// Funciones CRUD CRUD estándar\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId, name: 'Jhonattan' },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId, name: 'Jhonattan' }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId, name: 'Thannia' },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId, name: 'Thannia' }\r\n    });\r\n\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}"],"names":[],"mappings":";;;;;;;IAiDsB,mBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 80, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    return await verifyToken(token);\r\n}\r\n\r\n// --- NUEVA ACCIÓN: CREAR USUARIO (Para el botón Admin) ---\r\nexport async function createNewUser(email: string, name: string, householdId: string) {\r\n    const currentUser = await getCurrentUser();\r\n    // Validación de seguridad básica: Solo tú puedes crear usuarios\r\n    if (currentUser?.email !== 'jhonattan.gonzalez.38@gmail.com') {\r\n        return { success: false, message: 'No autorizado' };\r\n    }\r\n\r\n    try {\r\n        const existing = await prisma.user.findUnique({ where: { email } });\r\n        if (existing) return { success: false, message: 'El usuario ya existe.' };\r\n\r\n        await prisma.user.create({\r\n            data: {\r\n                email,\r\n                name,\r\n                householdId,\r\n                token: 'INIT', // Token inicial placeholder\r\n              }\r\n          });\r\n        \r\n        return { success: true, message: 'Usuario creado exitosamente.' };\r\n    } catch (error) {\r\n        return { success: false, message: 'Error creando usuario en BD.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n\r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    if (!user || user.token !== token) {\r\n        return { success: false, message: 'Código incorrecto.' };\r\n    }\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n    \r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO (SOLICITUD) ---\r\n// Actualizada para recibir el NOMBRE también\r\nexport async function requestRegistration(email: string, name: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        // Enviamos nombre, email y familia al correo\r\n        await sendRegistrationRequestEmail(email, name, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('is_demo_mode', 'true', { path: '/' });\r\n    cookieStore.delete('auth_token');\r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' } \r\n        };\r\n    }\r\n\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; \r\n    }\r\n\r\n    const householdId = user.householdId; \r\n\r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({ \r\n        where: { householdId }, orderBy: { date: 'desc' } \r\n    });\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user,\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES Y UPDATES (Igual que antes, solo asegúrate que estén aquí) ---\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    // Forzamos la fecha para evitar desfase de zona horaria\r\n    const date = new Date(data.date);\r\n\r\n    if (data.type === 'transfer') {\r\n        // ... (Lógica de transferencia se mantiene IGUAL) ...\r\n        await prisma.transaction.create({ data: { householdId, type: 'expense', amount: data.amount, accountId: data.accountId, description: `Transferencia a: ${data.destAccountName}`, date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true } });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n        await prisma.transaction.create({ data: { householdId, type: 'income', amount: data.amount, accountId: data.relatedAccountId, description: `Recibido de: ${data.originAccountName}`, date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false } });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } else {\r\n        // Lógica de Ingreso/Gasto normal\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        \r\n        await prisma.transaction.create({\r\n            data: { \r\n                householdId, \r\n                type: data.type, \r\n                amount: data.amount, \r\n                budgetedAmount: data.budgetedAmount, \r\n                accountId: data.accountId, \r\n                categoryId: data.categoryId, \r\n                description: data.description, \r\n                date, \r\n                isFixed: data.isFixed || false, \r\n                isSavings: data.isSavings || false, \r\n                didWithdraw: data.didWithdraw ?? true \r\n            }\r\n        });\r\n\r\n        if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }\r\n\r\n        // --- LÓGICA DE AHORRO ---\r\n        if (data.isSavings) {\r\n            // ... (Lógica de ahorro se mantiene IGUAL) ...\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) {\r\n                savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            }\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n\r\n        // --- NUEVA LÓGICA: CREAR REGLA FIJA DESDE TRANSACCIÓN ---\r\n        // Si el usuario marcó \"Guardar como recurrente\"\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: {\r\n                    householdId,\r\n                    description: data.description,\r\n                    categoryId: data.categoryId,\r\n                    budgetedAmount: data.amount,\r\n                    accountIdToCharge: data.accountId,\r\n                    dayOfMonth: data.dayOfMonth || date.getDate(), // Usa el día seleccionado o el de la fecha\r\n                    isActive: true\r\n                }\r\n            });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');\r\n}\r\n\r\n// Funciones CRUD CRUD estándar\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId, name: 'Jhonattan' },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId, name: 'Jhonattan' }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId, name: 'Thannia' },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId, name: 'Thannia' }\r\n    });\r\n\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}"],"names":[],"mappings":";;;;;;;IAoGsB,sBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 95, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    return await verifyToken(token);\r\n}\r\n\r\n// --- NUEVA ACCIÓN: CREAR USUARIO (Para el botón Admin) ---\r\nexport async function createNewUser(email: string, name: string, householdId: string) {\r\n    const currentUser = await getCurrentUser();\r\n    // Validación de seguridad básica: Solo tú puedes crear usuarios\r\n    if (currentUser?.email !== 'jhonattan.gonzalez.38@gmail.com') {\r\n        return { success: false, message: 'No autorizado' };\r\n    }\r\n\r\n    try {\r\n        const existing = await prisma.user.findUnique({ where: { email } });\r\n        if (existing) return { success: false, message: 'El usuario ya existe.' };\r\n\r\n        await prisma.user.create({\r\n            data: {\r\n                email,\r\n                name,\r\n                householdId,\r\n                token: 'INIT', // Token inicial placeholder\r\n              }\r\n          });\r\n        \r\n        return { success: true, message: 'Usuario creado exitosamente.' };\r\n    } catch (error) {\r\n        return { success: false, message: 'Error creando usuario en BD.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n\r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    if (!user || user.token !== token) {\r\n        return { success: false, message: 'Código incorrecto.' };\r\n    }\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n    \r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO (SOLICITUD) ---\r\n// Actualizada para recibir el NOMBRE también\r\nexport async function requestRegistration(email: string, name: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        // Enviamos nombre, email y familia al correo\r\n        await sendRegistrationRequestEmail(email, name, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('is_demo_mode', 'true', { path: '/' });\r\n    cookieStore.delete('auth_token');\r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' } \r\n        };\r\n    }\r\n\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; \r\n    }\r\n\r\n    const householdId = user.householdId; \r\n\r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({ \r\n        where: { householdId }, orderBy: { date: 'desc' } \r\n    });\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user,\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES Y UPDATES (Igual que antes, solo asegúrate que estén aquí) ---\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    // Forzamos la fecha para evitar desfase de zona horaria\r\n    const date = new Date(data.date);\r\n\r\n    if (data.type === 'transfer') {\r\n        // ... (Lógica de transferencia se mantiene IGUAL) ...\r\n        await prisma.transaction.create({ data: { householdId, type: 'expense', amount: data.amount, accountId: data.accountId, description: `Transferencia a: ${data.destAccountName}`, date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true } });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n        await prisma.transaction.create({ data: { householdId, type: 'income', amount: data.amount, accountId: data.relatedAccountId, description: `Recibido de: ${data.originAccountName}`, date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false } });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } else {\r\n        // Lógica de Ingreso/Gasto normal\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        \r\n        await prisma.transaction.create({\r\n            data: { \r\n                householdId, \r\n                type: data.type, \r\n                amount: data.amount, \r\n                budgetedAmount: data.budgetedAmount, \r\n                accountId: data.accountId, \r\n                categoryId: data.categoryId, \r\n                description: data.description, \r\n                date, \r\n                isFixed: data.isFixed || false, \r\n                isSavings: data.isSavings || false, \r\n                didWithdraw: data.didWithdraw ?? true \r\n            }\r\n        });\r\n\r\n        if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }\r\n\r\n        // --- LÓGICA DE AHORRO ---\r\n        if (data.isSavings) {\r\n            // ... (Lógica de ahorro se mantiene IGUAL) ...\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) {\r\n                savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            }\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n\r\n        // --- NUEVA LÓGICA: CREAR REGLA FIJA DESDE TRANSACCIÓN ---\r\n        // Si el usuario marcó \"Guardar como recurrente\"\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: {\r\n                    householdId,\r\n                    description: data.description,\r\n                    categoryId: data.categoryId,\r\n                    budgetedAmount: data.amount,\r\n                    accountIdToCharge: data.accountId,\r\n                    dayOfMonth: data.dayOfMonth || date.getDate(), // Usa el día seleccionado o el de la fecha\r\n                    isActive: true\r\n                }\r\n            });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');\r\n}\r\n\r\n// Funciones CRUD CRUD estándar\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId, name: 'Jhonattan' },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId, name: 'Jhonattan' }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId, name: 'Thannia' },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId, name: 'Thannia' }\r\n    });\r\n\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}"],"names":[],"mappings":";;;;;;;IA8PsB,eAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 110, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/components/ui/tabs.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as TabsPrimitive from \"@radix-ui/react-tabs\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Tabs({\n  className,\n  ...props\n}: React.ComponentProps<typeof TabsPrimitive.Root>) {\n  return (\n    <TabsPrimitive.Root\n      data-slot=\"tabs\"\n      className={cn(\"flex flex-col gap-2\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction TabsList({\n  className,\n  ...props\n}: React.ComponentProps<typeof TabsPrimitive.List>) {\n  return (\n    <TabsPrimitive.List\n      data-slot=\"tabs-list\"\n      className={cn(\n        \"bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction TabsTrigger({\n  className,\n  ...props\n}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {\n  return (\n    <TabsPrimitive.Trigger\n      data-slot=\"tabs-trigger\"\n      className={cn(\n        \"data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction TabsContent({\n  className,\n  ...props\n}: React.ComponentProps<typeof TabsPrimitive.Content>) {\n  return (\n    <TabsPrimitive.Content\n      data-slot=\"tabs-content\"\n      className={cn(\"flex-1 outline-none\", className)}\n      {...props}\n    />\n  )\n}\n\nexport { Tabs, TabsList, TabsTrigger, TabsContent }\n"],"names":[],"mappings":";;;;;;;;;;;AAGA;AAEA;AALA;;;;AAOA,SAAS,KAAK,EACZ,SAAS,EACT,GAAG,OAC6C;IAChD,qBACE,kPAAC,gOAAkB;QACjB,aAAU;QACV,WAAW,IAAA,0KAAE,EAAC,uBAAuB;QACpC,GAAG,KAAK;;;;;;AAGf;KAXS;AAaT,SAAS,SAAS,EAChB,SAAS,EACT,GAAG,OAC6C;IAChD,qBACE,kPAAC,gOAAkB;QACjB,aAAU;QACV,WAAW,IAAA,0KAAE,EACX,uGACA;QAED,GAAG,KAAK;;;;;;AAGf;MAdS;AAgBT,SAAS,YAAY,EACnB,SAAS,EACT,GAAG,OACgD;IACnD,qBACE,kPAAC,mOAAqB;QACpB,aAAU;QACV,WAAW,IAAA,0KAAE,EACX,mqBACA;QAED,GAAG,KAAK;;;;;;AAGf;MAdS;AAgBT,SAAS,YAAY,EACnB,SAAS,EACT,GAAG,OACgD;IACnD,qBACE,kPAAC,mOAAqB;QACpB,aAAU;QACV,WAAW,IAAA,0KAAE,EAAC,uBAAuB;QACpC,GAAG,KAAK;;;;;;AAGf;MAXS"}},
    {"offset": {"line": 188, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/login/page.tsx"],"sourcesContent":["\"use client\";\r\nimport { useState, useEffect } from 'react';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Input } from '@/components/ui/input';\r\nimport { loginAction, setDemoModeAction, requestLoginCode, requestRegistration, seedDatabase } from '@/app/actions';\r\nimport { useRouter } from 'next/navigation';\r\nimport { Lock, Eye, Mail, ArrowRight, UserPlus, Users, Info, User } from 'lucide-react';\r\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"@/components/ui/tabs\";\r\n\r\nexport default function LoginPage() {\r\n  const router = useRouter();\r\n  const [email, setEmail] = useState('');\r\n  const [token, setToken] = useState('');\r\n  \r\n  // NUEVO ESTADO: Nombre\r\n  const [name, setName] = useState('');\r\n  const [familyName, setFamilyName] = useState('');\r\n  \r\n  const [step, setStep] = useState(1);\r\n  const [loading, setLoading] = useState(false);\r\n\r\n  useEffect(() => {\r\n      seedDatabase().catch(() => {});\r\n  }, []);\r\n\r\n  const handleRequestCode = async (e: React.FormEvent) => {\r\n      e.preventDefault();\r\n      setLoading(true);\r\n      const res = await requestLoginCode(email);\r\n      setLoading(false);\r\n      \r\n      if (res.success) {\r\n          setStep(2);\r\n      } else {\r\n          alert(res.message);\r\n      }\r\n  };\r\n\r\n  const handleLogin = async (e: React.FormEvent) => {\r\n      e.preventDefault();\r\n      setLoading(true);\r\n      const res = await loginAction(email, token);\r\n      if (res.success) {\r\n          window.location.href = '/'; \r\n      } else {\r\n          alert(\"Código incorrecto\");\r\n          setLoading(false);\r\n      }\r\n  };\r\n\r\n  const handleRegister = async (e: React.FormEvent) => {\r\n      e.preventDefault();\r\n      setLoading(true);\r\n      // ENVIAMOS TAMBIÉN EL NOMBRE\r\n      const res = await requestRegistration(email, name, familyName);\r\n      setLoading(false);\r\n      if (res.success) alert(\"✅ Solicitud enviada al administrador.\");\r\n      else alert(\"Error: \" + res.message);\r\n  };\r\n\r\n  const handleDemo = async () => {\r\n      setLoading(true);\r\n      await setDemoModeAction();\r\n      window.location.href = '/';\r\n  };\r\n\r\n  return (\r\n    <div className=\"min-h-screen bg-black flex items-center justify-center p-4\">\r\n        <div className=\"w-full max-w-md bg-zinc-900 border border-zinc-800 p-8 rounded-2xl shadow-2xl\">\r\n            <div className=\"text-center mb-6\">\r\n                <div className=\"inline-flex items-center justify-center w-12 h-12 rounded-full bg-indigo-900/30 text-indigo-400 mb-4\">\r\n                    <Lock className=\"w-6 h-6\" />\r\n                </div>\r\n                <h1 className=\"text-2xl font-bold text-white\">Bienvenido</h1>\r\n                <p className=\"text-zinc-500 text-sm\">Gestión Financiera Familiar</p>\r\n            </div>\r\n\r\n            <Tabs defaultValue=\"login\" className=\"w-full\">\r\n                <TabsList className=\"grid w-full grid-cols-2 bg-zinc-950 mb-6\">\r\n                    <TabsTrigger value=\"login\">Ingresar</TabsTrigger>\r\n                    <TabsTrigger value=\"register\">Solicitar</TabsTrigger>\r\n                </TabsList>\r\n\r\n                {/* LOGIN (Sin cambios significativos) */}\r\n                <TabsContent value=\"login\">\r\n                    {step === 1 ? (\r\n                        <form onSubmit={handleRequestCode} className=\"space-y-4\">\r\n                            <div className=\"space-y-2\">\r\n                                <label className=\"text-xs text-zinc-400 ml-1\">Correo Electrónico</label>\r\n                                <Input \r\n                                    type=\"email\" placeholder=\"ejemplo@gmail.com\" \r\n                                    className=\"bg-black border-zinc-800 h-12 text-white\"\r\n                                    value={email} onChange={e => setEmail(e.target.value)} required\r\n                                />\r\n                            </div>\r\n                            <Button type=\"submit\" disabled={loading} className=\"w-full h-12 bg-indigo-600 hover:bg-indigo-700 font-bold\">\r\n                                {loading ? 'Enviando...' : 'Siguiente'} <ArrowRight className=\"ml-2 h-4 w-4\" />\r\n                            </Button>\r\n                        </form>\r\n                    ) : (\r\n                        <form onSubmit={handleLogin} className=\"space-y-4\">\r\n                            <div className=\"text-center text-zinc-400 text-sm mb-2\">\r\n                                Ingresa el código enviado a <span className=\"text-white\">{email}</span>\r\n                            </div>\r\n                            <Input \r\n                                type=\"text\" placeholder=\"TOKEN\" autoFocus\r\n                                className=\"bg-black border-zinc-800 h-14 text-center text-2xl tracking-widest text-emerald-400 font-mono\"\r\n                                value={token} onChange={e => setToken(e.target.value)} required\r\n                            />\r\n                            <Button type=\"submit\" disabled={loading} className=\"w-full h-12 bg-emerald-600 hover:bg-emerald-700 font-bold\">\r\n                                {loading ? 'Validando...' : 'Entrar'}\r\n                            </Button>\r\n                            <button type=\"button\" onClick={()=>setStep(1)} className=\"text-xs text-indigo-400 w-full mt-2 hover:underline\">Corregir correo</button>\r\n                        </form>\r\n                    )}\r\n                </TabsContent>\r\n\r\n                {/* REGISTRO (CON CAMPO NOMBRE NUEVO) */}\r\n                <TabsContent value=\"register\">\r\n                    <form onSubmit={handleRegister} className=\"space-y-4\">\r\n                        <div className=\"space-y-1\">\r\n                             <Input \r\n                                className=\"bg-black border-zinc-800\" \r\n                                placeholder=\"Nombre Completo\" \r\n                                required \r\n                                value={name} onChange={e=>setName(e.target.value)} \r\n                            />\r\n                        </div>\r\n                        \r\n                        <div className=\"space-y-1\">\r\n                            <Input \r\n                                className=\"bg-black border-zinc-800\" \r\n                                type=\"email\" \r\n                                placeholder=\"Correo Electrónico\" \r\n                                required \r\n                                value={email} onChange={e=>setEmail(e.target.value)} \r\n                            />\r\n                        </div>\r\n                        \r\n                        <div className=\"space-y-1\">\r\n                            <Input \r\n                                className=\"bg-black border-zinc-800\" \r\n                                placeholder=\"Nombre Grupo Familiar\" \r\n                                required \r\n                                value={familyName} onChange={e=>setFamilyName(e.target.value)} \r\n                            />\r\n                            <p className=\"text-[10px] text-zinc-500 flex items-center gap-1 ml-1\">\r\n                                <Info className=\"h-3 w-3\" /> Debe ser idéntico al de tu pareja.\r\n                            </p>\r\n                        </div>\r\n\r\n                        <Button type=\"submit\" disabled={loading} className=\"w-full bg-zinc-800 hover:bg-zinc-700 border border-zinc-700\">\r\n                             <UserPlus className=\"mr-2 h-4 w-4\" /> Solicitar Acceso\r\n                        </Button>\r\n                    </form>\r\n                </TabsContent>\r\n            </Tabs>\r\n\r\n            <div className=\"mt-8 pt-6 border-t border-zinc-800\">\r\n                <Button variant=\"outline\" onClick={handleDemo} className=\"w-full border-zinc-700 hover:bg-zinc-800 text-zinc-300\">\r\n                    <Eye className=\"mr-2 h-4 w-4\" /> Ver Demo (Datos Falsos)\r\n                </Button>\r\n            </div>\r\n        </div>\r\n    </div>\r\n  );\r\n}"],"names":[],"mappings":";;;;;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAPA;;;;;;;;AASe,SAAS;;IACtB,MAAM,SAAS,IAAA,uMAAS;IACxB,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,8NAAQ,EAAC;IACnC,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,8NAAQ,EAAC;IAEnC,uBAAuB;IACvB,MAAM,CAAC,MAAM,QAAQ,GAAG,IAAA,8NAAQ,EAAC;IACjC,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,8NAAQ,EAAC;IAE7C,MAAM,CAAC,MAAM,QAAQ,GAAG,IAAA,8NAAQ,EAAC;IACjC,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,8NAAQ,EAAC;IAEvC,IAAA,+NAAS;+BAAC;YACN,IAAA,mNAAY,IAAG,KAAK;uCAAC,KAAO;;QAChC;8BAAG,EAAE;IAEL,MAAM,oBAAoB,OAAO;QAC7B,EAAE,cAAc;QAChB,WAAW;QACX,MAAM,MAAM,MAAM,IAAA,uNAAgB,EAAC;QACnC,WAAW;QAEX,IAAI,IAAI,OAAO,EAAE;YACb,QAAQ;QACZ,OAAO;YACH,MAAM,IAAI,OAAO;QACrB;IACJ;IAEA,MAAM,cAAc,OAAO;QACvB,EAAE,cAAc;QAChB,WAAW;QACX,MAAM,MAAM,MAAM,IAAA,kNAAW,EAAC,OAAO;QACrC,IAAI,IAAI,OAAO,EAAE;YACb,OAAO,QAAQ,CAAC,IAAI,GAAG;QAC3B,OAAO;YACH,MAAM;YACN,WAAW;QACf;IACJ;IAEA,MAAM,iBAAiB,OAAO;QAC1B,EAAE,cAAc;QAChB,WAAW;QACX,6BAA6B;QAC7B,MAAM,MAAM,MAAM,IAAA,0NAAmB,EAAC,OAAO,MAAM;QACnD,WAAW;QACX,IAAI,IAAI,OAAO,EAAE,MAAM;aAClB,MAAM,YAAY,IAAI,OAAO;IACtC;IAEA,MAAM,aAAa;QACf,WAAW;QACX,MAAM,IAAA,wNAAiB;QACvB,OAAO,QAAQ,CAAC,IAAI,GAAG;IAC3B;IAEA,qBACE,kPAAC;QAAI,WAAU;kBACX,cAAA,kPAAC;YAAI,WAAU;;8BACX,kPAAC;oBAAI,WAAU;;sCACX,kPAAC;4BAAI,WAAU;sCACX,cAAA,kPAAC,kQAAI;gCAAC,WAAU;;;;;;;;;;;sCAEpB,kPAAC;4BAAG,WAAU;sCAAgC;;;;;;sCAC9C,kPAAC;4BAAE,WAAU;sCAAwB;;;;;;;;;;;;8BAGzC,kPAAC,yLAAI;oBAAC,cAAa;oBAAQ,WAAU;;sCACjC,kPAAC,6LAAQ;4BAAC,WAAU;;8CAChB,kPAAC,gMAAW;oCAAC,OAAM;8CAAQ;;;;;;8CAC3B,kPAAC,gMAAW;oCAAC,OAAM;8CAAW;;;;;;;;;;;;sCAIlC,kPAAC,gMAAW;4BAAC,OAAM;sCACd,SAAS,kBACN,kPAAC;gCAAK,UAAU;gCAAmB,WAAU;;kDACzC,kPAAC;wCAAI,WAAU;;0DACX,kPAAC;gDAAM,WAAU;0DAA6B;;;;;;0DAC9C,kPAAC,2LAAK;gDACF,MAAK;gDAAQ,aAAY;gDACzB,WAAU;gDACV,OAAO;gDAAO,UAAU,CAAA,IAAK,SAAS,EAAE,MAAM,CAAC,KAAK;gDAAG,QAAQ;;;;;;;;;;;;kDAGvE,kPAAC,6LAAM;wCAAC,MAAK;wCAAS,UAAU;wCAAS,WAAU;;4CAC9C,UAAU,gBAAgB;4CAAY;0DAAC,kPAAC,wRAAU;gDAAC,WAAU;;;;;;;;;;;;;;;;;qDAItE,kPAAC;gCAAK,UAAU;gCAAa,WAAU;;kDACnC,kPAAC;wCAAI,WAAU;;4CAAyC;0DACxB,kPAAC;gDAAK,WAAU;0DAAc;;;;;;;;;;;;kDAE9D,kPAAC,2LAAK;wCACF,MAAK;wCAAO,aAAY;wCAAQ,SAAS;wCACzC,WAAU;wCACV,OAAO;wCAAO,UAAU,CAAA,IAAK,SAAS,EAAE,MAAM,CAAC,KAAK;wCAAG,QAAQ;;;;;;kDAEnE,kPAAC,6LAAM;wCAAC,MAAK;wCAAS,UAAU;wCAAS,WAAU;kDAC9C,UAAU,iBAAiB;;;;;;kDAEhC,kPAAC;wCAAO,MAAK;wCAAS,SAAS,IAAI,QAAQ;wCAAI,WAAU;kDAAsD;;;;;;;;;;;;;;;;;sCAM3H,kPAAC,gMAAW;4BAAC,OAAM;sCACf,cAAA,kPAAC;gCAAK,UAAU;gCAAgB,WAAU;;kDACtC,kPAAC;wCAAI,WAAU;kDACV,cAAA,kPAAC,2LAAK;4CACH,WAAU;4CACV,aAAY;4CACZ,QAAQ;4CACR,OAAO;4CAAM,UAAU,CAAA,IAAG,QAAQ,EAAE,MAAM,CAAC,KAAK;;;;;;;;;;;kDAIxD,kPAAC;wCAAI,WAAU;kDACX,cAAA,kPAAC,2LAAK;4CACF,WAAU;4CACV,MAAK;4CACL,aAAY;4CACZ,QAAQ;4CACR,OAAO;4CAAO,UAAU,CAAA,IAAG,SAAS,EAAE,MAAM,CAAC,KAAK;;;;;;;;;;;kDAI1D,kPAAC;wCAAI,WAAU;;0DACX,kPAAC,2LAAK;gDACF,WAAU;gDACV,aAAY;gDACZ,QAAQ;gDACR,OAAO;gDAAY,UAAU,CAAA,IAAG,cAAc,EAAE,MAAM,CAAC,KAAK;;;;;;0DAEhE,kPAAC;gDAAE,WAAU;;kEACT,kPAAC,kQAAI;wDAAC,WAAU;;;;;;oDAAY;;;;;;;;;;;;;kDAIpC,kPAAC,6LAAM;wCAAC,MAAK;wCAAS,UAAU;wCAAS,WAAU;;0DAC9C,kPAAC,kRAAQ;gDAAC,WAAU;;;;;;4CAAiB;;;;;;;;;;;;;;;;;;;;;;;;8BAMtD,kPAAC;oBAAI,WAAU;8BACX,cAAA,kPAAC,6LAAM;wBAAC,SAAQ;wBAAU,SAAS;wBAAY,WAAU;;0CACrD,kPAAC,+PAAG;gCAAC,WAAU;;;;;;4BAAiB;;;;;;;;;;;;;;;;;;;;;;;AAMpD;GA7JwB;;QACP,uMAAS;;;KADF"}}]
}