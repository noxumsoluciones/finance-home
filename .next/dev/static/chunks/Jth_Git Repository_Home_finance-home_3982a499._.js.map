{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken, UserPayload } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    return await verifyToken(token);\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    // Token seguro: 8 digitos + 1 especial\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n\r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    if (!user || user.token !== token) {\r\n        return { success: false, message: 'Código incorrecto.' };\r\n    }\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    // Cookie de 30 DÍAS\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n    \r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO ---\r\nexport async function requestRegistration(email: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        await sendRegistrationRequestEmail(email, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('is_demo_mode', 'true', { path: '/' });\r\n    cookieStore.delete('auth_token');\r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS (EL CEREBRO DE LA APP) ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. MODO DEMO: Retorna datos estáticos (NO toca la BD)\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' } \r\n        };\r\n    }\r\n\r\n    // 2. MODO REAL: Verifica sesión\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; // Señal para redirigir al login\r\n    }\r\n\r\n    const householdId = user.householdId; \r\n\r\n    // 3. CONSULTA BD FILTRADA POR HOGAR\r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({ \r\n        where: { householdId }, orderBy: { date: 'desc' } \r\n    });\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user, // Para mostrar el nombre en el Dashboard\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES (Siempre inyectan el householdId del usuario) ---\r\n\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n\r\n    if (data.type === 'transfer') {\r\n        await prisma.transaction.create({ data: { householdId, type: 'expense', amount: data.amount, accountId: data.accountId, description: `Transferencia a: ${data.destAccountName}`, date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true } });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        await prisma.transaction.create({ data: { householdId, type: 'income', amount: data.amount, accountId: data.relatedAccountId, description: `Recibido de: ${data.originAccountName}`, date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false } });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } else {\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        await prisma.transaction.create({\r\n            data: { householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount, accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, isFixed: data.isFixed||false, isSavings: data.isSavings||false, didWithdraw: data.didWithdraw??true }\r\n        });\r\n\r\n        if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }\r\n\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) {\r\n                savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            }\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n}\r\n\r\n// Funciones CRUD estándar protegidas\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED LIMPIO (SOLO PARA INICIALIZAR HOGAR JHONATTAN & THANNIA) ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    // 1. Crear/Asegurar Usuarios\r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    // 2. Crear Datos Base\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        \r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}"],"names":[],"mappings":";;;;;;;IAsGsB,iBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 19, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken, UserPayload } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    return await verifyToken(token);\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    // Token seguro: 8 digitos + 1 especial\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n\r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    if (!user || user.token !== token) {\r\n        return { success: false, message: 'Código incorrecto.' };\r\n    }\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    // Cookie de 30 DÍAS\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n    \r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO ---\r\nexport async function requestRegistration(email: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        await sendRegistrationRequestEmail(email, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('is_demo_mode', 'true', { path: '/' });\r\n    cookieStore.delete('auth_token');\r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS (EL CEREBRO DE LA APP) ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. MODO DEMO: Retorna datos estáticos (NO toca la BD)\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' } \r\n        };\r\n    }\r\n\r\n    // 2. MODO REAL: Verifica sesión\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; // Señal para redirigir al login\r\n    }\r\n\r\n    const householdId = user.householdId; \r\n\r\n    // 3. CONSULTA BD FILTRADA POR HOGAR\r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({ \r\n        where: { householdId }, orderBy: { date: 'desc' } \r\n    });\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user, // Para mostrar el nombre en el Dashboard\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES (Siempre inyectan el householdId del usuario) ---\r\n\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n\r\n    if (data.type === 'transfer') {\r\n        await prisma.transaction.create({ data: { householdId, type: 'expense', amount: data.amount, accountId: data.accountId, description: `Transferencia a: ${data.destAccountName}`, date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true } });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        await prisma.transaction.create({ data: { householdId, type: 'income', amount: data.amount, accountId: data.relatedAccountId, description: `Recibido de: ${data.originAccountName}`, date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false } });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } else {\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        await prisma.transaction.create({\r\n            data: { householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount, accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, isFixed: data.isFixed||false, isSavings: data.isSavings||false, didWithdraw: data.didWithdraw??true }\r\n        });\r\n\r\n        if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }\r\n\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) {\r\n                savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            }\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n}\r\n\r\n// Funciones CRUD estándar protegidas\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED LIMPIO (SOLO PARA INICIALIZAR HOGAR JHONATTAN & THANNIA) ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    // 1. Crear/Asegurar Usuarios\r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    // 2. Crear Datos Base\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        \r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}"],"names":[],"mappings":";;;;;;;IAoJsB,oBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken, UserPayload } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    return await verifyToken(token);\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    // Token seguro: 8 digitos + 1 especial\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n\r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    if (!user || user.token !== token) {\r\n        return { success: false, message: 'Código incorrecto.' };\r\n    }\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    // Cookie de 30 DÍAS\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n    \r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO ---\r\nexport async function requestRegistration(email: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        await sendRegistrationRequestEmail(email, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('is_demo_mode', 'true', { path: '/' });\r\n    cookieStore.delete('auth_token');\r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS (EL CEREBRO DE LA APP) ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. MODO DEMO: Retorna datos estáticos (NO toca la BD)\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' } \r\n        };\r\n    }\r\n\r\n    // 2. MODO REAL: Verifica sesión\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; // Señal para redirigir al login\r\n    }\r\n\r\n    const householdId = user.householdId; \r\n\r\n    // 3. CONSULTA BD FILTRADA POR HOGAR\r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({ \r\n        where: { householdId }, orderBy: { date: 'desc' } \r\n    });\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user, // Para mostrar el nombre en el Dashboard\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES (Siempre inyectan el householdId del usuario) ---\r\n\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n\r\n    if (data.type === 'transfer') {\r\n        await prisma.transaction.create({ data: { householdId, type: 'expense', amount: data.amount, accountId: data.accountId, description: `Transferencia a: ${data.destAccountName}`, date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true } });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        await prisma.transaction.create({ data: { householdId, type: 'income', amount: data.amount, accountId: data.relatedAccountId, description: `Recibido de: ${data.originAccountName}`, date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false } });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } else {\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        await prisma.transaction.create({\r\n            data: { householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount, accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, isFixed: data.isFixed||false, isSavings: data.isSavings||false, didWithdraw: data.didWithdraw??true }\r\n        });\r\n\r\n        if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }\r\n\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) {\r\n                savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            }\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n}\r\n\r\n// Funciones CRUD estándar protegidas\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED LIMPIO (SOLO PARA INICIALIZAR HOGAR JHONATTAN & THANNIA) ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    // 1. Crear/Asegurar Usuarios\r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    // 2. Crear Datos Base\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        \r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}"],"names":[],"mappings":";;;;;;;IAuLsB,gBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 49, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken, UserPayload } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    return await verifyToken(token);\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    // Token seguro: 8 digitos + 1 especial\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n\r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    if (!user || user.token !== token) {\r\n        return { success: false, message: 'Código incorrecto.' };\r\n    }\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    // Cookie de 30 DÍAS\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n    \r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO ---\r\nexport async function requestRegistration(email: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        await sendRegistrationRequestEmail(email, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('is_demo_mode', 'true', { path: '/' });\r\n    cookieStore.delete('auth_token');\r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS (EL CEREBRO DE LA APP) ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. MODO DEMO: Retorna datos estáticos (NO toca la BD)\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' } \r\n        };\r\n    }\r\n\r\n    // 2. MODO REAL: Verifica sesión\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; // Señal para redirigir al login\r\n    }\r\n\r\n    const householdId = user.householdId; \r\n\r\n    // 3. CONSULTA BD FILTRADA POR HOGAR\r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({ \r\n        where: { householdId }, orderBy: { date: 'desc' } \r\n    });\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user, // Para mostrar el nombre en el Dashboard\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES (Siempre inyectan el householdId del usuario) ---\r\n\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n\r\n    if (data.type === 'transfer') {\r\n        await prisma.transaction.create({ data: { householdId, type: 'expense', amount: data.amount, accountId: data.accountId, description: `Transferencia a: ${data.destAccountName}`, date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true } });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        await prisma.transaction.create({ data: { householdId, type: 'income', amount: data.amount, accountId: data.relatedAccountId, description: `Recibido de: ${data.originAccountName}`, date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false } });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } else {\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        await prisma.transaction.create({\r\n            data: { householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount, accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, isFixed: data.isFixed||false, isSavings: data.isSavings||false, didWithdraw: data.didWithdraw??true }\r\n        });\r\n\r\n        if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }\r\n\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) {\r\n                savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            }\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n}\r\n\r\n// Funciones CRUD estándar protegidas\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED LIMPIO (SOLO PARA INICIALIZAR HOGAR JHONATTAN & THANNIA) ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    // 1. Crear/Asegurar Usuarios\r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    // 2. Crear Datos Base\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        \r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}"],"names":[],"mappings":";;;;;;;IAwLsB,gBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken, UserPayload } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    return await verifyToken(token);\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    // Token seguro: 8 digitos + 1 especial\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n\r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    if (!user || user.token !== token) {\r\n        return { success: false, message: 'Código incorrecto.' };\r\n    }\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    // Cookie de 30 DÍAS\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n    \r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO ---\r\nexport async function requestRegistration(email: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        await sendRegistrationRequestEmail(email, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('is_demo_mode', 'true', { path: '/' });\r\n    cookieStore.delete('auth_token');\r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS (EL CEREBRO DE LA APP) ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. MODO DEMO: Retorna datos estáticos (NO toca la BD)\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' } \r\n        };\r\n    }\r\n\r\n    // 2. MODO REAL: Verifica sesión\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; // Señal para redirigir al login\r\n    }\r\n\r\n    const householdId = user.householdId; \r\n\r\n    // 3. CONSULTA BD FILTRADA POR HOGAR\r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({ \r\n        where: { householdId }, orderBy: { date: 'desc' } \r\n    });\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user, // Para mostrar el nombre en el Dashboard\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES (Siempre inyectan el householdId del usuario) ---\r\n\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n\r\n    if (data.type === 'transfer') {\r\n        await prisma.transaction.create({ data: { householdId, type: 'expense', amount: data.amount, accountId: data.accountId, description: `Transferencia a: ${data.destAccountName}`, date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true } });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        await prisma.transaction.create({ data: { householdId, type: 'income', amount: data.amount, accountId: data.relatedAccountId, description: `Recibido de: ${data.originAccountName}`, date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false } });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } else {\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        await prisma.transaction.create({\r\n            data: { householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount, accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, isFixed: data.isFixed||false, isSavings: data.isSavings||false, didWithdraw: data.didWithdraw??true }\r\n        });\r\n\r\n        if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }\r\n\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) {\r\n                savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            }\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n}\r\n\r\n// Funciones CRUD estándar protegidas\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED LIMPIO (SOLO PARA INICIALIZAR HOGAR JHONATTAN & THANNIA) ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    // 1. Crear/Asegurar Usuarios\r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    // 2. Crear Datos Base\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        \r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}"],"names":[],"mappings":";;;;;;;IA0LsB,iBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 79, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken, UserPayload } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    return await verifyToken(token);\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    // Token seguro: 8 digitos + 1 especial\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n\r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    if (!user || user.token !== token) {\r\n        return { success: false, message: 'Código incorrecto.' };\r\n    }\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    // Cookie de 30 DÍAS\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n    \r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO ---\r\nexport async function requestRegistration(email: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        await sendRegistrationRequestEmail(email, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('is_demo_mode', 'true', { path: '/' });\r\n    cookieStore.delete('auth_token');\r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS (EL CEREBRO DE LA APP) ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. MODO DEMO: Retorna datos estáticos (NO toca la BD)\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' } \r\n        };\r\n    }\r\n\r\n    // 2. MODO REAL: Verifica sesión\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; // Señal para redirigir al login\r\n    }\r\n\r\n    const householdId = user.householdId; \r\n\r\n    // 3. CONSULTA BD FILTRADA POR HOGAR\r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({ \r\n        where: { householdId }, orderBy: { date: 'desc' } \r\n    });\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user, // Para mostrar el nombre en el Dashboard\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES (Siempre inyectan el householdId del usuario) ---\r\n\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n\r\n    if (data.type === 'transfer') {\r\n        await prisma.transaction.create({ data: { householdId, type: 'expense', amount: data.amount, accountId: data.accountId, description: `Transferencia a: ${data.destAccountName}`, date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true } });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        await prisma.transaction.create({ data: { householdId, type: 'income', amount: data.amount, accountId: data.relatedAccountId, description: `Recibido de: ${data.originAccountName}`, date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false } });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } else {\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        await prisma.transaction.create({\r\n            data: { householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount, accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, isFixed: data.isFixed||false, isSavings: data.isSavings||false, didWithdraw: data.didWithdraw??true }\r\n        });\r\n\r\n        if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }\r\n\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) {\r\n                savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            }\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n}\r\n\r\n// Funciones CRUD estándar protegidas\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED LIMPIO (SOLO PARA INICIALIZAR HOGAR JHONATTAN & THANNIA) ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    // 1. Crear/Asegurar Usuarios\r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    // 2. Crear Datos Base\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        \r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}"],"names":[],"mappings":";;;;;;;IAiMsB,oBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 94, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken, UserPayload } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    return await verifyToken(token);\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    // Token seguro: 8 digitos + 1 especial\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n\r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    if (!user || user.token !== token) {\r\n        return { success: false, message: 'Código incorrecto.' };\r\n    }\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    // Cookie de 30 DÍAS\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n    \r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO ---\r\nexport async function requestRegistration(email: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        await sendRegistrationRequestEmail(email, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('is_demo_mode', 'true', { path: '/' });\r\n    cookieStore.delete('auth_token');\r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS (EL CEREBRO DE LA APP) ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. MODO DEMO: Retorna datos estáticos (NO toca la BD)\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' } \r\n        };\r\n    }\r\n\r\n    // 2. MODO REAL: Verifica sesión\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; // Señal para redirigir al login\r\n    }\r\n\r\n    const householdId = user.householdId; \r\n\r\n    // 3. CONSULTA BD FILTRADA POR HOGAR\r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({ \r\n        where: { householdId }, orderBy: { date: 'desc' } \r\n    });\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user, // Para mostrar el nombre en el Dashboard\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES (Siempre inyectan el householdId del usuario) ---\r\n\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n\r\n    if (data.type === 'transfer') {\r\n        await prisma.transaction.create({ data: { householdId, type: 'expense', amount: data.amount, accountId: data.accountId, description: `Transferencia a: ${data.destAccountName}`, date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true } });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        await prisma.transaction.create({ data: { householdId, type: 'income', amount: data.amount, accountId: data.relatedAccountId, description: `Recibido de: ${data.originAccountName}`, date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false } });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } else {\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        await prisma.transaction.create({\r\n            data: { householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount, accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, isFixed: data.isFixed||false, isSavings: data.isSavings||false, didWithdraw: data.didWithdraw??true }\r\n        });\r\n\r\n        if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }\r\n\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) {\r\n                savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            }\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n}\r\n\r\n// Funciones CRUD estándar protegidas\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED LIMPIO (SOLO PARA INICIALIZAR HOGAR JHONATTAN & THANNIA) ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    // 1. Crear/Asegurar Usuarios\r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    // 2. Crear Datos Base\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        \r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}"],"names":[],"mappings":";;;;;;;IAkMsB,sBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 109, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken, UserPayload } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    return await verifyToken(token);\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    // Token seguro: 8 digitos + 1 especial\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n\r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    if (!user || user.token !== token) {\r\n        return { success: false, message: 'Código incorrecto.' };\r\n    }\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    // Cookie de 30 DÍAS\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n    \r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO ---\r\nexport async function requestRegistration(email: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        await sendRegistrationRequestEmail(email, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('is_demo_mode', 'true', { path: '/' });\r\n    cookieStore.delete('auth_token');\r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS (EL CEREBRO DE LA APP) ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. MODO DEMO: Retorna datos estáticos (NO toca la BD)\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' } \r\n        };\r\n    }\r\n\r\n    // 2. MODO REAL: Verifica sesión\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; // Señal para redirigir al login\r\n    }\r\n\r\n    const householdId = user.householdId; \r\n\r\n    // 3. CONSULTA BD FILTRADA POR HOGAR\r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({ \r\n        where: { householdId }, orderBy: { date: 'desc' } \r\n    });\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user, // Para mostrar el nombre en el Dashboard\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES (Siempre inyectan el householdId del usuario) ---\r\n\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n\r\n    if (data.type === 'transfer') {\r\n        await prisma.transaction.create({ data: { householdId, type: 'expense', amount: data.amount, accountId: data.accountId, description: `Transferencia a: ${data.destAccountName}`, date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true } });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        await prisma.transaction.create({ data: { householdId, type: 'income', amount: data.amount, accountId: data.relatedAccountId, description: `Recibido de: ${data.originAccountName}`, date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false } });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } else {\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        await prisma.transaction.create({\r\n            data: { householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount, accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, isFixed: data.isFixed||false, isSavings: data.isSavings||false, didWithdraw: data.didWithdraw??true }\r\n        });\r\n\r\n        if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }\r\n\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) {\r\n                savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            }\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n}\r\n\r\n// Funciones CRUD estándar protegidas\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED LIMPIO (SOLO PARA INICIALIZAR HOGAR JHONATTAN & THANNIA) ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    // 1. Crear/Asegurar Usuarios\r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    // 2. Crear Datos Base\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        \r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}"],"names":[],"mappings":";;;;;;;IA8LsB,kBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 124, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken, UserPayload } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    return await verifyToken(token);\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    // Token seguro: 8 digitos + 1 especial\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n\r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    if (!user || user.token !== token) {\r\n        return { success: false, message: 'Código incorrecto.' };\r\n    }\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    // Cookie de 30 DÍAS\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n    \r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO ---\r\nexport async function requestRegistration(email: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        await sendRegistrationRequestEmail(email, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('is_demo_mode', 'true', { path: '/' });\r\n    cookieStore.delete('auth_token');\r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS (EL CEREBRO DE LA APP) ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. MODO DEMO: Retorna datos estáticos (NO toca la BD)\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' } \r\n        };\r\n    }\r\n\r\n    // 2. MODO REAL: Verifica sesión\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; // Señal para redirigir al login\r\n    }\r\n\r\n    const householdId = user.householdId; \r\n\r\n    // 3. CONSULTA BD FILTRADA POR HOGAR\r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({ \r\n        where: { householdId }, orderBy: { date: 'desc' } \r\n    });\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user, // Para mostrar el nombre en el Dashboard\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES (Siempre inyectan el householdId del usuario) ---\r\n\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n\r\n    if (data.type === 'transfer') {\r\n        await prisma.transaction.create({ data: { householdId, type: 'expense', amount: data.amount, accountId: data.accountId, description: `Transferencia a: ${data.destAccountName}`, date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true } });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        await prisma.transaction.create({ data: { householdId, type: 'income', amount: data.amount, accountId: data.relatedAccountId, description: `Recibido de: ${data.originAccountName}`, date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false } });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } else {\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        await prisma.transaction.create({\r\n            data: { householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount, accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, isFixed: data.isFixed||false, isSavings: data.isSavings||false, didWithdraw: data.didWithdraw??true }\r\n        });\r\n\r\n        if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }\r\n\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) {\r\n                savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            }\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n}\r\n\r\n// Funciones CRUD estándar protegidas\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED LIMPIO (SOLO PARA INICIALIZAR HOGAR JHONATTAN & THANNIA) ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    // 1. Crear/Asegurar Usuarios\r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    // 2. Crear Datos Base\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        \r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}"],"names":[],"mappings":";;;;;;;IA2LsB,iBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 139, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken, UserPayload } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    return await verifyToken(token);\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    // Token seguro: 8 digitos + 1 especial\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n\r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    if (!user || user.token !== token) {\r\n        return { success: false, message: 'Código incorrecto.' };\r\n    }\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    // Cookie de 30 DÍAS\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n    \r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO ---\r\nexport async function requestRegistration(email: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        await sendRegistrationRequestEmail(email, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('is_demo_mode', 'true', { path: '/' });\r\n    cookieStore.delete('auth_token');\r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS (EL CEREBRO DE LA APP) ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. MODO DEMO: Retorna datos estáticos (NO toca la BD)\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' } \r\n        };\r\n    }\r\n\r\n    // 2. MODO REAL: Verifica sesión\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; // Señal para redirigir al login\r\n    }\r\n\r\n    const householdId = user.householdId; \r\n\r\n    // 3. CONSULTA BD FILTRADA POR HOGAR\r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({ \r\n        where: { householdId }, orderBy: { date: 'desc' } \r\n    });\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user, // Para mostrar el nombre en el Dashboard\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES (Siempre inyectan el householdId del usuario) ---\r\n\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n\r\n    if (data.type === 'transfer') {\r\n        await prisma.transaction.create({ data: { householdId, type: 'expense', amount: data.amount, accountId: data.accountId, description: `Transferencia a: ${data.destAccountName}`, date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true } });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        await prisma.transaction.create({ data: { householdId, type: 'income', amount: data.amount, accountId: data.relatedAccountId, description: `Recibido de: ${data.originAccountName}`, date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false } });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } else {\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        await prisma.transaction.create({\r\n            data: { householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount, accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, isFixed: data.isFixed||false, isSavings: data.isSavings||false, didWithdraw: data.didWithdraw??true }\r\n        });\r\n\r\n        if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }\r\n\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) {\r\n                savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            }\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n}\r\n\r\n// Funciones CRUD estándar protegidas\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED LIMPIO (SOLO PARA INICIALIZAR HOGAR JHONATTAN & THANNIA) ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    // 1. Crear/Asegurar Usuarios\r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    // 2. Crear Datos Base\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        \r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}"],"names":[],"mappings":";;;;;;;IA4LsB,iBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 154, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken, UserPayload } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    return await verifyToken(token);\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    // Token seguro: 8 digitos + 1 especial\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n\r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    if (!user || user.token !== token) {\r\n        return { success: false, message: 'Código incorrecto.' };\r\n    }\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    // Cookie de 30 DÍAS\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n    \r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO ---\r\nexport async function requestRegistration(email: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        await sendRegistrationRequestEmail(email, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('is_demo_mode', 'true', { path: '/' });\r\n    cookieStore.delete('auth_token');\r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS (EL CEREBRO DE LA APP) ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. MODO DEMO: Retorna datos estáticos (NO toca la BD)\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' } \r\n        };\r\n    }\r\n\r\n    // 2. MODO REAL: Verifica sesión\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; // Señal para redirigir al login\r\n    }\r\n\r\n    const householdId = user.householdId; \r\n\r\n    // 3. CONSULTA BD FILTRADA POR HOGAR\r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({ \r\n        where: { householdId }, orderBy: { date: 'desc' } \r\n    });\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user, // Para mostrar el nombre en el Dashboard\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES (Siempre inyectan el householdId del usuario) ---\r\n\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n\r\n    if (data.type === 'transfer') {\r\n        await prisma.transaction.create({ data: { householdId, type: 'expense', amount: data.amount, accountId: data.accountId, description: `Transferencia a: ${data.destAccountName}`, date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true } });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        await prisma.transaction.create({ data: { householdId, type: 'income', amount: data.amount, accountId: data.relatedAccountId, description: `Recibido de: ${data.originAccountName}`, date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false } });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } else {\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        await prisma.transaction.create({\r\n            data: { householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount, accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, isFixed: data.isFixed||false, isSavings: data.isSavings||false, didWithdraw: data.didWithdraw??true }\r\n        });\r\n\r\n        if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }\r\n\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) {\r\n                savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            }\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n}\r\n\r\n// Funciones CRUD estándar protegidas\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED LIMPIO (SOLO PARA INICIALIZAR HOGAR JHONATTAN & THANNIA) ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    // 1. Crear/Asegurar Usuarios\r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    // 2. Crear Datos Base\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        \r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}"],"names":[],"mappings":";;;;;;;IA6LsB,oBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 169, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken, UserPayload } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    return await verifyToken(token);\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    // Token seguro: 8 digitos + 1 especial\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n\r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    if (!user || user.token !== token) {\r\n        return { success: false, message: 'Código incorrecto.' };\r\n    }\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    // Cookie de 30 DÍAS\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n    \r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO ---\r\nexport async function requestRegistration(email: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        await sendRegistrationRequestEmail(email, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('is_demo_mode', 'true', { path: '/' });\r\n    cookieStore.delete('auth_token');\r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS (EL CEREBRO DE LA APP) ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. MODO DEMO: Retorna datos estáticos (NO toca la BD)\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' } \r\n        };\r\n    }\r\n\r\n    // 2. MODO REAL: Verifica sesión\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; // Señal para redirigir al login\r\n    }\r\n\r\n    const householdId = user.householdId; \r\n\r\n    // 3. CONSULTA BD FILTRADA POR HOGAR\r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({ \r\n        where: { householdId }, orderBy: { date: 'desc' } \r\n    });\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user, // Para mostrar el nombre en el Dashboard\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES (Siempre inyectan el householdId del usuario) ---\r\n\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n\r\n    if (data.type === 'transfer') {\r\n        await prisma.transaction.create({ data: { householdId, type: 'expense', amount: data.amount, accountId: data.accountId, description: `Transferencia a: ${data.destAccountName}`, date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true } });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        await prisma.transaction.create({ data: { householdId, type: 'income', amount: data.amount, accountId: data.relatedAccountId, description: `Recibido de: ${data.originAccountName}`, date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false } });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } else {\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        await prisma.transaction.create({\r\n            data: { householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount, accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, isFixed: data.isFixed||false, isSavings: data.isSavings||false, didWithdraw: data.didWithdraw??true }\r\n        });\r\n\r\n        if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }\r\n\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) {\r\n                savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            }\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n}\r\n\r\n// Funciones CRUD estándar protegidas\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED LIMPIO (SOLO PARA INICIALIZAR HOGAR JHONATTAN & THANNIA) ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    // 1. Crear/Asegurar Usuarios\r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    // 2. Crear Datos Base\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        \r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}"],"names":[],"mappings":";;;;;;;IAyLsB,gBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 184, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken, UserPayload } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    return await verifyToken(token);\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    // Token seguro: 8 digitos + 1 especial\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n\r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    if (!user || user.token !== token) {\r\n        return { success: false, message: 'Código incorrecto.' };\r\n    }\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    // Cookie de 30 DÍAS\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n    \r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO ---\r\nexport async function requestRegistration(email: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        await sendRegistrationRequestEmail(email, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('is_demo_mode', 'true', { path: '/' });\r\n    cookieStore.delete('auth_token');\r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS (EL CEREBRO DE LA APP) ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. MODO DEMO: Retorna datos estáticos (NO toca la BD)\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' } \r\n        };\r\n    }\r\n\r\n    // 2. MODO REAL: Verifica sesión\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; // Señal para redirigir al login\r\n    }\r\n\r\n    const householdId = user.householdId; \r\n\r\n    // 3. CONSULTA BD FILTRADA POR HOGAR\r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({ \r\n        where: { householdId }, orderBy: { date: 'desc' } \r\n    });\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user, // Para mostrar el nombre en el Dashboard\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES (Siempre inyectan el householdId del usuario) ---\r\n\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n\r\n    if (data.type === 'transfer') {\r\n        await prisma.transaction.create({ data: { householdId, type: 'expense', amount: data.amount, accountId: data.accountId, description: `Transferencia a: ${data.destAccountName}`, date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true } });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        await prisma.transaction.create({ data: { householdId, type: 'income', amount: data.amount, accountId: data.relatedAccountId, description: `Recibido de: ${data.originAccountName}`, date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false } });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } else {\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        await prisma.transaction.create({\r\n            data: { householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount, accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, isFixed: data.isFixed||false, isSavings: data.isSavings||false, didWithdraw: data.didWithdraw??true }\r\n        });\r\n\r\n        if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }\r\n\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) {\r\n                savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            }\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n}\r\n\r\n// Funciones CRUD estándar protegidas\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED LIMPIO (SOLO PARA INICIALIZAR HOGAR JHONATTAN & THANNIA) ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    // 1. Crear/Asegurar Usuarios\r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    // 2. Crear Datos Base\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        \r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}"],"names":[],"mappings":";;;;;;;IA+LsB,kBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 199, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken, UserPayload } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    return await verifyToken(token);\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    // Token seguro: 8 digitos + 1 especial\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n\r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    if (!user || user.token !== token) {\r\n        return { success: false, message: 'Código incorrecto.' };\r\n    }\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    // Cookie de 30 DÍAS\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n    \r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO ---\r\nexport async function requestRegistration(email: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        await sendRegistrationRequestEmail(email, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('is_demo_mode', 'true', { path: '/' });\r\n    cookieStore.delete('auth_token');\r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS (EL CEREBRO DE LA APP) ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. MODO DEMO: Retorna datos estáticos (NO toca la BD)\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' } \r\n        };\r\n    }\r\n\r\n    // 2. MODO REAL: Verifica sesión\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; // Señal para redirigir al login\r\n    }\r\n\r\n    const householdId = user.householdId; \r\n\r\n    // 3. CONSULTA BD FILTRADA POR HOGAR\r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({ \r\n        where: { householdId }, orderBy: { date: 'desc' } \r\n    });\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user, // Para mostrar el nombre en el Dashboard\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES (Siempre inyectan el householdId del usuario) ---\r\n\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n\r\n    if (data.type === 'transfer') {\r\n        await prisma.transaction.create({ data: { householdId, type: 'expense', amount: data.amount, accountId: data.accountId, description: `Transferencia a: ${data.destAccountName}`, date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true } });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        await prisma.transaction.create({ data: { householdId, type: 'income', amount: data.amount, accountId: data.relatedAccountId, description: `Recibido de: ${data.originAccountName}`, date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false } });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } else {\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        await prisma.transaction.create({\r\n            data: { householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount, accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, isFixed: data.isFixed||false, isSavings: data.isSavings||false, didWithdraw: data.didWithdraw??true }\r\n        });\r\n\r\n        if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }\r\n\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) {\r\n                savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            }\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n}\r\n\r\n// Funciones CRUD estándar protegidas\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED LIMPIO (SOLO PARA INICIALIZAR HOGAR JHONATTAN & THANNIA) ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    // 1. Crear/Asegurar Usuarios\r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    // 2. Crear Datos Base\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        \r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}"],"names":[],"mappings":";;;;;;;IAgMsB,kBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 214, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/context/FinanceContext.tsx"],"sourcesContent":["// context/FinanceContext.tsx\r\n\"use client\";\r\n\r\nimport React, { createContext, useContext, useEffect, useState } from 'react';\r\nimport { Account, Category, Transaction, FixedExpenseRule } from '@/types';\r\n// 1. IMPORTAR LAS NUEVAS ACCIONES\r\nimport { \r\n    getFinanceData, createTransaction, createAccount, deleteAccount, createCategory, \r\n    saveSimulatorItem, deleteSimulatorItem, createFixedRule, \r\n    deleteCategory as deleteCategoryAction, updateCategory as updateCategoryAction,\r\n    // Nuevas:\r\n    deleteTransaction as deleteTransactionAction,\r\n    updateAccount as updateAccountAction,\r\n    updateFixedRule as updateFixedRuleAction,\r\n    deleteFixedRule as deleteFixedRuleAction\r\n} from '@/app/actions';\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\nimport { generateDemoData } from '@/lib/demoData'; // Importa el generador\r\n\r\ninterface SimulatorItem {\r\n  id: string;\r\n  name: string;\r\n  amount: number;\r\n  type: 'income' | 'expense' | 'transfer';\r\n  isFixed: boolean;\r\n}\r\n\r\ninterface FinanceContextType {\r\n    currentUser: { email: string; householdId: string } | null;\r\n  accounts: Account[];\r\n  transactions: Transaction[];\r\n  categories: Category[];\r\n  fixedRules: FixedExpenseRule[];\r\n  simulatorItems: SimulatorItem[];\r\n  \r\n  addTransaction: (t: any) => Promise<void>;\r\n  addAccount: (a: any) => Promise<void>;\r\n  deleteAccountAction: (id: string) => Promise<void>;\r\n  addCategory: (c: any) => Promise<void>;\r\n  addFixedRule: (r: any) => Promise<void>;\r\n  \r\n  // Simulador\r\n  addSimItem: (item: any) => Promise<void>;\r\n  removeSimItem: (id: string) => Promise<void>;\r\n  \r\n  // Funciones COMPLETAS (Ya no vacías)\r\n  updateTransaction: (t: any) => void;\r\n  deleteTransaction: (id: string) => void;\r\n  updateAccount: (a: any) => void;\r\n  deleteCategory: (id: string) => void;\r\n  addSubCategory: (id: string, sub: string) => void;\r\n  removeSubCategory: (id: string, sub: string) => void;\r\n  updateFixedRule: (r: any) => void;\r\n  deleteFixedRule: (id: string) => void;\r\n  markRuleAsPaid: (id: string, date: string) => void;\r\n}\r\n\r\nconst FinanceContext = createContext<FinanceContextType | undefined>(undefined);\r\n\r\nexport const FinanceProvider = ({ children }: { children: React.ReactNode }) => {\r\n  const [accounts, setAccounts] = useState<Account[]>([]);\r\n  const [transactions, setTransactions] = useState<Transaction[]>([]);\r\n  const [categories, setCategories] = useState<Category[]>([]);\r\n  const [fixedRules, setFixedRules] = useState<FixedExpenseRule[]>([]);\r\n  const [simulatorItems, setSimulatorItems] = useState<SimulatorItem[]>([]);\r\n    const [currentUser, setCurrentUser] = useState<{ email: string; householdId: string } | null>(null);\r\n  // CARGAR DATOS\r\n  useEffect(() => {\r\n        const initData = async () => {\r\n            try {\r\n                const data = await getFinanceData();\r\n\r\n                // CASO NO AUTORIZADO\r\n                // @ts-ignore\r\n                if (data.unauthorized) {\r\n                    // Si estamos en /login no hacemos nada, si estamos dentro, el middleware o el usuario redirige\r\n                    return; \r\n                }\r\n\r\n                // CASO DEMO o REAL (Ambos traen estructura similar ahora)\r\n                // @ts-ignore\r\n                setAccounts(data.accounts || []);\r\n                // @ts-ignore\r\n                setTransactions(data.transactions || []);\r\n                // @ts-ignore\r\n                setCategories(data.categories || []);\r\n                // @ts-ignore\r\n                setFixedRules(data.fixedRules || []);\r\n                // @ts-ignore\r\n                setSimulatorItems(data.simulatorItems || []);\r\n                // @ts-ignore\r\n                setCurrentUser(data.currentUser || null);\r\n\r\n            } catch (e) { console.error(e); }\r\n        };\r\n        initData();\r\n    }, []);\r\n\r\n  // --- TRANSACCIONES ---\r\n  const addTransaction = async (t: any) => {\r\n    const tempId = uuidv4();\r\n    const optimisticTx = { ...t, id: tempId };\r\n    setTransactions(prev => [optimisticTx, ...prev]);\r\n\r\n    // Actualización optimista de saldo\r\n    if (t.type === 'transfer') {\r\n        setAccounts(prev => prev.map(acc => {\r\n            if (acc.id === t.accountId) return { ...acc, balance: acc.balance - t.amount };\r\n            if (acc.id === t.relatedAccountId) return { ...acc, balance: acc.balance + t.amount };\r\n            return acc;\r\n        }));\r\n    } else {\r\n        const shouldUpdateBalance = t.type === 'expense' && t.isSavings ? t.didWithdraw : true;\r\n        if (shouldUpdateBalance) {\r\n            const multiplier = t.type === 'income' ? 1 : -1;\r\n            setAccounts(prev => prev.map(acc => {\r\n                if (acc.id === t.accountId) return { ...acc, balance: acc.balance + (t.amount * multiplier) };\r\n                return acc;\r\n            }));\r\n        }\r\n        if (t.isSavings) {\r\n             setAccounts(prev => {\r\n                 const hasVirtual = prev.some(a => a.type === 'savings_virtual');\r\n                 if (hasVirtual) {\r\n                     return prev.map(a => a.type === 'savings_virtual' ? { ...a, balance: a.balance + t.amount } : a);\r\n                 }\r\n                 return prev;\r\n             });\r\n        }\r\n    }\r\n    await createTransaction(t);\r\n  };\r\n\r\n  const deleteTransaction = async (id: string) => {\r\n      // 1. Optimistic UI\r\n      const tx = transactions.find(t => t.id === id);\r\n      setTransactions(prev => prev.filter(t => t.id !== id));\r\n      \r\n      // Revertir saldo visualmente (básico)\r\n      if (tx && tx.type !== 'transfer') {\r\n          const multiplier = tx.type === 'income' ? -1 : 1; // Inverso para borrar\r\n          setAccounts(prev => prev.map(a => a.id === tx.accountId ? { ...a, balance: a.balance + (tx.amount * multiplier) } : a));\r\n      }\r\n      // 2. Server Action\r\n      await deleteTransactionAction(id);\r\n  };\r\n\r\n  const updateTransaction = async (t: any) => {\r\n      // Implementación futura si deseas editar montos\r\n      console.log(\"Edit not implemented yet\");\r\n  };\r\n\r\n  // --- CUENTAS ---\r\n  const addAccount = async (a: any) => {\r\n      setAccounts(prev => [...prev, a]);\r\n      await createAccount(a);\r\n  };\r\n\r\n  const deleteAccountAction = async (id: string) => {\r\n      setAccounts(prev => prev.filter(x => x.id !== id));\r\n      await deleteAccount(id);\r\n  };\r\n\r\n  const updateAccount = async (a: any) => {\r\n      setAccounts(prev => prev.map(acc => acc.id === a.id ? a : acc));\r\n      await updateAccountAction(a);\r\n  };\r\n\r\n  // --- CATEGORÍAS ---\r\n  const addCategory = async (c: any) => {\r\n      setCategories(prev => [...prev, c]);\r\n      await createCategory(c);\r\n  };\r\n\r\n  const deleteCategory = async (id: string) => {\r\n      setCategories(prev => prev.filter(c => c.id !== id));\r\n      await deleteCategoryAction(id);\r\n  };\r\n\r\n  const addSubCategory = async (catId: string, subName: string) => {\r\n      if (!subName) return;\r\n      const categoryToUpdate = categories.find(c => c.id === catId);\r\n      if (!categoryToUpdate) return;\r\n      const newSubCategories = [...(categoryToUpdate.subCategories || []), subName];\r\n      setCategories(prev => prev.map(c => c.id === catId ? { ...c, subCategories: newSubCategories } : c));\r\n      await updateCategoryAction({ ...categoryToUpdate, subCategories: newSubCategories });\r\n  };\r\n\r\n  const removeSubCategory = async (catId: string, subName: string) => {\r\n      const categoryToUpdate = categories.find(c => c.id === catId);\r\n      if (!categoryToUpdate) return;\r\n      const newSubCategories = categoryToUpdate.subCategories.filter(s => s !== subName);\r\n      setCategories(prev => prev.map(c => c.id === catId ? { ...c, subCategories: newSubCategories } : c));\r\n      await updateCategoryAction({ ...categoryToUpdate, subCategories: newSubCategories });\r\n  };\r\n\r\n  // --- REGLAS FIJAS ---\r\n  const addFixedRule = async (r: any) => {\r\n      setFixedRules(prev => [...prev, r]);\r\n      await createFixedRule(r);\r\n  };\r\n\r\n  const updateFixedRule = async (r: any) => {\r\n      setFixedRules(prev => prev.map(rule => rule.id === r.id ? r : rule));\r\n      await updateFixedRuleAction(r);\r\n  };\r\n\r\n  const deleteFixedRule = async (id: string) => {\r\n      setFixedRules(prev => prev.filter(r => r.id !== id));\r\n      await deleteFixedRuleAction(id);\r\n  };\r\n\r\n  const markRuleAsPaid = (id: string, date: string) => {\r\n      // Implementación opcional visual\r\n      console.log(\"Rule marked as paid\", id);\r\n  };\r\n\r\n  // --- SIMULADOR ---\r\n  const addSimItem = async (item: any) => {\r\n      setSimulatorItems(prev => {\r\n          const exists = prev.find(i => i.id === item.id);\r\n          if (exists) return prev.map(i => i.id === item.id ? item : i);\r\n          return [...prev, item];\r\n      });\r\n      await saveSimulatorItem(item);\r\n  };\r\n\r\n  const removeSimItem = async (id: string) => {\r\n      setSimulatorItems(prev => prev.filter(i => i.id !== id));\r\n      await deleteSimulatorItem(id);\r\n  };\r\n\r\n  return (\r\n    <FinanceContext.Provider value={{\r\n      currentUser,accounts, transactions, categories, fixedRules, simulatorItems, \r\n      addTransaction, addAccount, deleteAccountAction, addCategory, addFixedRule,\r\n      addSimItem, removeSimItem, deleteCategory, addSubCategory, removeSubCategory,\r\n      // AHORA SÍ PASAMOS LAS IMPLEMENTACIONES REALES\r\n      updateTransaction, \r\n      deleteTransaction, \r\n      updateAccount, \r\n      updateFixedRule, \r\n      deleteFixedRule, \r\n      markRuleAsPaid\r\n    }}>\r\n      {children}\r\n    </FinanceContext.Provider>\r\n  );\r\n};\r\n\r\nexport const useFinance = () => {\r\n    const context = useContext(FinanceContext);\r\n    if (!context) throw new Error(\"useFinance Error\");\r\n    return context;\r\n};"],"names":[],"mappings":"AAAA,6BAA6B;;;;;;;;AAG7B;AAEA,kCAAkC;AAClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;;;AAfA;;;;AAyDA,MAAM,+BAAiB,IAAA,mOAAa,EAAiC;AAE9D,MAAM,kBAAkB,CAAC,EAAE,QAAQ,EAAiC;;IACzE,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,8NAAQ,EAAY,EAAE;IACtD,MAAM,CAAC,cAAc,gBAAgB,GAAG,IAAA,8NAAQ,EAAgB,EAAE;IAClE,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,8NAAQ,EAAa,EAAE;IAC3D,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,8NAAQ,EAAqB,EAAE;IACnE,MAAM,CAAC,gBAAgB,kBAAkB,GAAG,IAAA,8NAAQ,EAAkB,EAAE;IACtE,MAAM,CAAC,aAAa,eAAe,GAAG,IAAA,8NAAQ,EAAgD;IAChG,eAAe;IACf,IAAA,+NAAS;qCAAC;YACJ,MAAM;sDAAW;oBACb,IAAI;wBACA,MAAM,OAAO,MAAM,IAAA,qNAAc;wBAEjC,qBAAqB;wBACrB,aAAa;wBACb,IAAI,KAAK,YAAY,EAAE;4BACnB,+FAA+F;4BAC/F;wBACJ;wBAEA,0DAA0D;wBAC1D,aAAa;wBACb,YAAY,KAAK,QAAQ,IAAI,EAAE;wBAC/B,aAAa;wBACb,gBAAgB,KAAK,YAAY,IAAI,EAAE;wBACvC,aAAa;wBACb,cAAc,KAAK,UAAU,IAAI,EAAE;wBACnC,aAAa;wBACb,cAAc,KAAK,UAAU,IAAI,EAAE;wBACnC,aAAa;wBACb,kBAAkB,KAAK,cAAc,IAAI,EAAE;wBAC3C,aAAa;wBACb,eAAe,KAAK,WAAW,IAAI;oBAEvC,EAAE,OAAO,GAAG;wBAAE,QAAQ,KAAK,CAAC;oBAAI;gBACpC;;YACA;QACJ;oCAAG,EAAE;IAEP,wBAAwB;IACxB,MAAM,iBAAiB,OAAO;QAC5B,MAAM,SAAS,IAAA,iOAAM;QACrB,MAAM,eAAe;YAAE,GAAG,CAAC;YAAE,IAAI;QAAO;QACxC,gBAAgB,CAAA,OAAQ;gBAAC;mBAAiB;aAAK;QAE/C,mCAAmC;QACnC,IAAI,EAAE,IAAI,KAAK,YAAY;YACvB,YAAY,CAAA,OAAQ,KAAK,GAAG,CAAC,CAAA;oBACzB,IAAI,IAAI,EAAE,KAAK,EAAE,SAAS,EAAE,OAAO;wBAAE,GAAG,GAAG;wBAAE,SAAS,IAAI,OAAO,GAAG,EAAE,MAAM;oBAAC;oBAC7E,IAAI,IAAI,EAAE,KAAK,EAAE,gBAAgB,EAAE,OAAO;wBAAE,GAAG,GAAG;wBAAE,SAAS,IAAI,OAAO,GAAG,EAAE,MAAM;oBAAC;oBACpF,OAAO;gBACX;QACJ,OAAO;YACH,MAAM,sBAAsB,EAAE,IAAI,KAAK,aAAa,EAAE,SAAS,GAAG,EAAE,WAAW,GAAG;YAClF,IAAI,qBAAqB;gBACrB,MAAM,aAAa,EAAE,IAAI,KAAK,WAAW,IAAI,CAAC;gBAC9C,YAAY,CAAA,OAAQ,KAAK,GAAG,CAAC,CAAA;wBACzB,IAAI,IAAI,EAAE,KAAK,EAAE,SAAS,EAAE,OAAO;4BAAE,GAAG,GAAG;4BAAE,SAAS,IAAI,OAAO,GAAI,EAAE,MAAM,GAAG;wBAAY;wBAC5F,OAAO;oBACX;YACJ;YACA,IAAI,EAAE,SAAS,EAAE;gBACZ,YAAY,CAAA;oBACR,MAAM,aAAa,KAAK,IAAI,CAAC,CAAA,IAAK,EAAE,IAAI,KAAK;oBAC7C,IAAI,YAAY;wBACZ,OAAO,KAAK,GAAG,CAAC,CAAA,IAAK,EAAE,IAAI,KAAK,oBAAoB;gCAAE,GAAG,CAAC;gCAAE,SAAS,EAAE,OAAO,GAAG,EAAE,MAAM;4BAAC,IAAI;oBAClG;oBACA,OAAO;gBACX;YACL;QACJ;QACA,MAAM,IAAA,wNAAiB,EAAC;IAC1B;IAEA,MAAM,oBAAoB,OAAO;QAC7B,mBAAmB;QACnB,MAAM,KAAK,aAAa,IAAI,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;QAC3C,gBAAgB,CAAA,OAAQ,KAAK,MAAM,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;QAElD,sCAAsC;QACtC,IAAI,MAAM,GAAG,IAAI,KAAK,YAAY;YAC9B,MAAM,aAAa,GAAG,IAAI,KAAK,WAAW,CAAC,IAAI,GAAG,sBAAsB;YACxE,YAAY,CAAA,OAAQ,KAAK,GAAG,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,GAAG,SAAS,GAAG;wBAAE,GAAG,CAAC;wBAAE,SAAS,EAAE,OAAO,GAAI,GAAG,MAAM,GAAG;oBAAY,IAAI;QACxH;QACA,mBAAmB;QACnB,MAAM,IAAA,wNAAuB,EAAC;IAClC;IAEA,MAAM,oBAAoB,OAAO;QAC7B,gDAAgD;QAChD,QAAQ,GAAG,CAAC;IAChB;IAEA,kBAAkB;IAClB,MAAM,aAAa,OAAO;QACtB,YAAY,CAAA,OAAQ;mBAAI;gBAAM;aAAE;QAChC,MAAM,IAAA,oNAAa,EAAC;IACxB;IAEA,MAAM,sBAAsB,OAAO;QAC/B,YAAY,CAAA,OAAQ,KAAK,MAAM,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;QAC9C,MAAM,IAAA,oNAAa,EAAC;IACxB;IAEA,MAAM,gBAAgB,OAAO;QACzB,YAAY,CAAA,OAAQ,KAAK,GAAG,CAAC,CAAA,MAAO,IAAI,EAAE,KAAK,EAAE,EAAE,GAAG,IAAI;QAC1D,MAAM,IAAA,oNAAmB,EAAC;IAC9B;IAEA,qBAAqB;IACrB,MAAM,cAAc,OAAO;QACvB,cAAc,CAAA,OAAQ;mBAAI;gBAAM;aAAE;QAClC,MAAM,IAAA,qNAAc,EAAC;IACzB;IAEA,MAAM,iBAAiB,OAAO;QAC1B,cAAc,CAAA,OAAQ,KAAK,MAAM,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;QAChD,MAAM,IAAA,qNAAoB,EAAC;IAC/B;IAEA,MAAM,iBAAiB,OAAO,OAAe;QACzC,IAAI,CAAC,SAAS;QACd,MAAM,mBAAmB,WAAW,IAAI,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;QACvD,IAAI,CAAC,kBAAkB;QACvB,MAAM,mBAAmB;eAAK,iBAAiB,aAAa,IAAI,EAAE;YAAG;SAAQ;QAC7E,cAAc,CAAA,OAAQ,KAAK,GAAG,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,QAAQ;oBAAE,GAAG,CAAC;oBAAE,eAAe;gBAAiB,IAAI;QACjG,MAAM,IAAA,qNAAoB,EAAC;YAAE,GAAG,gBAAgB;YAAE,eAAe;QAAiB;IACtF;IAEA,MAAM,oBAAoB,OAAO,OAAe;QAC5C,MAAM,mBAAmB,WAAW,IAAI,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;QACvD,IAAI,CAAC,kBAAkB;QACvB,MAAM,mBAAmB,iBAAiB,aAAa,CAAC,MAAM,CAAC,CAAA,IAAK,MAAM;QAC1E,cAAc,CAAA,OAAQ,KAAK,GAAG,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,QAAQ;oBAAE,GAAG,CAAC;oBAAE,eAAe;gBAAiB,IAAI;QACjG,MAAM,IAAA,qNAAoB,EAAC;YAAE,GAAG,gBAAgB;YAAE,eAAe;QAAiB;IACtF;IAEA,uBAAuB;IACvB,MAAM,eAAe,OAAO;QACxB,cAAc,CAAA,OAAQ;mBAAI;gBAAM;aAAE;QAClC,MAAM,IAAA,sNAAe,EAAC;IAC1B;IAEA,MAAM,kBAAkB,OAAO;QAC3B,cAAc,CAAA,OAAQ,KAAK,GAAG,CAAC,CAAA,OAAQ,KAAK,EAAE,KAAK,EAAE,EAAE,GAAG,IAAI;QAC9D,MAAM,IAAA,sNAAqB,EAAC;IAChC;IAEA,MAAM,kBAAkB,OAAO;QAC3B,cAAc,CAAA,OAAQ,KAAK,MAAM,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;QAChD,MAAM,IAAA,sNAAqB,EAAC;IAChC;IAEA,MAAM,iBAAiB,CAAC,IAAY;QAChC,iCAAiC;QACjC,QAAQ,GAAG,CAAC,uBAAuB;IACvC;IAEA,oBAAoB;IACpB,MAAM,aAAa,OAAO;QACtB,kBAAkB,CAAA;YACd,MAAM,SAAS,KAAK,IAAI,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,KAAK,EAAE;YAC9C,IAAI,QAAQ,OAAO,KAAK,GAAG,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,KAAK,EAAE,GAAG,OAAO;YAC3D,OAAO;mBAAI;gBAAM;aAAK;QAC1B;QACA,MAAM,IAAA,wNAAiB,EAAC;IAC5B;IAEA,MAAM,gBAAgB,OAAO;QACzB,kBAAkB,CAAA,OAAQ,KAAK,MAAM,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;QACpD,MAAM,IAAA,0NAAmB,EAAC;IAC9B;IAEA,qBACE,kPAAC,eAAe,QAAQ;QAAC,OAAO;YAC9B;YAAY;YAAU;YAAc;YAAY;YAAY;YAC5D;YAAgB;YAAY;YAAqB;YAAa;YAC9D;YAAY;YAAe;YAAgB;YAAgB;YAC3D,+CAA+C;YAC/C;YACA;YACA;YACA;YACA;YACA;QACF;kBACG;;;;;;AAGP;GA7La;KAAA;AA+LN,MAAM,aAAa;;IACtB,MAAM,UAAU,IAAA,gOAAU,EAAC;IAC3B,IAAI,CAAC,SAAS,MAAM,IAAI,MAAM;IAC9B,OAAO;AACX;IAJa"}},
    {"offset": {"line": 503, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/lib/utils.ts"],"sourcesContent":["import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,GAAG,GAAG,MAAoB;IACxC,OAAO,IAAA,8NAAO,EAAC,IAAA,qMAAI,EAAC;AACtB"}},
    {"offset": {"line": 521, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/components/dashboard/RealisticAccountCard.tsx"],"sourcesContent":["\"use client\";\r\nimport { useFinance } from '@/context/FinanceContext';\r\nimport { Account } from '@/types';\r\nimport { Wallet, Building2, Banknote, CreditCard, Lock } from 'lucide-react';\r\nimport { cn } from '@/lib/utils';\r\n\r\nexport default function RealisticAccountCard({ account }: { account: Account }) {\r\n  const { transactions } = useFinance();\r\n\r\n  // 1. Calcular cuánto de esta cuenta es \"Ahorro no retirado\"\r\n  // Buscamos transacciones que sean de esta cuenta, sean Ahorro y NO se hayan retirado (didWithdraw = false)\r\n  const savingsInAccount = transactions\r\n    .filter(t => t.accountId === account.id && t.isSavings && t.type === 'expense' && !t.didWithdraw)\r\n    .reduce((sum, t) => sum + t.amount, 0);\r\n\r\n  // 2. El \"Balance\" que viene de la BD ya incluye todo (porque decidimos no restarlo).\r\n  //    Así que el \"Disponible\" es el Total menos el Ahorro Reservado.\r\n  const totalBalance = account.balance;\r\n  const availableBalance = totalBalance - savingsInAccount;\r\n\r\n  const Icon = account.type === 'wallet' ? Wallet : \r\n               account.type === 'cash' ? Banknote : \r\n               account.type === 'bond' ? CreditCard : Building2;\r\n\r\n  const cardColor = account.color || '#52525b';\r\n\r\n  return (\r\n    <div \r\n        className=\"relative overflow-hidden rounded-xl p-4 bg-zinc-900 border border-zinc-800 shadow-md transition-all hover:scale-[1.02]\"\r\n        style={{ borderLeft: `4px solid ${cardColor}` }}\r\n    >\r\n      <div className=\"flex justify-between items-start mb-3\">\r\n        <div className=\"flex items-center gap-3\">\r\n            <div className=\"w-3 h-3 rounded-sm shadow-[0_0_10px_rgba(0,0,0,0.5)]\" style={{ backgroundColor: cardColor }} />\r\n            <div>\r\n                <h3 className=\"text-lg font-bold text-white leading-tight\">{account.name}</h3>\r\n                <p className=\"text-xs text-zinc-500 font-medium\">\r\n                    {account.bank} • <span className=\"text-zinc-400\">{account.owner}</span>\r\n                </p>\r\n            </div>\r\n        </div>\r\n        <Icon className=\"text-zinc-600 opacity-50\" size={20} />\r\n      </div>\r\n\r\n      <div className=\"space-y-2\">\r\n         {/* Ahorro Reservado (Solo si hay) */}\r\n         {savingsInAccount > 0 && (\r\n            <div className=\"flex justify-between items-center bg-blue-900/20 px-2 py-1 rounded border border-blue-900/30\">\r\n                <div className=\"flex items-center gap-1 text-blue-400 text-xs\">\r\n                    <Lock size={10} /> <span>Reservado Ahorro</span>\r\n                </div>\r\n                <span className=\"text-blue-300 text-xs font-mono font-bold\">${savingsInAccount.toLocaleString()}</span>\r\n            </div>\r\n         )}\r\n\r\n         <div className=\"flex justify-between items-end border-t border-zinc-800 pt-2 mt-2\">\r\n             <div className=\"text-left\">\r\n                <p className=\"text-[10px] text-zinc-500 uppercase tracking-wider\">Total Banco</p>\r\n                <p className=\"text-xs text-zinc-400 font-mono\">${totalBalance.toLocaleString()}</p>\r\n             </div>\r\n             <div className=\"text-right\">\r\n                <p className=\"text-[10px] text-zinc-400 uppercase tracking-wider font-bold\">Disponible Real</p>\r\n                <p className={cn(\r\n                    \"text-xl font-mono font-bold tracking-tight\",\r\n                    availableBalance >= 0 ? \"text-emerald-400\" : \"text-rose-400\"\r\n                )}>\r\n                    ${availableBalance.toLocaleString('es-CO')}\r\n                </p>\r\n             </div>\r\n         </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}"],"names":[],"mappings":";;;;;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAJA;;;;AAMe,SAAS,qBAAqB,EAAE,OAAO,EAAwB;;IAC5E,MAAM,EAAE,YAAY,EAAE,GAAG,IAAA,gMAAU;IAEnC,4DAA4D;IAC5D,2GAA2G;IAC3G,MAAM,mBAAmB,aACtB,MAAM,CAAC,CAAA,IAAK,EAAE,SAAS,KAAK,QAAQ,EAAE,IAAI,EAAE,SAAS,IAAI,EAAE,IAAI,KAAK,aAAa,CAAC,EAAE,WAAW,EAC/F,MAAM,CAAC,CAAC,KAAK,IAAM,MAAM,EAAE,MAAM,EAAE;IAEtC,qFAAqF;IACrF,oEAAoE;IACpE,MAAM,eAAe,QAAQ,OAAO;IACpC,MAAM,mBAAmB,eAAe;IAExC,MAAM,OAAO,QAAQ,IAAI,KAAK,WAAW,wQAAM,GAClC,QAAQ,IAAI,KAAK,SAAS,8QAAQ,GAClC,QAAQ,IAAI,KAAK,SAAS,wRAAU,GAAG,qRAAS;IAE7D,MAAM,YAAY,QAAQ,KAAK,IAAI;IAEnC,qBACE,kPAAC;QACG,WAAU;QACV,OAAO;YAAE,YAAY,CAAC,UAAU,EAAE,WAAW;QAAC;;0BAEhD,kPAAC;gBAAI,WAAU;;kCACb,kPAAC;wBAAI,WAAU;;0CACX,kPAAC;gCAAI,WAAU;gCAAuD,OAAO;oCAAE,iBAAiB;gCAAU;;;;;;0CAC1G,kPAAC;;kDACG,kPAAC;wCAAG,WAAU;kDAA8C,QAAQ,IAAI;;;;;;kDACxE,kPAAC;wCAAE,WAAU;;4CACR,QAAQ,IAAI;4CAAC;0DAAG,kPAAC;gDAAK,WAAU;0DAAiB,QAAQ,KAAK;;;;;;;;;;;;;;;;;;;;;;;;kCAI3E,kPAAC;wBAAK,WAAU;wBAA2B,MAAM;;;;;;;;;;;;0BAGnD,kPAAC;gBAAI,WAAU;;oBAEX,mBAAmB,mBACjB,kPAAC;wBAAI,WAAU;;0CACX,kPAAC;gCAAI,WAAU;;kDACX,kPAAC,kQAAI;wCAAC,MAAM;;;;;;oCAAM;kDAAC,kPAAC;kDAAK;;;;;;;;;;;;0CAE7B,kPAAC;gCAAK,WAAU;;oCAA4C;oCAAE,iBAAiB,cAAc;;;;;;;;;;;;;kCAIpG,kPAAC;wBAAI,WAAU;;0CACX,kPAAC;gCAAI,WAAU;;kDACZ,kPAAC;wCAAE,WAAU;kDAAqD;;;;;;kDAClE,kPAAC;wCAAE,WAAU;;4CAAkC;4CAAE,aAAa,cAAc;;;;;;;;;;;;;0CAE/E,kPAAC;gCAAI,WAAU;;kDACZ,kPAAC;wCAAE,WAAU;kDAA+D;;;;;;kDAC5E,kPAAC;wCAAE,WAAW,IAAA,0KAAE,EACZ,8CACA,oBAAoB,IAAI,qBAAqB;;4CAC9C;4CACG,iBAAiB,cAAc,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOtD;GAnEwB;;QACG,gMAAU;;;KADb"}},
    {"offset": {"line": 768, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/components/ui/button.tsx"],"sourcesContent":["import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-primary text-primary-foreground hover:bg-primary/90\",\n        destructive:\n          \"bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60\",\n        outline:\n          \"border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50\",\n        secondary:\n          \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        ghost:\n          \"hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-9 px-4 py-2 has-[>svg]:px-3\",\n        sm: \"h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5\",\n        lg: \"h-10 rounded-md px-6 has-[>svg]:px-4\",\n        icon: \"size-9\",\n        \"icon-sm\": \"size-8\",\n        \"icon-lg\": \"size-10\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nfunction Button({\n  className,\n  variant = \"default\",\n  size = \"default\",\n  asChild = false,\n  ...props\n}: React.ComponentProps<\"button\"> &\n  VariantProps<typeof buttonVariants> & {\n    asChild?: boolean\n  }) {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      data-slot=\"button\"\n      data-variant={variant}\n      data-size={size}\n      className={cn(buttonVariants({ variant, size, className }))}\n      {...props}\n    />\n  )\n}\n\nexport { Button, buttonVariants }\n"],"names":[],"mappings":";;;;;;;AACA;AACA;AAEA;;;;;AAEA,MAAM,iBAAiB,IAAA,+NAAG,EACxB,+bACA;IACE,UAAU;QACR,SAAS;YACP,SAAS;YACT,aACE;YACF,SACE;YACF,WACE;YACF,OACE;YACF,MAAM;QACR;QACA,MAAM;YACJ,SAAS;YACT,IAAI;YACJ,IAAI;YACJ,MAAM;YACN,WAAW;YACX,WAAW;QACb;IACF;IACA,iBAAiB;QACf,SAAS;QACT,MAAM;IACR;AACF;AAGF,SAAS,OAAO,EACd,SAAS,EACT,UAAU,SAAS,EACnB,OAAO,SAAS,EAChB,UAAU,KAAK,EACf,GAAG,OAIF;IACD,MAAM,OAAO,UAAU,gOAAI,GAAG;IAE9B,qBACE,kPAAC;QACC,aAAU;QACV,gBAAc;QACd,aAAW;QACX,WAAW,IAAA,0KAAE,EAAC,eAAe;YAAE;YAAS;YAAM;QAAU;QACvD,GAAG,KAAK;;;;;;AAGf;KArBS"}},
    {"offset": {"line": 835, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/components/dashboard/AccountsSidebar.tsx"],"sourcesContent":["// components/dashboard/AccountsSidebar.tsx\r\n\"use client\";\r\nimport { useState } from 'react';\r\nimport { useFinance } from '@/context/FinanceContext';\r\nimport RealisticAccountCard from './RealisticAccountCard';\r\nimport { Button } from '@/components/ui/button';\r\nimport { ChevronRight, Wallet, Home, Calculator, Settings } from 'lucide-react';\r\nimport Link from 'next/link'; \r\nimport { cn } from '@/lib/utils';\r\nimport { usePathname } from 'next/navigation'; \r\n\r\ninterface Props {\r\n    className?: string;\r\n}\r\n\r\nexport default function AccountsSidebar({ className }: Props) {\r\n  const { accounts, transactions } = useFinance();\r\n  const [isOpen, setIsOpen] = useState(false);\r\n  const visibleAccounts = accounts.filter(a => !a.isHidden);\r\n  const totalBalance = visibleAccounts.reduce((sum, acc) => sum + acc.balance, 0);\r\n  \r\n  const pathname = usePathname();\r\n\r\n  const navClass = (path: string) => cn(\r\n      \"flex items-center gap-3 p-3 rounded-lg transition-colors font-medium text-sm\",\r\n      pathname === path ? \"bg-indigo-900/50 text-indigo-400\" : \"text-zinc-400 hover:bg-zinc-900 hover:text-zinc-100\"\r\n  );\r\n\r\n  // 1. Calcular Ahorro Total \"Reservado\" (dinero que está en cuentas pero es ahorro)\r\n  const totalReservedSavings = transactions\r\n      .filter(t => t.isSavings && t.type === 'expense' && !t.didWithdraw)\r\n      .reduce((sum, t) => sum + t.amount, 0);\r\n\r\n  // 2. Totales\r\n  const totalPatrimony = visibleAccounts.reduce((sum, acc) => sum + acc.balance, 0);\r\n  const totalAvailable = totalPatrimony - totalReservedSavings;\r\n\r\n  return (\r\n    <>\r\n      <Button \r\n        variant=\"default\" size=\"icon\" onClick={() => setIsOpen(!isOpen)}\r\n        className={cn(\r\n            \"fixed top-24 right-0 z-50 rounded-l-xl rounded-r-none shadow-xl transition-all duration-300 bg-indigo-600 w-8 h-12 md:hidden\", \r\n            isOpen ? \"mr-[320px]\" : \"mr-0\"\r\n        )}\r\n      >\r\n        {isOpen ? <ChevronRight /> : <Wallet className=\"h-4 w-4\" />}\r\n      </Button>\r\n\r\n      {isOpen && <div className=\"fixed inset-0 bg-black/50 z-40 md:hidden\" onClick={() => setIsOpen(false)} />}\r\n\r\n      <aside className={cn(\r\n          \"fixed top-0 bottom-0 right-0 z-50 w-[320px] bg-zinc-950 border-l border-zinc-800 shadow-2xl transition-transform duration-300 ease-in-out flex flex-col\",\r\n          isOpen ? \"translate-x-0\" : \"translate-x-full md:translate-x-0\", // Siempre visible en Desktop\r\n          className \r\n      )}>\r\n        \r\n        {/* NAVEGACIÓN DESKTOP Y MOBILE */}\r\n        <div className=\"p-4 border-b border-zinc-900 bg-zinc-950\">\r\n            <h2 className=\"text-xs font-bold text-zinc-600 uppercase tracking-widest mb-2 px-2\">Menú</h2>\r\n            <nav className=\"space-y-1\">\r\n                <Link href=\"/\" className={navClass('/')}>\r\n                    <Home size={18} /> Resumen General\r\n                </Link>\r\n                <Link href=\"/simulator\" className={navClass('/simulator')}>\r\n                    <Calculator size={18} /> Simulador Mensual\r\n                </Link>\r\n                <Link href=\"/admin\" className={navClass('/admin')}>\r\n                    <Settings size={18} /> Configuración\r\n                </Link>\r\n            </nav>\r\n        </div>\r\n\r\n        <div className=\"mt-4 p-4 bg-zinc-900/50 rounded-xl border border-zinc-800/50\">\r\n            <div className=\"flex justify-between items-center mb-2 border-b border-zinc-800 pb-2\">\r\n                <span className=\"text-[10px] text-zinc-500 uppercase\">Patrimonio Total</span>\r\n                <span className=\"text-xs text-zinc-400 font-mono\">${totalPatrimony.toLocaleString()}</span>\r\n            </div>\r\n            <div className=\"text-center\">\r\n                <p className=\"text-[10px] text-zinc-400 uppercase tracking-widest font-bold\">Disponible para Gastar</p>\r\n                <p className={cn(\"text-2xl font-extrabold mt-1\", totalAvailable >= 0 ? \"text-emerald-400\" : \"text-rose-400\")}>\r\n                    ${totalAvailable.toLocaleString('es-CO')}\r\n                </p>\r\n            </div>\r\n            {totalReservedSavings > 0 && (\r\n                <div className=\"mt-2 text-center bg-blue-900/20 rounded py-1 border border-blue-900/30\">\r\n                    <p className=\"text-[10px] text-blue-400\">💰 Ahorro Intocable: <span className=\"font-bold\">${totalReservedSavings.toLocaleString()}</span></p>\r\n                </div>\r\n            )}\r\n        </div>\r\n\r\n        <div className=\"flex-1 overflow-y-auto p-4 space-y-3 pb-20 scrollbar-thin scrollbar-thumb-zinc-800\">\r\n          {visibleAccounts.length === 0 && <p className=\"text-center text-xs text-zinc-600 mt-10\">No hay cuentas creadas aún.</p>}\r\n          {visibleAccounts.map(acc => (\r\n            <RealisticAccountCard key={acc.id} account={acc} />\r\n          ))}\r\n        </div>\r\n      </aside>\r\n    </>\r\n  );\r\n}"],"names":[],"mappings":"AAAA,2CAA2C;;;;;;AAE3C;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;AARA;;;;;;;;;AAce,SAAS,gBAAgB,EAAE,SAAS,EAAS;;IAC1D,MAAM,EAAE,QAAQ,EAAE,YAAY,EAAE,GAAG,IAAA,gMAAU;IAC7C,MAAM,CAAC,QAAQ,UAAU,GAAG,IAAA,8NAAQ,EAAC;IACrC,MAAM,kBAAkB,SAAS,MAAM,CAAC,CAAA,IAAK,CAAC,EAAE,QAAQ;IACxD,MAAM,eAAe,gBAAgB,MAAM,CAAC,CAAC,KAAK,MAAQ,MAAM,IAAI,OAAO,EAAE;IAE7E,MAAM,WAAW,IAAA,yMAAW;IAE5B,MAAM,WAAW,CAAC,OAAiB,IAAA,0KAAE,EACjC,gFACA,aAAa,OAAO,qCAAqC;IAG7D,mFAAmF;IACnF,MAAM,uBAAuB,aACxB,MAAM,CAAC,CAAA,IAAK,EAAE,SAAS,IAAI,EAAE,IAAI,KAAK,aAAa,CAAC,EAAE,WAAW,EACjE,MAAM,CAAC,CAAC,KAAK,IAAM,MAAM,EAAE,MAAM,EAAE;IAExC,aAAa;IACb,MAAM,iBAAiB,gBAAgB,MAAM,CAAC,CAAC,KAAK,MAAQ,MAAM,IAAI,OAAO,EAAE;IAC/E,MAAM,iBAAiB,iBAAiB;IAExC,qBACE;;0BACE,kPAAC,6LAAM;gBACL,SAAQ;gBAAU,MAAK;gBAAO,SAAS,IAAM,UAAU,CAAC;gBACxD,WAAW,IAAA,0KAAE,EACT,gIACA,SAAS,eAAe;0BAG3B,uBAAS,kPAAC,8RAAY;;;;yCAAM,kPAAC,wQAAM;oBAAC,WAAU;;;;;;;;;;;YAGhD,wBAAU,kPAAC;gBAAI,WAAU;gBAA2C,SAAS,IAAM,UAAU;;;;;;0BAE9F,kPAAC;gBAAM,WAAW,IAAA,0KAAE,EAChB,2JACA,SAAS,kBAAkB,qCAC3B;;kCAIF,kPAAC;wBAAI,WAAU;;0CACX,kPAAC;gCAAG,WAAU;0CAAsE;;;;;;0CACpF,kPAAC;gCAAI,WAAU;;kDACX,kPAAC,+NAAI;wCAAC,MAAK;wCAAI,WAAW,SAAS;;0DAC/B,kPAAC,mQAAI;gDAAC,MAAM;;;;;;4CAAM;;;;;;;kDAEtB,kPAAC,+NAAI;wCAAC,MAAK;wCAAa,WAAW,SAAS;;0DACxC,kPAAC,oRAAU;gDAAC,MAAM;;;;;;4CAAM;;;;;;;kDAE5B,kPAAC,+NAAI;wCAAC,MAAK;wCAAS,WAAW,SAAS;;0DACpC,kPAAC,8QAAQ;gDAAC,MAAM;;;;;;4CAAM;;;;;;;;;;;;;;;;;;;kCAKlC,kPAAC;wBAAI,WAAU;;0CACX,kPAAC;gCAAI,WAAU;;kDACX,kPAAC;wCAAK,WAAU;kDAAsC;;;;;;kDACtD,kPAAC;wCAAK,WAAU;;4CAAkC;4CAAE,eAAe,cAAc;;;;;;;;;;;;;0CAErF,kPAAC;gCAAI,WAAU;;kDACX,kPAAC;wCAAE,WAAU;kDAAgE;;;;;;kDAC7E,kPAAC;wCAAE,WAAW,IAAA,0KAAE,EAAC,gCAAgC,kBAAkB,IAAI,qBAAqB;;4CAAkB;4CACxG,eAAe,cAAc,CAAC;;;;;;;;;;;;;4BAGvC,uBAAuB,mBACpB,kPAAC;gCAAI,WAAU;0CACX,cAAA,kPAAC;oCAAE,WAAU;;wCAA4B;sDAAqB,kPAAC;4CAAK,WAAU;;gDAAY;gDAAE,qBAAqB,cAAc;;;;;;;;;;;;;;;;;;;;;;;;kCAK3I,kPAAC;wBAAI,WAAU;;4BACZ,gBAAgB,MAAM,KAAK,mBAAK,kPAAC;gCAAE,WAAU;0CAA0C;;;;;;4BACvF,gBAAgB,GAAG,CAAC,CAAA,oBACnB,kPAAC,mNAAoB;oCAAc,SAAS;mCAAjB,IAAI,EAAE;;;;;;;;;;;;;;;;;;;AAM7C;GArFwB;;QACa,gMAAU;QAK5B,yMAAW;;;KANN"}},
    {"offset": {"line": 1133, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken, UserPayload } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    return await verifyToken(token);\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    // Token seguro: 8 digitos + 1 especial\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n\r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    if (!user || user.token !== token) {\r\n        return { success: false, message: 'Código incorrecto.' };\r\n    }\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    // Cookie de 30 DÍAS\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n    \r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO ---\r\nexport async function requestRegistration(email: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        await sendRegistrationRequestEmail(email, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('is_demo_mode', 'true', { path: '/' });\r\n    cookieStore.delete('auth_token');\r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS (EL CEREBRO DE LA APP) ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. MODO DEMO: Retorna datos estáticos (NO toca la BD)\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' } \r\n        };\r\n    }\r\n\r\n    // 2. MODO REAL: Verifica sesión\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; // Señal para redirigir al login\r\n    }\r\n\r\n    const householdId = user.householdId; \r\n\r\n    // 3. CONSULTA BD FILTRADA POR HOGAR\r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({ \r\n        where: { householdId }, orderBy: { date: 'desc' } \r\n    });\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user, // Para mostrar el nombre en el Dashboard\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES (Siempre inyectan el householdId del usuario) ---\r\n\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n\r\n    if (data.type === 'transfer') {\r\n        await prisma.transaction.create({ data: { householdId, type: 'expense', amount: data.amount, accountId: data.accountId, description: `Transferencia a: ${data.destAccountName}`, date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true } });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        await prisma.transaction.create({ data: { householdId, type: 'income', amount: data.amount, accountId: data.relatedAccountId, description: `Recibido de: ${data.originAccountName}`, date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false } });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } else {\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        await prisma.transaction.create({\r\n            data: { householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount, accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, isFixed: data.isFixed||false, isSavings: data.isSavings||false, didWithdraw: data.didWithdraw??true }\r\n        });\r\n\r\n        if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }\r\n\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) {\r\n                savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            }\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n}\r\n\r\n// Funciones CRUD estándar protegidas\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED LIMPIO (SOLO PARA INICIALIZAR HOGAR JHONATTAN & THANNIA) ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    // 1. Crear/Asegurar Usuarios\r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId }\r\n    });\r\n\r\n    // 2. Crear Datos Base\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        \r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}"],"names":[],"mappings":";;;;;;;IA8FsB,eAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 1148, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/components/layout/MainLayout.tsx"],"sourcesContent":["\"use client\";\r\n\r\nimport { usePathname, useRouter } from 'next/navigation';\r\nimport AccountsSidebar from '@/components/dashboard/AccountsSidebar';\r\nimport { Button } from '@/components/ui/button';\r\nimport { LogOut, User } from 'lucide-react';\r\nimport { logoutAction } from '@/app/actions';\r\nimport { useFinance } from '@/context/FinanceContext';\r\n\r\nexport default function MainLayout({ children }: { children: React.ReactNode }) {\r\n    const pathname = usePathname();\r\n    const router = useRouter();\r\n    const { currentUser } = useFinance(); // Necesitaremos agregar esto al contexto\r\n    const isLoginPage = pathname === '/login';\r\n\r\n    const handleLogout = async () => {\r\n        await logoutAction();\r\n        window.location.href = '/login';\r\n    };\r\n\r\n    if (isLoginPage) {\r\n        return <main className=\"w-full h-full\">{children}</main>;\r\n    }\r\n\r\n    return (\r\n        <div className=\"flex min-h-screen bg-black text-white\">\r\n            {/* Sidebar solo si no es login */}\r\n            <AccountsSidebar className=\"hidden md:flex\" />\r\n\r\n            <div className=\"flex-1 flex flex-col md:ml-[320px] transition-all duration-300\">\r\n                \r\n                {/* Header Superior con Info de Usuario */}\r\n                <header className=\"h-16 border-b border-zinc-800 bg-zinc-950/80 backdrop-blur flex items-center justify-between px-6 sticky top-0 z-40\">\r\n                    <div className=\"font-bold text-lg bg-clip-text text-transparent bg-gradient-to-r from-indigo-400 to-emerald-400\">\r\n                        Finance Home\r\n                    </div>\r\n                    \r\n                    <div className=\"flex items-center gap-4\">\r\n                        {currentUser && (\r\n                            <div className=\"flex items-center gap-2 text-sm text-zinc-400 bg-zinc-900 py-1 px-3 rounded-full border border-zinc-800\">\r\n                                <User className=\"h-4 w-4\" />\r\n                                <span className=\"max-w-[150px] truncate\">{currentUser.email}</span>\r\n                                {currentUser.householdId === 'demo' && <span className=\"text-yellow-500 font-bold text-xs ml-1\">(DEMO)</span>}\r\n                            </div>\r\n                        )}\r\n                        \r\n                        <Button variant=\"ghost\" size=\"sm\" onClick={handleLogout} className=\"text-zinc-500 hover:text-red-400 hover:bg-red-950/30\">\r\n                            <LogOut className=\"h-4 w-4 mr-2\" /> Salir\r\n                        </Button>\r\n                    </div>\r\n                </header>\r\n\r\n                <main className=\"flex-1 p-4 md:p-8 max-w-7xl mx-auto w-full\">\r\n                    {children}\r\n                </main>\r\n            </div>\r\n        </div>\r\n    );\r\n}"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;;;AAPA;;;;;;;AASe,SAAS,WAAW,EAAE,QAAQ,EAAiC;;IAC1E,MAAM,WAAW,IAAA,yMAAW;IAC5B,MAAM,SAAS,IAAA,uMAAS;IACxB,MAAM,EAAE,WAAW,EAAE,GAAG,IAAA,gMAAU,KAAI,yCAAyC;IAC/E,MAAM,cAAc,aAAa;IAEjC,MAAM,eAAe;QACjB,MAAM,IAAA,mNAAY;QAClB,OAAO,QAAQ,CAAC,IAAI,GAAG;IAC3B;IAEA,IAAI,aAAa;QACb,qBAAO,kPAAC;YAAK,WAAU;sBAAiB;;;;;;IAC5C;IAEA,qBACI,kPAAC;QAAI,WAAU;;0BAEX,kPAAC,8MAAe;gBAAC,WAAU;;;;;;0BAE3B,kPAAC;gBAAI,WAAU;;kCAGX,kPAAC;wBAAO,WAAU;;0CACd,kPAAC;gCAAI,WAAU;0CAAkG;;;;;;0CAIjH,kPAAC;gCAAI,WAAU;;oCACV,6BACG,kPAAC;wCAAI,WAAU;;0DACX,kPAAC,kQAAI;gDAAC,WAAU;;;;;;0DAChB,kPAAC;gDAAK,WAAU;0DAA0B,YAAY,KAAK;;;;;;4CAC1D,YAAY,WAAW,KAAK,wBAAU,kPAAC;gDAAK,WAAU;0DAAyC;;;;;;;;;;;;kDAIxG,kPAAC,6LAAM;wCAAC,SAAQ;wCAAQ,MAAK;wCAAK,SAAS;wCAAc,WAAU;;0DAC/D,kPAAC,4QAAM;gDAAC,WAAU;;;;;;4CAAiB;;;;;;;;;;;;;;;;;;;kCAK/C,kPAAC;wBAAK,WAAU;kCACX;;;;;;;;;;;;;;;;;;AAKrB;GAjDwB;;QACH,yMAAW;QACb,uMAAS;QACA,gMAAU;;;KAHd"}}]
}