{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["// app/actions.ts\r\n\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// Evita instanciar múltiples clientes en desarrollo\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- LEER TODOS LOS DATOS ---\r\nexport async function getFinanceData() {\r\n  \r\n  const accounts = await prisma.account.findMany();\r\n  const categories = await prisma.category.findMany();\r\n  const transactions = await prisma.transaction.findMany({ orderBy: { date: 'desc' } });\r\n  const fixedRules = await prisma.fixedRule.findMany();\r\n  const simulatorItems = await prisma.simulatorItem.findMany();\r\n\r\n  // Convertimos datos complejos para que React los entienda (Fechas y JSON)\r\n  const parsedCategories = categories.map(c => ({\r\n    ...c,\r\n    subCategories: c.subCategories ? JSON.parse(c.subCategories) : []\r\n  }));\r\n\r\n  const parsedTransactions = transactions.map(t => ({\r\n    ...t,\r\n    date: t.date.toISOString(), // React prefiere strings para fechas\r\n    accountId: t.accountId,\r\n    categoryId: t.categoryId\r\n  }));\r\n\r\n  return {\r\n    accounts,\r\n    categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n    transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n    fixedRules,\r\n    simulatorItems\r\n  };\r\n}\r\n\r\n// --- CREAR TRANSACCIÓN INTELIGENTE ---\r\nexport async function createTransaction(data: any) {\r\n  const date = new Date(data.date);\r\n\r\n  // CASO 1: TRANSFERENCIA ENTRE CUENTAS\r\n  if (data.type === 'transfer') {\r\n      // 1. Salida (Gasto) de Cuenta A\r\n      await prisma.transaction.create({\r\n          data: {\r\n              type: 'expense',\r\n              amount: data.amount,\r\n              accountId: data.accountId, // Origen\r\n              description: `Transferencia a: ${data.destAccountName}`,\r\n              date: date,\r\n              isTransfer: true,\r\n              relatedAccountId: data.relatedAccountId, // Destino\r\n              didWithdraw: true\r\n          }\r\n      });\r\n      // Restar de Origen\r\n      await prisma.account.update({\r\n          where: { id: data.accountId },\r\n          data: { balance: { decrement: data.amount } }\r\n      });\r\n\r\n      // 2. Entrada (Ingreso) a Cuenta B\r\n      await prisma.transaction.create({\r\n          data: {\r\n              type: 'income',\r\n              amount: data.amount,\r\n              accountId: data.relatedAccountId, // Destino\r\n              description: `Recibido de: ${data.originAccountName}`,\r\n              date: date,\r\n              isTransfer: true,\r\n              relatedAccountId: data.accountId, // Origen\r\n              didWithdraw: false // Irrelevante en ingreso, pero por consistencia\r\n          }\r\n      });\r\n      // Sumar a Destino\r\n      await prisma.account.update({\r\n          where: { id: data.relatedAccountId },\r\n          data: { balance: { increment: data.amount } }\r\n      });\r\n  } \r\n  // CASO 2: MOVIMIENTO NORMAL (Ingreso / Gasto / Ahorro)\r\n  else {\r\n      // Si es \"Ahorro que NO se retira\", no descontamos saldo\r\n      const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n\r\n      await prisma.transaction.create({\r\n          data: {\r\n              type: data.type,\r\n              amount: data.amount,\r\n              budgetedAmount: data.budgetedAmount,\r\n              accountId: data.accountId,\r\n              categoryId: data.categoryId,\r\n              description: data.description,\r\n              date: date,\r\n              isFixed: data.isFixed || false,\r\n              isSavings: data.isSavings || false,\r\n              didWithdraw: data.didWithdraw ?? true\r\n          }\r\n      });\r\n\r\n      if (shouldUpdateBalance) {\r\n          const multiplier = data.type === 'income' ? 1 : -1;\r\n          await prisma.account.update({\r\n              where: { id: data.accountId },\r\n              data: { balance: { increment: data.amount * multiplier } }\r\n          });\r\n      }\r\n\r\n      // CASO ESPECIAL: Ahorro (se retire o no) -> Sumar a la \"Cartera de Ahorro\" virtual\r\n      // Buscamos o creamos una cuenta virtual de ahorro para llevar el registro\r\n      if (data.isSavings) {\r\n          // Buscamos una cuenta tipo 'savings_virtual'\r\n          let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual' } });\r\n          \r\n          if (!savingsAcc) {\r\n             savingsAcc = await prisma.account.create({\r\n                 data: { name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Todos', color: '#3b82f6' }\r\n             });\r\n          }\r\n\r\n          // Sumamos el valor a esa cuenta virtual (siempre suma, nunca resta)\r\n          await prisma.account.update({\r\n              where: { id: savingsAcc.id },\r\n              data: { balance: { increment: data.amount } }\r\n          });\r\n      }\r\n  }\r\n\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE CUENTAS ---\r\nexport async function createAccount(data: any) {\r\n  await prisma.account.create({ data });\r\n  revalidatePath('/');\r\n}\r\n\r\nexport async function deleteAccount(id: string) {\r\n  await prisma.account.delete({ where: { id } });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE CATEGORIAS ---\r\nexport async function createCategory(data: any) {\r\n  await prisma.category.create({\r\n    data: {\r\n        name: data.name,\r\n        type: data.type,\r\n        subCategories: JSON.stringify(data.subCategories || [])\r\n    }\r\n  });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE SIMULADOR ---\r\nexport async function saveSimulatorItem(data: any) {\r\n    // Si existe ID lo actualiza, si no, crea uno nuevo\r\n    const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } });\r\n    if (existing) {\r\n        await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } });\r\n    } else {\r\n        await prisma.simulatorItem.create({ data });\r\n    }\r\n    revalidatePath('/simulator');\r\n}\r\n\r\nexport async function deleteSimulatorItem(id: string) {\r\n    await prisma.simulatorItem.delete({ where: { id } });\r\n    revalidatePath('/simulator');\r\n}\r\n\r\n// --- REGLAS FIJAS ---\r\nexport async function createFixedRule(data: any) {\r\n    await prisma.fixedRule.create({ data });\r\n    revalidatePath('/');\r\n}\r\n\r\n// --- FUNCIÓN PARA POBLAR DATOS INICIALES (SEED) ---\r\nexport async function seedDatabase() {\r\n  // 1. Crear Cuentas por defecto\r\n  const acc1 = await prisma.account.create({\r\n    data: { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', balance: 0 }\r\n  });\r\n  \r\n  const acc2 = await prisma.account.create({\r\n    data: { name: 'Efectivo', bank: 'Bolsillo', type: 'cash', owner: 'Jhonattan', color: '#22c55e', balance: 0 }\r\n  });\r\n\r\n  // 2. Crear Categorías por defecto\r\n  await prisma.category.create({\r\n    data: { name: 'Efectivo', type: 'income', subCategories: JSON.stringify(['Retiro']) }\r\n  });\r\n\r\n  \r\n  \r\n  // 2. Categorías Básicas\r\n  const catCount = await prisma.category.count();\r\n  if (catCount === 0) {\r\n      await prisma.category.createMany({\r\n          data: [\r\n            { name: 'Efectivo', type: 'income', subCategories: JSON.stringify(['Retiro'])  }\r\n          ]\r\n      });\r\n  }\r\n  \r\n  // 3. Categoría Especial de Ahorro (Esta era la que fallaba)\r\n  // Usamos upsert: Si existe no hace nada (update vacío), si no existe, la crea.\r\n  await prisma.category.upsert({\r\n    where: { id: 'cat_sys_savings' },\r\n    update: {},\r\n    create: { id: 'cat_sys_savings', name: 'Ahorro Automático', type: 'income', subCategories: '[]' }\r\n  });\r\n\r\n  revalidatePath('/');\r\n  return { success: true };\r\n}"],"names":[],"mappings":";;;;;;;IAYsB,iBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 19, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["// app/actions.ts\r\n\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// Evita instanciar múltiples clientes en desarrollo\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- LEER TODOS LOS DATOS ---\r\nexport async function getFinanceData() {\r\n  \r\n  const accounts = await prisma.account.findMany();\r\n  const categories = await prisma.category.findMany();\r\n  const transactions = await prisma.transaction.findMany({ orderBy: { date: 'desc' } });\r\n  const fixedRules = await prisma.fixedRule.findMany();\r\n  const simulatorItems = await prisma.simulatorItem.findMany();\r\n\r\n  // Convertimos datos complejos para que React los entienda (Fechas y JSON)\r\n  const parsedCategories = categories.map(c => ({\r\n    ...c,\r\n    subCategories: c.subCategories ? JSON.parse(c.subCategories) : []\r\n  }));\r\n\r\n  const parsedTransactions = transactions.map(t => ({\r\n    ...t,\r\n    date: t.date.toISOString(), // React prefiere strings para fechas\r\n    accountId: t.accountId,\r\n    categoryId: t.categoryId\r\n  }));\r\n\r\n  return {\r\n    accounts,\r\n    categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n    transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n    fixedRules,\r\n    simulatorItems\r\n  };\r\n}\r\n\r\n// --- CREAR TRANSACCIÓN INTELIGENTE ---\r\nexport async function createTransaction(data: any) {\r\n  const date = new Date(data.date);\r\n\r\n  // CASO 1: TRANSFERENCIA ENTRE CUENTAS\r\n  if (data.type === 'transfer') {\r\n      // 1. Salida (Gasto) de Cuenta A\r\n      await prisma.transaction.create({\r\n          data: {\r\n              type: 'expense',\r\n              amount: data.amount,\r\n              accountId: data.accountId, // Origen\r\n              description: `Transferencia a: ${data.destAccountName}`,\r\n              date: date,\r\n              isTransfer: true,\r\n              relatedAccountId: data.relatedAccountId, // Destino\r\n              didWithdraw: true\r\n          }\r\n      });\r\n      // Restar de Origen\r\n      await prisma.account.update({\r\n          where: { id: data.accountId },\r\n          data: { balance: { decrement: data.amount } }\r\n      });\r\n\r\n      // 2. Entrada (Ingreso) a Cuenta B\r\n      await prisma.transaction.create({\r\n          data: {\r\n              type: 'income',\r\n              amount: data.amount,\r\n              accountId: data.relatedAccountId, // Destino\r\n              description: `Recibido de: ${data.originAccountName}`,\r\n              date: date,\r\n              isTransfer: true,\r\n              relatedAccountId: data.accountId, // Origen\r\n              didWithdraw: false // Irrelevante en ingreso, pero por consistencia\r\n          }\r\n      });\r\n      // Sumar a Destino\r\n      await prisma.account.update({\r\n          where: { id: data.relatedAccountId },\r\n          data: { balance: { increment: data.amount } }\r\n      });\r\n  } \r\n  // CASO 2: MOVIMIENTO NORMAL (Ingreso / Gasto / Ahorro)\r\n  else {\r\n      // Si es \"Ahorro que NO se retira\", no descontamos saldo\r\n      const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n\r\n      await prisma.transaction.create({\r\n          data: {\r\n              type: data.type,\r\n              amount: data.amount,\r\n              budgetedAmount: data.budgetedAmount,\r\n              accountId: data.accountId,\r\n              categoryId: data.categoryId,\r\n              description: data.description,\r\n              date: date,\r\n              isFixed: data.isFixed || false,\r\n              isSavings: data.isSavings || false,\r\n              didWithdraw: data.didWithdraw ?? true\r\n          }\r\n      });\r\n\r\n      if (shouldUpdateBalance) {\r\n          const multiplier = data.type === 'income' ? 1 : -1;\r\n          await prisma.account.update({\r\n              where: { id: data.accountId },\r\n              data: { balance: { increment: data.amount * multiplier } }\r\n          });\r\n      }\r\n\r\n      // CASO ESPECIAL: Ahorro (se retire o no) -> Sumar a la \"Cartera de Ahorro\" virtual\r\n      // Buscamos o creamos una cuenta virtual de ahorro para llevar el registro\r\n      if (data.isSavings) {\r\n          // Buscamos una cuenta tipo 'savings_virtual'\r\n          let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual' } });\r\n          \r\n          if (!savingsAcc) {\r\n             savingsAcc = await prisma.account.create({\r\n                 data: { name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Todos', color: '#3b82f6' }\r\n             });\r\n          }\r\n\r\n          // Sumamos el valor a esa cuenta virtual (siempre suma, nunca resta)\r\n          await prisma.account.update({\r\n              where: { id: savingsAcc.id },\r\n              data: { balance: { increment: data.amount } }\r\n          });\r\n      }\r\n  }\r\n\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE CUENTAS ---\r\nexport async function createAccount(data: any) {\r\n  await prisma.account.create({ data });\r\n  revalidatePath('/');\r\n}\r\n\r\nexport async function deleteAccount(id: string) {\r\n  await prisma.account.delete({ where: { id } });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE CATEGORIAS ---\r\nexport async function createCategory(data: any) {\r\n  await prisma.category.create({\r\n    data: {\r\n        name: data.name,\r\n        type: data.type,\r\n        subCategories: JSON.stringify(data.subCategories || [])\r\n    }\r\n  });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE SIMULADOR ---\r\nexport async function saveSimulatorItem(data: any) {\r\n    // Si existe ID lo actualiza, si no, crea uno nuevo\r\n    const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } });\r\n    if (existing) {\r\n        await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } });\r\n    } else {\r\n        await prisma.simulatorItem.create({ data });\r\n    }\r\n    revalidatePath('/simulator');\r\n}\r\n\r\nexport async function deleteSimulatorItem(id: string) {\r\n    await prisma.simulatorItem.delete({ where: { id } });\r\n    revalidatePath('/simulator');\r\n}\r\n\r\n// --- REGLAS FIJAS ---\r\nexport async function createFixedRule(data: any) {\r\n    await prisma.fixedRule.create({ data });\r\n    revalidatePath('/');\r\n}\r\n\r\n// --- FUNCIÓN PARA POBLAR DATOS INICIALES (SEED) ---\r\nexport async function seedDatabase() {\r\n  // 1. Crear Cuentas por defecto\r\n  const acc1 = await prisma.account.create({\r\n    data: { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', balance: 0 }\r\n  });\r\n  \r\n  const acc2 = await prisma.account.create({\r\n    data: { name: 'Efectivo', bank: 'Bolsillo', type: 'cash', owner: 'Jhonattan', color: '#22c55e', balance: 0 }\r\n  });\r\n\r\n  // 2. Crear Categorías por defecto\r\n  await prisma.category.create({\r\n    data: { name: 'Efectivo', type: 'income', subCategories: JSON.stringify(['Retiro']) }\r\n  });\r\n\r\n  \r\n  \r\n  // 2. Categorías Básicas\r\n  const catCount = await prisma.category.count();\r\n  if (catCount === 0) {\r\n      await prisma.category.createMany({\r\n          data: [\r\n            { name: 'Efectivo', type: 'income', subCategories: JSON.stringify(['Retiro'])  }\r\n          ]\r\n      });\r\n  }\r\n  \r\n  // 3. Categoría Especial de Ahorro (Esta era la que fallaba)\r\n  // Usamos upsert: Si existe no hace nada (update vacío), si no existe, la crea.\r\n  await prisma.category.upsert({\r\n    where: { id: 'cat_sys_savings' },\r\n    update: {},\r\n    create: { id: 'cat_sys_savings', name: 'Ahorro Automático', type: 'income', subCategories: '[]' }\r\n  });\r\n\r\n  revalidatePath('/');\r\n  return { success: true };\r\n}"],"names":[],"mappings":";;;;;;;IA2CsB,oBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["// app/actions.ts\r\n\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// Evita instanciar múltiples clientes en desarrollo\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- LEER TODOS LOS DATOS ---\r\nexport async function getFinanceData() {\r\n  \r\n  const accounts = await prisma.account.findMany();\r\n  const categories = await prisma.category.findMany();\r\n  const transactions = await prisma.transaction.findMany({ orderBy: { date: 'desc' } });\r\n  const fixedRules = await prisma.fixedRule.findMany();\r\n  const simulatorItems = await prisma.simulatorItem.findMany();\r\n\r\n  // Convertimos datos complejos para que React los entienda (Fechas y JSON)\r\n  const parsedCategories = categories.map(c => ({\r\n    ...c,\r\n    subCategories: c.subCategories ? JSON.parse(c.subCategories) : []\r\n  }));\r\n\r\n  const parsedTransactions = transactions.map(t => ({\r\n    ...t,\r\n    date: t.date.toISOString(), // React prefiere strings para fechas\r\n    accountId: t.accountId,\r\n    categoryId: t.categoryId\r\n  }));\r\n\r\n  return {\r\n    accounts,\r\n    categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n    transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n    fixedRules,\r\n    simulatorItems\r\n  };\r\n}\r\n\r\n// --- CREAR TRANSACCIÓN INTELIGENTE ---\r\nexport async function createTransaction(data: any) {\r\n  const date = new Date(data.date);\r\n\r\n  // CASO 1: TRANSFERENCIA ENTRE CUENTAS\r\n  if (data.type === 'transfer') {\r\n      // 1. Salida (Gasto) de Cuenta A\r\n      await prisma.transaction.create({\r\n          data: {\r\n              type: 'expense',\r\n              amount: data.amount,\r\n              accountId: data.accountId, // Origen\r\n              description: `Transferencia a: ${data.destAccountName}`,\r\n              date: date,\r\n              isTransfer: true,\r\n              relatedAccountId: data.relatedAccountId, // Destino\r\n              didWithdraw: true\r\n          }\r\n      });\r\n      // Restar de Origen\r\n      await prisma.account.update({\r\n          where: { id: data.accountId },\r\n          data: { balance: { decrement: data.amount } }\r\n      });\r\n\r\n      // 2. Entrada (Ingreso) a Cuenta B\r\n      await prisma.transaction.create({\r\n          data: {\r\n              type: 'income',\r\n              amount: data.amount,\r\n              accountId: data.relatedAccountId, // Destino\r\n              description: `Recibido de: ${data.originAccountName}`,\r\n              date: date,\r\n              isTransfer: true,\r\n              relatedAccountId: data.accountId, // Origen\r\n              didWithdraw: false // Irrelevante en ingreso, pero por consistencia\r\n          }\r\n      });\r\n      // Sumar a Destino\r\n      await prisma.account.update({\r\n          where: { id: data.relatedAccountId },\r\n          data: { balance: { increment: data.amount } }\r\n      });\r\n  } \r\n  // CASO 2: MOVIMIENTO NORMAL (Ingreso / Gasto / Ahorro)\r\n  else {\r\n      // Si es \"Ahorro que NO se retira\", no descontamos saldo\r\n      const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n\r\n      await prisma.transaction.create({\r\n          data: {\r\n              type: data.type,\r\n              amount: data.amount,\r\n              budgetedAmount: data.budgetedAmount,\r\n              accountId: data.accountId,\r\n              categoryId: data.categoryId,\r\n              description: data.description,\r\n              date: date,\r\n              isFixed: data.isFixed || false,\r\n              isSavings: data.isSavings || false,\r\n              didWithdraw: data.didWithdraw ?? true\r\n          }\r\n      });\r\n\r\n      if (shouldUpdateBalance) {\r\n          const multiplier = data.type === 'income' ? 1 : -1;\r\n          await prisma.account.update({\r\n              where: { id: data.accountId },\r\n              data: { balance: { increment: data.amount * multiplier } }\r\n          });\r\n      }\r\n\r\n      // CASO ESPECIAL: Ahorro (se retire o no) -> Sumar a la \"Cartera de Ahorro\" virtual\r\n      // Buscamos o creamos una cuenta virtual de ahorro para llevar el registro\r\n      if (data.isSavings) {\r\n          // Buscamos una cuenta tipo 'savings_virtual'\r\n          let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual' } });\r\n          \r\n          if (!savingsAcc) {\r\n             savingsAcc = await prisma.account.create({\r\n                 data: { name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Todos', color: '#3b82f6' }\r\n             });\r\n          }\r\n\r\n          // Sumamos el valor a esa cuenta virtual (siempre suma, nunca resta)\r\n          await prisma.account.update({\r\n              where: { id: savingsAcc.id },\r\n              data: { balance: { increment: data.amount } }\r\n          });\r\n      }\r\n  }\r\n\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE CUENTAS ---\r\nexport async function createAccount(data: any) {\r\n  await prisma.account.create({ data });\r\n  revalidatePath('/');\r\n}\r\n\r\nexport async function deleteAccount(id: string) {\r\n  await prisma.account.delete({ where: { id } });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE CATEGORIAS ---\r\nexport async function createCategory(data: any) {\r\n  await prisma.category.create({\r\n    data: {\r\n        name: data.name,\r\n        type: data.type,\r\n        subCategories: JSON.stringify(data.subCategories || [])\r\n    }\r\n  });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE SIMULADOR ---\r\nexport async function saveSimulatorItem(data: any) {\r\n    // Si existe ID lo actualiza, si no, crea uno nuevo\r\n    const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } });\r\n    if (existing) {\r\n        await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } });\r\n    } else {\r\n        await prisma.simulatorItem.create({ data });\r\n    }\r\n    revalidatePath('/simulator');\r\n}\r\n\r\nexport async function deleteSimulatorItem(id: string) {\r\n    await prisma.simulatorItem.delete({ where: { id } });\r\n    revalidatePath('/simulator');\r\n}\r\n\r\n// --- REGLAS FIJAS ---\r\nexport async function createFixedRule(data: any) {\r\n    await prisma.fixedRule.create({ data });\r\n    revalidatePath('/');\r\n}\r\n\r\n// --- FUNCIÓN PARA POBLAR DATOS INICIALES (SEED) ---\r\nexport async function seedDatabase() {\r\n  // 1. Crear Cuentas por defecto\r\n  const acc1 = await prisma.account.create({\r\n    data: { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', balance: 0 }\r\n  });\r\n  \r\n  const acc2 = await prisma.account.create({\r\n    data: { name: 'Efectivo', bank: 'Bolsillo', type: 'cash', owner: 'Jhonattan', color: '#22c55e', balance: 0 }\r\n  });\r\n\r\n  // 2. Crear Categorías por defecto\r\n  await prisma.category.create({\r\n    data: { name: 'Efectivo', type: 'income', subCategories: JSON.stringify(['Retiro']) }\r\n  });\r\n\r\n  \r\n  \r\n  // 2. Categorías Básicas\r\n  const catCount = await prisma.category.count();\r\n  if (catCount === 0) {\r\n      await prisma.category.createMany({\r\n          data: [\r\n            { name: 'Efectivo', type: 'income', subCategories: JSON.stringify(['Retiro'])  }\r\n          ]\r\n      });\r\n  }\r\n  \r\n  // 3. Categoría Especial de Ahorro (Esta era la que fallaba)\r\n  // Usamos upsert: Si existe no hace nada (update vacío), si no existe, la crea.\r\n  await prisma.category.upsert({\r\n    where: { id: 'cat_sys_savings' },\r\n    update: {},\r\n    create: { id: 'cat_sys_savings', name: 'Ahorro Automático', type: 'income', subCategories: '[]' }\r\n  });\r\n\r\n  revalidatePath('/');\r\n  return { success: true };\r\n}"],"names":[],"mappings":";;;;;;;IA0IsB,gBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 49, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["// app/actions.ts\r\n\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// Evita instanciar múltiples clientes en desarrollo\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- LEER TODOS LOS DATOS ---\r\nexport async function getFinanceData() {\r\n  \r\n  const accounts = await prisma.account.findMany();\r\n  const categories = await prisma.category.findMany();\r\n  const transactions = await prisma.transaction.findMany({ orderBy: { date: 'desc' } });\r\n  const fixedRules = await prisma.fixedRule.findMany();\r\n  const simulatorItems = await prisma.simulatorItem.findMany();\r\n\r\n  // Convertimos datos complejos para que React los entienda (Fechas y JSON)\r\n  const parsedCategories = categories.map(c => ({\r\n    ...c,\r\n    subCategories: c.subCategories ? JSON.parse(c.subCategories) : []\r\n  }));\r\n\r\n  const parsedTransactions = transactions.map(t => ({\r\n    ...t,\r\n    date: t.date.toISOString(), // React prefiere strings para fechas\r\n    accountId: t.accountId,\r\n    categoryId: t.categoryId\r\n  }));\r\n\r\n  return {\r\n    accounts,\r\n    categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n    transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n    fixedRules,\r\n    simulatorItems\r\n  };\r\n}\r\n\r\n// --- CREAR TRANSACCIÓN INTELIGENTE ---\r\nexport async function createTransaction(data: any) {\r\n  const date = new Date(data.date);\r\n\r\n  // CASO 1: TRANSFERENCIA ENTRE CUENTAS\r\n  if (data.type === 'transfer') {\r\n      // 1. Salida (Gasto) de Cuenta A\r\n      await prisma.transaction.create({\r\n          data: {\r\n              type: 'expense',\r\n              amount: data.amount,\r\n              accountId: data.accountId, // Origen\r\n              description: `Transferencia a: ${data.destAccountName}`,\r\n              date: date,\r\n              isTransfer: true,\r\n              relatedAccountId: data.relatedAccountId, // Destino\r\n              didWithdraw: true\r\n          }\r\n      });\r\n      // Restar de Origen\r\n      await prisma.account.update({\r\n          where: { id: data.accountId },\r\n          data: { balance: { decrement: data.amount } }\r\n      });\r\n\r\n      // 2. Entrada (Ingreso) a Cuenta B\r\n      await prisma.transaction.create({\r\n          data: {\r\n              type: 'income',\r\n              amount: data.amount,\r\n              accountId: data.relatedAccountId, // Destino\r\n              description: `Recibido de: ${data.originAccountName}`,\r\n              date: date,\r\n              isTransfer: true,\r\n              relatedAccountId: data.accountId, // Origen\r\n              didWithdraw: false // Irrelevante en ingreso, pero por consistencia\r\n          }\r\n      });\r\n      // Sumar a Destino\r\n      await prisma.account.update({\r\n          where: { id: data.relatedAccountId },\r\n          data: { balance: { increment: data.amount } }\r\n      });\r\n  } \r\n  // CASO 2: MOVIMIENTO NORMAL (Ingreso / Gasto / Ahorro)\r\n  else {\r\n      // Si es \"Ahorro que NO se retira\", no descontamos saldo\r\n      const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n\r\n      await prisma.transaction.create({\r\n          data: {\r\n              type: data.type,\r\n              amount: data.amount,\r\n              budgetedAmount: data.budgetedAmount,\r\n              accountId: data.accountId,\r\n              categoryId: data.categoryId,\r\n              description: data.description,\r\n              date: date,\r\n              isFixed: data.isFixed || false,\r\n              isSavings: data.isSavings || false,\r\n              didWithdraw: data.didWithdraw ?? true\r\n          }\r\n      });\r\n\r\n      if (shouldUpdateBalance) {\r\n          const multiplier = data.type === 'income' ? 1 : -1;\r\n          await prisma.account.update({\r\n              where: { id: data.accountId },\r\n              data: { balance: { increment: data.amount * multiplier } }\r\n          });\r\n      }\r\n\r\n      // CASO ESPECIAL: Ahorro (se retire o no) -> Sumar a la \"Cartera de Ahorro\" virtual\r\n      // Buscamos o creamos una cuenta virtual de ahorro para llevar el registro\r\n      if (data.isSavings) {\r\n          // Buscamos una cuenta tipo 'savings_virtual'\r\n          let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual' } });\r\n          \r\n          if (!savingsAcc) {\r\n             savingsAcc = await prisma.account.create({\r\n                 data: { name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Todos', color: '#3b82f6' }\r\n             });\r\n          }\r\n\r\n          // Sumamos el valor a esa cuenta virtual (siempre suma, nunca resta)\r\n          await prisma.account.update({\r\n              where: { id: savingsAcc.id },\r\n              data: { balance: { increment: data.amount } }\r\n          });\r\n      }\r\n  }\r\n\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE CUENTAS ---\r\nexport async function createAccount(data: any) {\r\n  await prisma.account.create({ data });\r\n  revalidatePath('/');\r\n}\r\n\r\nexport async function deleteAccount(id: string) {\r\n  await prisma.account.delete({ where: { id } });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE CATEGORIAS ---\r\nexport async function createCategory(data: any) {\r\n  await prisma.category.create({\r\n    data: {\r\n        name: data.name,\r\n        type: data.type,\r\n        subCategories: JSON.stringify(data.subCategories || [])\r\n    }\r\n  });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE SIMULADOR ---\r\nexport async function saveSimulatorItem(data: any) {\r\n    // Si existe ID lo actualiza, si no, crea uno nuevo\r\n    const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } });\r\n    if (existing) {\r\n        await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } });\r\n    } else {\r\n        await prisma.simulatorItem.create({ data });\r\n    }\r\n    revalidatePath('/simulator');\r\n}\r\n\r\nexport async function deleteSimulatorItem(id: string) {\r\n    await prisma.simulatorItem.delete({ where: { id } });\r\n    revalidatePath('/simulator');\r\n}\r\n\r\n// --- REGLAS FIJAS ---\r\nexport async function createFixedRule(data: any) {\r\n    await prisma.fixedRule.create({ data });\r\n    revalidatePath('/');\r\n}\r\n\r\n// --- FUNCIÓN PARA POBLAR DATOS INICIALES (SEED) ---\r\nexport async function seedDatabase() {\r\n  // 1. Crear Cuentas por defecto\r\n  const acc1 = await prisma.account.create({\r\n    data: { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', balance: 0 }\r\n  });\r\n  \r\n  const acc2 = await prisma.account.create({\r\n    data: { name: 'Efectivo', bank: 'Bolsillo', type: 'cash', owner: 'Jhonattan', color: '#22c55e', balance: 0 }\r\n  });\r\n\r\n  // 2. Crear Categorías por defecto\r\n  await prisma.category.create({\r\n    data: { name: 'Efectivo', type: 'income', subCategories: JSON.stringify(['Retiro']) }\r\n  });\r\n\r\n  \r\n  \r\n  // 2. Categorías Básicas\r\n  const catCount = await prisma.category.count();\r\n  if (catCount === 0) {\r\n      await prisma.category.createMany({\r\n          data: [\r\n            { name: 'Efectivo', type: 'income', subCategories: JSON.stringify(['Retiro'])  }\r\n          ]\r\n      });\r\n  }\r\n  \r\n  // 3. Categoría Especial de Ahorro (Esta era la que fallaba)\r\n  // Usamos upsert: Si existe no hace nada (update vacío), si no existe, la crea.\r\n  await prisma.category.upsert({\r\n    where: { id: 'cat_sys_savings' },\r\n    update: {},\r\n    create: { id: 'cat_sys_savings', name: 'Ahorro Automático', type: 'income', subCategories: '[]' }\r\n  });\r\n\r\n  revalidatePath('/');\r\n  return { success: true };\r\n}"],"names":[],"mappings":";;;;;;;IA+IsB,gBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["// app/actions.ts\r\n\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// Evita instanciar múltiples clientes en desarrollo\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- LEER TODOS LOS DATOS ---\r\nexport async function getFinanceData() {\r\n  \r\n  const accounts = await prisma.account.findMany();\r\n  const categories = await prisma.category.findMany();\r\n  const transactions = await prisma.transaction.findMany({ orderBy: { date: 'desc' } });\r\n  const fixedRules = await prisma.fixedRule.findMany();\r\n  const simulatorItems = await prisma.simulatorItem.findMany();\r\n\r\n  // Convertimos datos complejos para que React los entienda (Fechas y JSON)\r\n  const parsedCategories = categories.map(c => ({\r\n    ...c,\r\n    subCategories: c.subCategories ? JSON.parse(c.subCategories) : []\r\n  }));\r\n\r\n  const parsedTransactions = transactions.map(t => ({\r\n    ...t,\r\n    date: t.date.toISOString(), // React prefiere strings para fechas\r\n    accountId: t.accountId,\r\n    categoryId: t.categoryId\r\n  }));\r\n\r\n  return {\r\n    accounts,\r\n    categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n    transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n    fixedRules,\r\n    simulatorItems\r\n  };\r\n}\r\n\r\n// --- CREAR TRANSACCIÓN INTELIGENTE ---\r\nexport async function createTransaction(data: any) {\r\n  const date = new Date(data.date);\r\n\r\n  // CASO 1: TRANSFERENCIA ENTRE CUENTAS\r\n  if (data.type === 'transfer') {\r\n      // 1. Salida (Gasto) de Cuenta A\r\n      await prisma.transaction.create({\r\n          data: {\r\n              type: 'expense',\r\n              amount: data.amount,\r\n              accountId: data.accountId, // Origen\r\n              description: `Transferencia a: ${data.destAccountName}`,\r\n              date: date,\r\n              isTransfer: true,\r\n              relatedAccountId: data.relatedAccountId, // Destino\r\n              didWithdraw: true\r\n          }\r\n      });\r\n      // Restar de Origen\r\n      await prisma.account.update({\r\n          where: { id: data.accountId },\r\n          data: { balance: { decrement: data.amount } }\r\n      });\r\n\r\n      // 2. Entrada (Ingreso) a Cuenta B\r\n      await prisma.transaction.create({\r\n          data: {\r\n              type: 'income',\r\n              amount: data.amount,\r\n              accountId: data.relatedAccountId, // Destino\r\n              description: `Recibido de: ${data.originAccountName}`,\r\n              date: date,\r\n              isTransfer: true,\r\n              relatedAccountId: data.accountId, // Origen\r\n              didWithdraw: false // Irrelevante en ingreso, pero por consistencia\r\n          }\r\n      });\r\n      // Sumar a Destino\r\n      await prisma.account.update({\r\n          where: { id: data.relatedAccountId },\r\n          data: { balance: { increment: data.amount } }\r\n      });\r\n  } \r\n  // CASO 2: MOVIMIENTO NORMAL (Ingreso / Gasto / Ahorro)\r\n  else {\r\n      // Si es \"Ahorro que NO se retira\", no descontamos saldo\r\n      const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n\r\n      await prisma.transaction.create({\r\n          data: {\r\n              type: data.type,\r\n              amount: data.amount,\r\n              budgetedAmount: data.budgetedAmount,\r\n              accountId: data.accountId,\r\n              categoryId: data.categoryId,\r\n              description: data.description,\r\n              date: date,\r\n              isFixed: data.isFixed || false,\r\n              isSavings: data.isSavings || false,\r\n              didWithdraw: data.didWithdraw ?? true\r\n          }\r\n      });\r\n\r\n      if (shouldUpdateBalance) {\r\n          const multiplier = data.type === 'income' ? 1 : -1;\r\n          await prisma.account.update({\r\n              where: { id: data.accountId },\r\n              data: { balance: { increment: data.amount * multiplier } }\r\n          });\r\n      }\r\n\r\n      // CASO ESPECIAL: Ahorro (se retire o no) -> Sumar a la \"Cartera de Ahorro\" virtual\r\n      // Buscamos o creamos una cuenta virtual de ahorro para llevar el registro\r\n      if (data.isSavings) {\r\n          // Buscamos una cuenta tipo 'savings_virtual'\r\n          let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual' } });\r\n          \r\n          if (!savingsAcc) {\r\n             savingsAcc = await prisma.account.create({\r\n                 data: { name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Todos', color: '#3b82f6' }\r\n             });\r\n          }\r\n\r\n          // Sumamos el valor a esa cuenta virtual (siempre suma, nunca resta)\r\n          await prisma.account.update({\r\n              where: { id: savingsAcc.id },\r\n              data: { balance: { increment: data.amount } }\r\n          });\r\n      }\r\n  }\r\n\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE CUENTAS ---\r\nexport async function createAccount(data: any) {\r\n  await prisma.account.create({ data });\r\n  revalidatePath('/');\r\n}\r\n\r\nexport async function deleteAccount(id: string) {\r\n  await prisma.account.delete({ where: { id } });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE CATEGORIAS ---\r\nexport async function createCategory(data: any) {\r\n  await prisma.category.create({\r\n    data: {\r\n        name: data.name,\r\n        type: data.type,\r\n        subCategories: JSON.stringify(data.subCategories || [])\r\n    }\r\n  });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE SIMULADOR ---\r\nexport async function saveSimulatorItem(data: any) {\r\n    // Si existe ID lo actualiza, si no, crea uno nuevo\r\n    const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } });\r\n    if (existing) {\r\n        await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } });\r\n    } else {\r\n        await prisma.simulatorItem.create({ data });\r\n    }\r\n    revalidatePath('/simulator');\r\n}\r\n\r\nexport async function deleteSimulatorItem(id: string) {\r\n    await prisma.simulatorItem.delete({ where: { id } });\r\n    revalidatePath('/simulator');\r\n}\r\n\r\n// --- REGLAS FIJAS ---\r\nexport async function createFixedRule(data: any) {\r\n    await prisma.fixedRule.create({ data });\r\n    revalidatePath('/');\r\n}\r\n\r\n// --- FUNCIÓN PARA POBLAR DATOS INICIALES (SEED) ---\r\nexport async function seedDatabase() {\r\n  // 1. Crear Cuentas por defecto\r\n  const acc1 = await prisma.account.create({\r\n    data: { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', balance: 0 }\r\n  });\r\n  \r\n  const acc2 = await prisma.account.create({\r\n    data: { name: 'Efectivo', bank: 'Bolsillo', type: 'cash', owner: 'Jhonattan', color: '#22c55e', balance: 0 }\r\n  });\r\n\r\n  // 2. Crear Categorías por defecto\r\n  await prisma.category.create({\r\n    data: { name: 'Efectivo', type: 'income', subCategories: JSON.stringify(['Retiro']) }\r\n  });\r\n\r\n  \r\n  \r\n  // 2. Categorías Básicas\r\n  const catCount = await prisma.category.count();\r\n  if (catCount === 0) {\r\n      await prisma.category.createMany({\r\n          data: [\r\n            { name: 'Efectivo', type: 'income', subCategories: JSON.stringify(['Retiro'])  }\r\n          ]\r\n      });\r\n  }\r\n  \r\n  // 3. Categoría Especial de Ahorro (Esta era la que fallaba)\r\n  // Usamos upsert: Si existe no hace nada (update vacío), si no existe, la crea.\r\n  await prisma.category.upsert({\r\n    where: { id: 'cat_sys_savings' },\r\n    update: {},\r\n    create: { id: 'cat_sys_savings', name: 'Ahorro Automático', type: 'income', subCategories: '[]' }\r\n  });\r\n\r\n  revalidatePath('/');\r\n  return { success: true };\r\n}"],"names":[],"mappings":";;;;;;;IAqJsB,iBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 79, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["// app/actions.ts\r\n\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// Evita instanciar múltiples clientes en desarrollo\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- LEER TODOS LOS DATOS ---\r\nexport async function getFinanceData() {\r\n  \r\n  const accounts = await prisma.account.findMany();\r\n  const categories = await prisma.category.findMany();\r\n  const transactions = await prisma.transaction.findMany({ orderBy: { date: 'desc' } });\r\n  const fixedRules = await prisma.fixedRule.findMany();\r\n  const simulatorItems = await prisma.simulatorItem.findMany();\r\n\r\n  // Convertimos datos complejos para que React los entienda (Fechas y JSON)\r\n  const parsedCategories = categories.map(c => ({\r\n    ...c,\r\n    subCategories: c.subCategories ? JSON.parse(c.subCategories) : []\r\n  }));\r\n\r\n  const parsedTransactions = transactions.map(t => ({\r\n    ...t,\r\n    date: t.date.toISOString(), // React prefiere strings para fechas\r\n    accountId: t.accountId,\r\n    categoryId: t.categoryId\r\n  }));\r\n\r\n  return {\r\n    accounts,\r\n    categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n    transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n    fixedRules,\r\n    simulatorItems\r\n  };\r\n}\r\n\r\n// --- CREAR TRANSACCIÓN INTELIGENTE ---\r\nexport async function createTransaction(data: any) {\r\n  const date = new Date(data.date);\r\n\r\n  // CASO 1: TRANSFERENCIA ENTRE CUENTAS\r\n  if (data.type === 'transfer') {\r\n      // 1. Salida (Gasto) de Cuenta A\r\n      await prisma.transaction.create({\r\n          data: {\r\n              type: 'expense',\r\n              amount: data.amount,\r\n              accountId: data.accountId, // Origen\r\n              description: `Transferencia a: ${data.destAccountName}`,\r\n              date: date,\r\n              isTransfer: true,\r\n              relatedAccountId: data.relatedAccountId, // Destino\r\n              didWithdraw: true\r\n          }\r\n      });\r\n      // Restar de Origen\r\n      await prisma.account.update({\r\n          where: { id: data.accountId },\r\n          data: { balance: { decrement: data.amount } }\r\n      });\r\n\r\n      // 2. Entrada (Ingreso) a Cuenta B\r\n      await prisma.transaction.create({\r\n          data: {\r\n              type: 'income',\r\n              amount: data.amount,\r\n              accountId: data.relatedAccountId, // Destino\r\n              description: `Recibido de: ${data.originAccountName}`,\r\n              date: date,\r\n              isTransfer: true,\r\n              relatedAccountId: data.accountId, // Origen\r\n              didWithdraw: false // Irrelevante en ingreso, pero por consistencia\r\n          }\r\n      });\r\n      // Sumar a Destino\r\n      await prisma.account.update({\r\n          where: { id: data.relatedAccountId },\r\n          data: { balance: { increment: data.amount } }\r\n      });\r\n  } \r\n  // CASO 2: MOVIMIENTO NORMAL (Ingreso / Gasto / Ahorro)\r\n  else {\r\n      // Si es \"Ahorro que NO se retira\", no descontamos saldo\r\n      const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n\r\n      await prisma.transaction.create({\r\n          data: {\r\n              type: data.type,\r\n              amount: data.amount,\r\n              budgetedAmount: data.budgetedAmount,\r\n              accountId: data.accountId,\r\n              categoryId: data.categoryId,\r\n              description: data.description,\r\n              date: date,\r\n              isFixed: data.isFixed || false,\r\n              isSavings: data.isSavings || false,\r\n              didWithdraw: data.didWithdraw ?? true\r\n          }\r\n      });\r\n\r\n      if (shouldUpdateBalance) {\r\n          const multiplier = data.type === 'income' ? 1 : -1;\r\n          await prisma.account.update({\r\n              where: { id: data.accountId },\r\n              data: { balance: { increment: data.amount * multiplier } }\r\n          });\r\n      }\r\n\r\n      // CASO ESPECIAL: Ahorro (se retire o no) -> Sumar a la \"Cartera de Ahorro\" virtual\r\n      // Buscamos o creamos una cuenta virtual de ahorro para llevar el registro\r\n      if (data.isSavings) {\r\n          // Buscamos una cuenta tipo 'savings_virtual'\r\n          let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual' } });\r\n          \r\n          if (!savingsAcc) {\r\n             savingsAcc = await prisma.account.create({\r\n                 data: { name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Todos', color: '#3b82f6' }\r\n             });\r\n          }\r\n\r\n          // Sumamos el valor a esa cuenta virtual (siempre suma, nunca resta)\r\n          await prisma.account.update({\r\n              where: { id: savingsAcc.id },\r\n              data: { balance: { increment: data.amount } }\r\n          });\r\n      }\r\n  }\r\n\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE CUENTAS ---\r\nexport async function createAccount(data: any) {\r\n  await prisma.account.create({ data });\r\n  revalidatePath('/');\r\n}\r\n\r\nexport async function deleteAccount(id: string) {\r\n  await prisma.account.delete({ where: { id } });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE CATEGORIAS ---\r\nexport async function createCategory(data: any) {\r\n  await prisma.category.create({\r\n    data: {\r\n        name: data.name,\r\n        type: data.type,\r\n        subCategories: JSON.stringify(data.subCategories || [])\r\n    }\r\n  });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE SIMULADOR ---\r\nexport async function saveSimulatorItem(data: any) {\r\n    // Si existe ID lo actualiza, si no, crea uno nuevo\r\n    const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } });\r\n    if (existing) {\r\n        await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } });\r\n    } else {\r\n        await prisma.simulatorItem.create({ data });\r\n    }\r\n    revalidatePath('/simulator');\r\n}\r\n\r\nexport async function deleteSimulatorItem(id: string) {\r\n    await prisma.simulatorItem.delete({ where: { id } });\r\n    revalidatePath('/simulator');\r\n}\r\n\r\n// --- REGLAS FIJAS ---\r\nexport async function createFixedRule(data: any) {\r\n    await prisma.fixedRule.create({ data });\r\n    revalidatePath('/');\r\n}\r\n\r\n// --- FUNCIÓN PARA POBLAR DATOS INICIALES (SEED) ---\r\nexport async function seedDatabase() {\r\n  // 1. Crear Cuentas por defecto\r\n  const acc1 = await prisma.account.create({\r\n    data: { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', balance: 0 }\r\n  });\r\n  \r\n  const acc2 = await prisma.account.create({\r\n    data: { name: 'Efectivo', bank: 'Bolsillo', type: 'cash', owner: 'Jhonattan', color: '#22c55e', balance: 0 }\r\n  });\r\n\r\n  // 2. Crear Categorías por defecto\r\n  await prisma.category.create({\r\n    data: { name: 'Efectivo', type: 'income', subCategories: JSON.stringify(['Retiro']) }\r\n  });\r\n\r\n  \r\n  \r\n  // 2. Categorías Básicas\r\n  const catCount = await prisma.category.count();\r\n  if (catCount === 0) {\r\n      await prisma.category.createMany({\r\n          data: [\r\n            { name: 'Efectivo', type: 'income', subCategories: JSON.stringify(['Retiro'])  }\r\n          ]\r\n      });\r\n  }\r\n  \r\n  // 3. Categoría Especial de Ahorro (Esta era la que fallaba)\r\n  // Usamos upsert: Si existe no hace nada (update vacío), si no existe, la crea.\r\n  await prisma.category.upsert({\r\n    where: { id: 'cat_sys_savings' },\r\n    update: {},\r\n    create: { id: 'cat_sys_savings', name: 'Ahorro Automático', type: 'income', subCategories: '[]' }\r\n  });\r\n\r\n  revalidatePath('/');\r\n  return { success: true };\r\n}"],"names":[],"mappings":";;;;;;;IAiKsB,oBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 94, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["// app/actions.ts\r\n\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// Evita instanciar múltiples clientes en desarrollo\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- LEER TODOS LOS DATOS ---\r\nexport async function getFinanceData() {\r\n  \r\n  const accounts = await prisma.account.findMany();\r\n  const categories = await prisma.category.findMany();\r\n  const transactions = await prisma.transaction.findMany({ orderBy: { date: 'desc' } });\r\n  const fixedRules = await prisma.fixedRule.findMany();\r\n  const simulatorItems = await prisma.simulatorItem.findMany();\r\n\r\n  // Convertimos datos complejos para que React los entienda (Fechas y JSON)\r\n  const parsedCategories = categories.map(c => ({\r\n    ...c,\r\n    subCategories: c.subCategories ? JSON.parse(c.subCategories) : []\r\n  }));\r\n\r\n  const parsedTransactions = transactions.map(t => ({\r\n    ...t,\r\n    date: t.date.toISOString(), // React prefiere strings para fechas\r\n    accountId: t.accountId,\r\n    categoryId: t.categoryId\r\n  }));\r\n\r\n  return {\r\n    accounts,\r\n    categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n    transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n    fixedRules,\r\n    simulatorItems\r\n  };\r\n}\r\n\r\n// --- CREAR TRANSACCIÓN INTELIGENTE ---\r\nexport async function createTransaction(data: any) {\r\n  const date = new Date(data.date);\r\n\r\n  // CASO 1: TRANSFERENCIA ENTRE CUENTAS\r\n  if (data.type === 'transfer') {\r\n      // 1. Salida (Gasto) de Cuenta A\r\n      await prisma.transaction.create({\r\n          data: {\r\n              type: 'expense',\r\n              amount: data.amount,\r\n              accountId: data.accountId, // Origen\r\n              description: `Transferencia a: ${data.destAccountName}`,\r\n              date: date,\r\n              isTransfer: true,\r\n              relatedAccountId: data.relatedAccountId, // Destino\r\n              didWithdraw: true\r\n          }\r\n      });\r\n      // Restar de Origen\r\n      await prisma.account.update({\r\n          where: { id: data.accountId },\r\n          data: { balance: { decrement: data.amount } }\r\n      });\r\n\r\n      // 2. Entrada (Ingreso) a Cuenta B\r\n      await prisma.transaction.create({\r\n          data: {\r\n              type: 'income',\r\n              amount: data.amount,\r\n              accountId: data.relatedAccountId, // Destino\r\n              description: `Recibido de: ${data.originAccountName}`,\r\n              date: date,\r\n              isTransfer: true,\r\n              relatedAccountId: data.accountId, // Origen\r\n              didWithdraw: false // Irrelevante en ingreso, pero por consistencia\r\n          }\r\n      });\r\n      // Sumar a Destino\r\n      await prisma.account.update({\r\n          where: { id: data.relatedAccountId },\r\n          data: { balance: { increment: data.amount } }\r\n      });\r\n  } \r\n  // CASO 2: MOVIMIENTO NORMAL (Ingreso / Gasto / Ahorro)\r\n  else {\r\n      // Si es \"Ahorro que NO se retira\", no descontamos saldo\r\n      const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n\r\n      await prisma.transaction.create({\r\n          data: {\r\n              type: data.type,\r\n              amount: data.amount,\r\n              budgetedAmount: data.budgetedAmount,\r\n              accountId: data.accountId,\r\n              categoryId: data.categoryId,\r\n              description: data.description,\r\n              date: date,\r\n              isFixed: data.isFixed || false,\r\n              isSavings: data.isSavings || false,\r\n              didWithdraw: data.didWithdraw ?? true\r\n          }\r\n      });\r\n\r\n      if (shouldUpdateBalance) {\r\n          const multiplier = data.type === 'income' ? 1 : -1;\r\n          await prisma.account.update({\r\n              where: { id: data.accountId },\r\n              data: { balance: { increment: data.amount * multiplier } }\r\n          });\r\n      }\r\n\r\n      // CASO ESPECIAL: Ahorro (se retire o no) -> Sumar a la \"Cartera de Ahorro\" virtual\r\n      // Buscamos o creamos una cuenta virtual de ahorro para llevar el registro\r\n      if (data.isSavings) {\r\n          // Buscamos una cuenta tipo 'savings_virtual'\r\n          let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual' } });\r\n          \r\n          if (!savingsAcc) {\r\n             savingsAcc = await prisma.account.create({\r\n                 data: { name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Todos', color: '#3b82f6' }\r\n             });\r\n          }\r\n\r\n          // Sumamos el valor a esa cuenta virtual (siempre suma, nunca resta)\r\n          await prisma.account.update({\r\n              where: { id: savingsAcc.id },\r\n              data: { balance: { increment: data.amount } }\r\n          });\r\n      }\r\n  }\r\n\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE CUENTAS ---\r\nexport async function createAccount(data: any) {\r\n  await prisma.account.create({ data });\r\n  revalidatePath('/');\r\n}\r\n\r\nexport async function deleteAccount(id: string) {\r\n  await prisma.account.delete({ where: { id } });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE CATEGORIAS ---\r\nexport async function createCategory(data: any) {\r\n  await prisma.category.create({\r\n    data: {\r\n        name: data.name,\r\n        type: data.type,\r\n        subCategories: JSON.stringify(data.subCategories || [])\r\n    }\r\n  });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE SIMULADOR ---\r\nexport async function saveSimulatorItem(data: any) {\r\n    // Si existe ID lo actualiza, si no, crea uno nuevo\r\n    const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } });\r\n    if (existing) {\r\n        await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } });\r\n    } else {\r\n        await prisma.simulatorItem.create({ data });\r\n    }\r\n    revalidatePath('/simulator');\r\n}\r\n\r\nexport async function deleteSimulatorItem(id: string) {\r\n    await prisma.simulatorItem.delete({ where: { id } });\r\n    revalidatePath('/simulator');\r\n}\r\n\r\n// --- REGLAS FIJAS ---\r\nexport async function createFixedRule(data: any) {\r\n    await prisma.fixedRule.create({ data });\r\n    revalidatePath('/');\r\n}\r\n\r\n// --- FUNCIÓN PARA POBLAR DATOS INICIALES (SEED) ---\r\nexport async function seedDatabase() {\r\n  // 1. Crear Cuentas por defecto\r\n  const acc1 = await prisma.account.create({\r\n    data: { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', balance: 0 }\r\n  });\r\n  \r\n  const acc2 = await prisma.account.create({\r\n    data: { name: 'Efectivo', bank: 'Bolsillo', type: 'cash', owner: 'Jhonattan', color: '#22c55e', balance: 0 }\r\n  });\r\n\r\n  // 2. Crear Categorías por defecto\r\n  await prisma.category.create({\r\n    data: { name: 'Efectivo', type: 'income', subCategories: JSON.stringify(['Retiro']) }\r\n  });\r\n\r\n  \r\n  \r\n  // 2. Categorías Básicas\r\n  const catCount = await prisma.category.count();\r\n  if (catCount === 0) {\r\n      await prisma.category.createMany({\r\n          data: [\r\n            { name: 'Efectivo', type: 'income', subCategories: JSON.stringify(['Retiro'])  }\r\n          ]\r\n      });\r\n  }\r\n  \r\n  // 3. Categoría Especial de Ahorro (Esta era la que fallaba)\r\n  // Usamos upsert: Si existe no hace nada (update vacío), si no existe, la crea.\r\n  await prisma.category.upsert({\r\n    where: { id: 'cat_sys_savings' },\r\n    update: {},\r\n    create: { id: 'cat_sys_savings', name: 'Ahorro Automático', type: 'income', subCategories: '[]' }\r\n  });\r\n\r\n  revalidatePath('/');\r\n  return { success: true };\r\n}"],"names":[],"mappings":";;;;;;;IA4KsB,sBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 109, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["// app/actions.ts\r\n\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// Evita instanciar múltiples clientes en desarrollo\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- LEER TODOS LOS DATOS ---\r\nexport async function getFinanceData() {\r\n  \r\n  const accounts = await prisma.account.findMany();\r\n  const categories = await prisma.category.findMany();\r\n  const transactions = await prisma.transaction.findMany({ orderBy: { date: 'desc' } });\r\n  const fixedRules = await prisma.fixedRule.findMany();\r\n  const simulatorItems = await prisma.simulatorItem.findMany();\r\n\r\n  // Convertimos datos complejos para que React los entienda (Fechas y JSON)\r\n  const parsedCategories = categories.map(c => ({\r\n    ...c,\r\n    subCategories: c.subCategories ? JSON.parse(c.subCategories) : []\r\n  }));\r\n\r\n  const parsedTransactions = transactions.map(t => ({\r\n    ...t,\r\n    date: t.date.toISOString(), // React prefiere strings para fechas\r\n    accountId: t.accountId,\r\n    categoryId: t.categoryId\r\n  }));\r\n\r\n  return {\r\n    accounts,\r\n    categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n    transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n    fixedRules,\r\n    simulatorItems\r\n  };\r\n}\r\n\r\n// --- CREAR TRANSACCIÓN INTELIGENTE ---\r\nexport async function createTransaction(data: any) {\r\n  const date = new Date(data.date);\r\n\r\n  // CASO 1: TRANSFERENCIA ENTRE CUENTAS\r\n  if (data.type === 'transfer') {\r\n      // 1. Salida (Gasto) de Cuenta A\r\n      await prisma.transaction.create({\r\n          data: {\r\n              type: 'expense',\r\n              amount: data.amount,\r\n              accountId: data.accountId, // Origen\r\n              description: `Transferencia a: ${data.destAccountName}`,\r\n              date: date,\r\n              isTransfer: true,\r\n              relatedAccountId: data.relatedAccountId, // Destino\r\n              didWithdraw: true\r\n          }\r\n      });\r\n      // Restar de Origen\r\n      await prisma.account.update({\r\n          where: { id: data.accountId },\r\n          data: { balance: { decrement: data.amount } }\r\n      });\r\n\r\n      // 2. Entrada (Ingreso) a Cuenta B\r\n      await prisma.transaction.create({\r\n          data: {\r\n              type: 'income',\r\n              amount: data.amount,\r\n              accountId: data.relatedAccountId, // Destino\r\n              description: `Recibido de: ${data.originAccountName}`,\r\n              date: date,\r\n              isTransfer: true,\r\n              relatedAccountId: data.accountId, // Origen\r\n              didWithdraw: false // Irrelevante en ingreso, pero por consistencia\r\n          }\r\n      });\r\n      // Sumar a Destino\r\n      await prisma.account.update({\r\n          where: { id: data.relatedAccountId },\r\n          data: { balance: { increment: data.amount } }\r\n      });\r\n  } \r\n  // CASO 2: MOVIMIENTO NORMAL (Ingreso / Gasto / Ahorro)\r\n  else {\r\n      // Si es \"Ahorro que NO se retira\", no descontamos saldo\r\n      const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n\r\n      await prisma.transaction.create({\r\n          data: {\r\n              type: data.type,\r\n              amount: data.amount,\r\n              budgetedAmount: data.budgetedAmount,\r\n              accountId: data.accountId,\r\n              categoryId: data.categoryId,\r\n              description: data.description,\r\n              date: date,\r\n              isFixed: data.isFixed || false,\r\n              isSavings: data.isSavings || false,\r\n              didWithdraw: data.didWithdraw ?? true\r\n          }\r\n      });\r\n\r\n      if (shouldUpdateBalance) {\r\n          const multiplier = data.type === 'income' ? 1 : -1;\r\n          await prisma.account.update({\r\n              where: { id: data.accountId },\r\n              data: { balance: { increment: data.amount * multiplier } }\r\n          });\r\n      }\r\n\r\n      // CASO ESPECIAL: Ahorro (se retire o no) -> Sumar a la \"Cartera de Ahorro\" virtual\r\n      // Buscamos o creamos una cuenta virtual de ahorro para llevar el registro\r\n      if (data.isSavings) {\r\n          // Buscamos una cuenta tipo 'savings_virtual'\r\n          let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual' } });\r\n          \r\n          if (!savingsAcc) {\r\n             savingsAcc = await prisma.account.create({\r\n                 data: { name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Todos', color: '#3b82f6' }\r\n             });\r\n          }\r\n\r\n          // Sumamos el valor a esa cuenta virtual (siempre suma, nunca resta)\r\n          await prisma.account.update({\r\n              where: { id: savingsAcc.id },\r\n              data: { balance: { increment: data.amount } }\r\n          });\r\n      }\r\n  }\r\n\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE CUENTAS ---\r\nexport async function createAccount(data: any) {\r\n  await prisma.account.create({ data });\r\n  revalidatePath('/');\r\n}\r\n\r\nexport async function deleteAccount(id: string) {\r\n  await prisma.account.delete({ where: { id } });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE CATEGORIAS ---\r\nexport async function createCategory(data: any) {\r\n  await prisma.category.create({\r\n    data: {\r\n        name: data.name,\r\n        type: data.type,\r\n        subCategories: JSON.stringify(data.subCategories || [])\r\n    }\r\n  });\r\n  revalidatePath('/');\r\n}\r\n\r\n// --- ACCIONES DE SIMULADOR ---\r\nexport async function saveSimulatorItem(data: any) {\r\n    // Si existe ID lo actualiza, si no, crea uno nuevo\r\n    const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } });\r\n    if (existing) {\r\n        await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } });\r\n    } else {\r\n        await prisma.simulatorItem.create({ data });\r\n    }\r\n    revalidatePath('/simulator');\r\n}\r\n\r\nexport async function deleteSimulatorItem(id: string) {\r\n    await prisma.simulatorItem.delete({ where: { id } });\r\n    revalidatePath('/simulator');\r\n}\r\n\r\n// --- REGLAS FIJAS ---\r\nexport async function createFixedRule(data: any) {\r\n    await prisma.fixedRule.create({ data });\r\n    revalidatePath('/');\r\n}\r\n\r\n// --- FUNCIÓN PARA POBLAR DATOS INICIALES (SEED) ---\r\nexport async function seedDatabase() {\r\n  // 1. Crear Cuentas por defecto\r\n  const acc1 = await prisma.account.create({\r\n    data: { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', balance: 0 }\r\n  });\r\n  \r\n  const acc2 = await prisma.account.create({\r\n    data: { name: 'Efectivo', bank: 'Bolsillo', type: 'cash', owner: 'Jhonattan', color: '#22c55e', balance: 0 }\r\n  });\r\n\r\n  // 2. Crear Categorías por defecto\r\n  await prisma.category.create({\r\n    data: { name: 'Efectivo', type: 'income', subCategories: JSON.stringify(['Retiro']) }\r\n  });\r\n\r\n  \r\n  \r\n  // 2. Categorías Básicas\r\n  const catCount = await prisma.category.count();\r\n  if (catCount === 0) {\r\n      await prisma.category.createMany({\r\n          data: [\r\n            { name: 'Efectivo', type: 'income', subCategories: JSON.stringify(['Retiro'])  }\r\n          ]\r\n      });\r\n  }\r\n  \r\n  // 3. Categoría Especial de Ahorro (Esta era la que fallaba)\r\n  // Usamos upsert: Si existe no hace nada (update vacío), si no existe, la crea.\r\n  await prisma.category.upsert({\r\n    where: { id: 'cat_sys_savings' },\r\n    update: {},\r\n    create: { id: 'cat_sys_savings', name: 'Ahorro Automático', type: 'income', subCategories: '[]' }\r\n  });\r\n\r\n  revalidatePath('/');\r\n  return { success: true };\r\n}"],"names":[],"mappings":";;;;;;;IAkLsB,kBAAA,WAAA,GAAA,IAAA,uSAAA,EAAA,8CAAA,4RAAA,EAAA,KAAA,GAAA,kSAAA,EAAA"}},
    {"offset": {"line": 124, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/context/FinanceContext.tsx"],"sourcesContent":["// context/FinanceContext.tsx\r\n\"use client\";\r\nimport React, { createContext, useContext, useEffect, useState } from 'react';\r\nimport { Account, Category, Transaction, FixedExpenseRule } from '@/types';\r\n// Importamos las acciones del servidor\r\nimport { getFinanceData, createTransaction, createAccount, deleteAccount, createCategory, saveSimulatorItem, deleteSimulatorItem, createFixedRule } from '@/app/actions';\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\n\r\ninterface SimulatorItem {\r\n    id: string;\r\n    name: string;\r\n    amount: number;\r\n    type: 'income' | 'expense' | 'transfer';\r\n    isFixed: boolean;\r\n}\r\n\r\ninterface FinanceContextType {\r\n  accounts: Account[];\r\n  transactions: Transaction[];\r\n  categories: Category[];\r\n  fixedRules: FixedExpenseRule[];\r\n  simulatorItems: SimulatorItem[];\r\n  \r\n  addTransaction: (t: any) => Promise<void>;\r\n  addAccount: (a: any) => Promise<void>;\r\n  deleteAccountAction: (id: string) => Promise<void>;\r\n  addCategory: (c: any) => Promise<void>;\r\n  addFixedRule: (r: any) => Promise<void>;\r\n  \r\n  // Simulador\r\n  addSimItem: (item: any) => Promise<void>;\r\n  removeSimItem: (id: string) => Promise<void>;\r\n  \r\n  // Placeholders para evitar errores en otros componentes viejos\r\n  updateTransaction: (t: any) => void;\r\n  deleteTransaction: (id: string) => void;\r\n  updateAccount: (a: any) => void;\r\n  deleteCategory: (id: string) => void;\r\n  addSubCategory: (id: string, sub: string) => void;\r\n  removeSubCategory: (id: string, sub: string) => void;\r\n  updateFixedRule: (r: any) => void;\r\n  deleteFixedRule: (id: string) => void;\r\n  markRuleAsPaid: (id: string, date: string) => void;\r\n}\r\n\r\nconst FinanceContext = createContext<FinanceContextType | undefined>(undefined);\r\n\r\nexport const FinanceProvider = ({ children }: { children: React.ReactNode }) => {\r\n  const [accounts, setAccounts] = useState<Account[]>([]);\r\n  const [transactions, setTransactions] = useState<Transaction[]>([]);\r\n  const [categories, setCategories] = useState<Category[]>([]);\r\n  const [fixedRules, setFixedRules] = useState<FixedExpenseRule[]>([]);\r\n  const [simulatorItems, setSimulatorItems] = useState<SimulatorItem[]>([]);\r\n\r\n  // 1. CARGAR DATOS REALES AL INICIO\r\n  useEffect(() => {\r\n    const initData = async () => {\r\n        try {\r\n            const data = await getFinanceData();\r\n            // @ts-ignore\r\n            setAccounts(data.accounts);\r\n            // @ts-ignore\r\n            setTransactions(data.transactions);\r\n            // @ts-ignore\r\n            setCategories(data.categories);\r\n            // @ts-ignore\r\n            setFixedRules(data.fixedRules);\r\n            // @ts-ignore\r\n            setSimulatorItems(data.simulatorItems);\r\n        } catch (e) {\r\n            console.error(\"Error cargando BDD:\", e);\r\n        }\r\n    };\r\n    initData();\r\n  }, []);\r\n\r\n  // 2. FUNCIONES CONECTADAS A LA DB\r\n\r\n  const addTransaction = async (t: any) => {\r\n    // 1. UI OPTIMISTA\r\n    const tempId = uuidv4();\r\n    const optimisticTx = { ...t, id: tempId };\r\n    setTransactions(prev => [optimisticTx, ...prev]);\r\n\r\n    // Actualizar Saldos Localmente (Instantáneo)\r\n    if (t.type === 'transfer') {\r\n        setAccounts(prev => prev.map(acc => {\r\n            if (acc.id === t.accountId) return { ...acc, balance: acc.balance - t.amount }; // Resta origen\r\n            if (acc.id === t.relatedAccountId) return { ...acc, balance: acc.balance + t.amount }; // Suma destino\r\n            return acc;\r\n        }));\r\n    } else {\r\n        // Ingreso o Gasto\r\n        // Si es Gasto de Ahorro y NO retira (didWithdraw = false), NO restamos.\r\n        const shouldUpdateBalance = t.type === 'expense' && t.isSavings ? t.didWithdraw : true;\r\n\r\n        if (shouldUpdateBalance) {\r\n            const multiplier = t.type === 'income' ? 1 : -1;\r\n            setAccounts(prev => prev.map(acc => {\r\n                if (acc.id === t.accountId) return { ...acc, balance: acc.balance + (t.amount * multiplier) };\r\n                return acc;\r\n            }));\r\n        }\r\n        \r\n        // Si es ahorro, actualizamos la cuenta virtual visualmente\r\n        if (t.isSavings) {\r\n             setAccounts(prev => {\r\n                 const hasVirtual = prev.some(a => a.type === 'savings_virtual');\r\n                 if (hasVirtual) {\r\n                     return prev.map(a => a.type === 'savings_virtual' ? { ...a, balance: a.balance + t.amount } : a);\r\n                 }\r\n                 // Si no existe visualmente aún, la DB la creará, aquí podríamos simularla pero es complejo\r\n                 return prev;\r\n             });\r\n        }\r\n    }\r\n\r\n    // 2. SERVER ACTION\r\n    await createTransaction(t);\r\n};\r\n\r\n  const addAccount = async (a: any) => {\r\n      setAccounts(prev => [...prev, a]);\r\n      await createAccount(a);\r\n  };\r\n\r\n  const deleteAccountAction = async (id: string) => {\r\n      setAccounts(prev => prev.filter(x => x.id !== id));\r\n      await deleteAccount(id);\r\n  };\r\n\r\n  const addCategory = async (c: any) => {\r\n      setCategories(prev => [...prev, c]);\r\n      await createCategory(c);\r\n  };\r\n\r\n  const addFixedRule = async (r: any) => {\r\n      setFixedRules(prev => [...prev, r]);\r\n      await createFixedRule(r);\r\n  };\r\n\r\n  const addSimItem = async (item: any) => {\r\n      setSimulatorItems(prev => {\r\n          const exists = prev.find(i => i.id === item.id);\r\n          if (exists) return prev.map(i => i.id === item.id ? item : i);\r\n          return [...prev, item];\r\n      });\r\n      await saveSimulatorItem(item);\r\n  };\r\n\r\n  const removeSimItem = async (id: string) => {\r\n      setSimulatorItems(prev => prev.filter(i => i.id !== id));\r\n      await deleteSimulatorItem(id);\r\n  };\r\n\r\n  return (\r\n    <FinanceContext.Provider value={{\r\n      accounts, transactions, categories, fixedRules, simulatorItems,\r\n      addTransaction, addAccount, deleteAccountAction, addCategory, addFixedRule,\r\n      addSimItem, removeSimItem,\r\n      // Funciones vacías por compatibilidad temporal\r\n      updateTransaction: () => {}, deleteTransaction: () => {}, updateAccount: () => {}, \r\n      deleteCategory: () => {}, addSubCategory: () => {}, removeSubCategory: () => {}, \r\n      updateFixedRule: () => {}, deleteFixedRule: () => {}, markRuleAsPaid: () => {}\r\n    }}>\r\n      {children}\r\n    </FinanceContext.Provider>\r\n  );\r\n};\r\n\r\nexport const useFinance = () => {\r\n    const context = useContext(FinanceContext);\r\n    if (!context) throw new Error(\"useFinance Error\");\r\n    return context;\r\n};"],"names":[],"mappings":"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"}},
    {"offset": {"line": 329, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/lib/utils.ts"],"sourcesContent":["import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,GAAG,GAAG,MAAoB;IACxC,OAAO,IAAA,8NAAO,EAAC,IAAA,qMAAI,EAAC;AACtB"}},
    {"offset": {"line": 347, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/components/dashboard/RealisticAccountCard.tsx"],"sourcesContent":["\"use client\";\r\nimport { useFinance } from '@/context/FinanceContext';\r\nimport { Account } from '@/types';\r\nimport { Wallet, Building2, Banknote, CreditCard, Lock } from 'lucide-react';\r\nimport { cn } from '@/lib/utils';\r\n\r\nexport default function RealisticAccountCard({ account }: { account: Account }) {\r\n  const { transactions } = useFinance();\r\n\r\n  // 1. Calcular cuánto de esta cuenta es \"Ahorro no retirado\"\r\n  // Buscamos transacciones que sean de esta cuenta, sean Ahorro y NO se hayan retirado (didWithdraw = false)\r\n  const savingsInAccount = transactions\r\n    .filter(t => t.accountId === account.id && t.isSavings && t.type === 'expense' && !t.didWithdraw)\r\n    .reduce((sum, t) => sum + t.amount, 0);\r\n\r\n  // 2. El \"Balance\" que viene de la BD ya incluye todo (porque decidimos no restarlo).\r\n  //    Así que el \"Disponible\" es el Total menos el Ahorro Reservado.\r\n  const totalBalance = account.balance;\r\n  const availableBalance = totalBalance - savingsInAccount;\r\n\r\n  const Icon = account.type === 'wallet' ? Wallet : \r\n               account.type === 'cash' ? Banknote : \r\n               account.type === 'bond' ? CreditCard : Building2;\r\n\r\n  const cardColor = account.color || '#52525b';\r\n\r\n  return (\r\n    <div \r\n        className=\"relative overflow-hidden rounded-xl p-4 bg-zinc-900 border border-zinc-800 shadow-md transition-all hover:scale-[1.02]\"\r\n        style={{ borderLeft: `4px solid ${cardColor}` }}\r\n    >\r\n      <div className=\"flex justify-between items-start mb-3\">\r\n        <div className=\"flex items-center gap-3\">\r\n            <div className=\"w-3 h-3 rounded-sm shadow-[0_0_10px_rgba(0,0,0,0.5)]\" style={{ backgroundColor: cardColor }} />\r\n            <div>\r\n                <h3 className=\"text-lg font-bold text-white leading-tight\">{account.name}</h3>\r\n                <p className=\"text-xs text-zinc-500 font-medium\">\r\n                    {account.bank} • <span className=\"text-zinc-400\">{account.owner}</span>\r\n                </p>\r\n            </div>\r\n        </div>\r\n        <Icon className=\"text-zinc-600 opacity-50\" size={20} />\r\n      </div>\r\n\r\n      <div className=\"space-y-2\">\r\n         {/* Ahorro Reservado (Solo si hay) */}\r\n         {savingsInAccount > 0 && (\r\n            <div className=\"flex justify-between items-center bg-blue-900/20 px-2 py-1 rounded border border-blue-900/30\">\r\n                <div className=\"flex items-center gap-1 text-blue-400 text-xs\">\r\n                    <Lock size={10} /> <span>Reservado Ahorro</span>\r\n                </div>\r\n                <span className=\"text-blue-300 text-xs font-mono font-bold\">${savingsInAccount.toLocaleString()}</span>\r\n            </div>\r\n         )}\r\n\r\n         <div className=\"flex justify-between items-end border-t border-zinc-800 pt-2 mt-2\">\r\n             <div className=\"text-left\">\r\n                <p className=\"text-[10px] text-zinc-500 uppercase tracking-wider\">Total Banco</p>\r\n                <p className=\"text-xs text-zinc-400 font-mono\">${totalBalance.toLocaleString()}</p>\r\n             </div>\r\n             <div className=\"text-right\">\r\n                <p className=\"text-[10px] text-zinc-400 uppercase tracking-wider font-bold\">Disponible Real</p>\r\n                <p className={cn(\r\n                    \"text-xl font-mono font-bold tracking-tight\",\r\n                    availableBalance >= 0 ? \"text-emerald-400\" : \"text-rose-400\"\r\n                )}>\r\n                    ${availableBalance.toLocaleString('es-CO')}\r\n                </p>\r\n             </div>\r\n         </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}"],"names":[],"mappings":";;;;;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAJA;;;;AAMe,SAAS,qBAAqB,EAAE,OAAO,EAAwB;;IAC5E,MAAM,EAAE,YAAY,EAAE,GAAG,IAAA,gMAAU;IAEnC,4DAA4D;IAC5D,2GAA2G;IAC3G,MAAM,mBAAmB,aACtB,MAAM,CAAC,CAAA,IAAK,EAAE,SAAS,KAAK,QAAQ,EAAE,IAAI,EAAE,SAAS,IAAI,EAAE,IAAI,KAAK,aAAa,CAAC,EAAE,WAAW,EAC/F,MAAM,CAAC,CAAC,KAAK,IAAM,MAAM,EAAE,MAAM,EAAE;IAEtC,qFAAqF;IACrF,oEAAoE;IACpE,MAAM,eAAe,QAAQ,OAAO;IACpC,MAAM,mBAAmB,eAAe;IAExC,MAAM,OAAO,QAAQ,IAAI,KAAK,WAAW,wQAAM,GAClC,QAAQ,IAAI,KAAK,SAAS,8QAAQ,GAClC,QAAQ,IAAI,KAAK,SAAS,wRAAU,GAAG,qRAAS;IAE7D,MAAM,YAAY,QAAQ,KAAK,IAAI;IAEnC,qBACE,kPAAC;QACG,WAAU;QACV,OAAO;YAAE,YAAY,CAAC,UAAU,EAAE,WAAW;QAAC;;0BAEhD,kPAAC;gBAAI,WAAU;;kCACb,kPAAC;wBAAI,WAAU;;0CACX,kPAAC;gCAAI,WAAU;gCAAuD,OAAO;oCAAE,iBAAiB;gCAAU;;;;;;0CAC1G,kPAAC;;kDACG,kPAAC;wCAAG,WAAU;kDAA8C,QAAQ,IAAI;;;;;;kDACxE,kPAAC;wCAAE,WAAU;;4CACR,QAAQ,IAAI;4CAAC;0DAAG,kPAAC;gDAAK,WAAU;0DAAiB,QAAQ,KAAK;;;;;;;;;;;;;;;;;;;;;;;;kCAI3E,kPAAC;wBAAK,WAAU;wBAA2B,MAAM;;;;;;;;;;;;0BAGnD,kPAAC;gBAAI,WAAU;;oBAEX,mBAAmB,mBACjB,kPAAC;wBAAI,WAAU;;0CACX,kPAAC;gCAAI,WAAU;;kDACX,kPAAC,kQAAI;wCAAC,MAAM;;;;;;oCAAM;kDAAC,kPAAC;kDAAK;;;;;;;;;;;;0CAE7B,kPAAC;gCAAK,WAAU;;oCAA4C;oCAAE,iBAAiB,cAAc;;;;;;;;;;;;;kCAIpG,kPAAC;wBAAI,WAAU;;0CACX,kPAAC;gCAAI,WAAU;;kDACZ,kPAAC;wCAAE,WAAU;kDAAqD;;;;;;kDAClE,kPAAC;wCAAE,WAAU;;4CAAkC;4CAAE,aAAa,cAAc;;;;;;;;;;;;;0CAE/E,kPAAC;gCAAI,WAAU;;kDACZ,kPAAC;wCAAE,WAAU;kDAA+D;;;;;;kDAC5E,kPAAC;wCAAE,WAAW,IAAA,0KAAE,EACZ,8CACA,oBAAoB,IAAI,qBAAqB;;4CAC9C;4CACG,iBAAiB,cAAc,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOtD;GAnEwB;;QACG,gMAAU;;;KADb"}},
    {"offset": {"line": 594, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/components/ui/button.tsx"],"sourcesContent":["import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-primary text-primary-foreground hover:bg-primary/90\",\n        destructive:\n          \"bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60\",\n        outline:\n          \"border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50\",\n        secondary:\n          \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        ghost:\n          \"hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-9 px-4 py-2 has-[>svg]:px-3\",\n        sm: \"h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5\",\n        lg: \"h-10 rounded-md px-6 has-[>svg]:px-4\",\n        icon: \"size-9\",\n        \"icon-sm\": \"size-8\",\n        \"icon-lg\": \"size-10\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nfunction Button({\n  className,\n  variant = \"default\",\n  size = \"default\",\n  asChild = false,\n  ...props\n}: React.ComponentProps<\"button\"> &\n  VariantProps<typeof buttonVariants> & {\n    asChild?: boolean\n  }) {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      data-slot=\"button\"\n      data-variant={variant}\n      data-size={size}\n      className={cn(buttonVariants({ variant, size, className }))}\n      {...props}\n    />\n  )\n}\n\nexport { Button, buttonVariants }\n"],"names":[],"mappings":";;;;;;;AACA;AACA;AAEA;;;;;AAEA,MAAM,iBAAiB,IAAA,+NAAG,EACxB,+bACA;IACE,UAAU;QACR,SAAS;YACP,SAAS;YACT,aACE;YACF,SACE;YACF,WACE;YACF,OACE;YACF,MAAM;QACR;QACA,MAAM;YACJ,SAAS;YACT,IAAI;YACJ,IAAI;YACJ,MAAM;YACN,WAAW;YACX,WAAW;QACb;IACF;IACA,iBAAiB;QACf,SAAS;QACT,MAAM;IACR;AACF;AAGF,SAAS,OAAO,EACd,SAAS,EACT,UAAU,SAAS,EACnB,OAAO,SAAS,EAChB,UAAU,KAAK,EACf,GAAG,OAIF;IACD,MAAM,OAAO,UAAU,gOAAI,GAAG;IAE9B,qBACE,kPAAC;QACC,aAAU;QACV,gBAAc;QACd,aAAW;QACX,WAAW,IAAA,0KAAE,EAAC,eAAe;YAAE;YAAS;YAAM;QAAU;QACvD,GAAG,KAAK;;;;;;AAGf;KArBS"}},
    {"offset": {"line": 661, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/components/dashboard/AccountsSidebar.tsx"],"sourcesContent":["// components/dashboard/AccountsSidebar.tsx\r\n\"use client\";\r\nimport { useState } from 'react';\r\nimport { useFinance } from '@/context/FinanceContext';\r\nimport RealisticAccountCard from './RealisticAccountCard';\r\nimport { Button } from '@/components/ui/button';\r\nimport { ChevronRight, Wallet, Home, Calculator, Settings } from 'lucide-react';\r\nimport Link from 'next/link'; \r\nimport { cn } from '@/lib/utils';\r\nimport { usePathname } from 'next/navigation'; \r\n\r\ninterface Props {\r\n    className?: string;\r\n}\r\n\r\nexport default function AccountsSidebar({ className }: Props) {\r\n  const { accounts, transactions } = useFinance();\r\n  const [isOpen, setIsOpen] = useState(false);\r\n  const visibleAccounts = accounts.filter(a => !a.isHidden);\r\n  const totalBalance = visibleAccounts.reduce((sum, acc) => sum + acc.balance, 0);\r\n  \r\n  const pathname = usePathname();\r\n\r\n  const navClass = (path: string) => cn(\r\n      \"flex items-center gap-3 p-3 rounded-lg transition-colors font-medium text-sm\",\r\n      pathname === path ? \"bg-indigo-900/50 text-indigo-400\" : \"text-zinc-400 hover:bg-zinc-900 hover:text-zinc-100\"\r\n  );\r\n\r\n  // 1. Calcular Ahorro Total \"Reservado\" (dinero que está en cuentas pero es ahorro)\r\n  const totalReservedSavings = transactions\r\n      .filter(t => t.isSavings && t.type === 'expense' && !t.didWithdraw)\r\n      .reduce((sum, t) => sum + t.amount, 0);\r\n\r\n  // 2. Totales\r\n  const totalPatrimony = visibleAccounts.reduce((sum, acc) => sum + acc.balance, 0);\r\n  const totalAvailable = totalPatrimony - totalReservedSavings;\r\n\r\n  return (\r\n    <>\r\n      <Button \r\n        variant=\"default\" size=\"icon\" onClick={() => setIsOpen(!isOpen)}\r\n        className={cn(\r\n            \"fixed top-24 right-0 z-50 rounded-l-xl rounded-r-none shadow-xl transition-all duration-300 bg-indigo-600 w-8 h-12 md:hidden\", \r\n            isOpen ? \"mr-[320px]\" : \"mr-0\"\r\n        )}\r\n      >\r\n        {isOpen ? <ChevronRight /> : <Wallet className=\"h-4 w-4\" />}\r\n      </Button>\r\n\r\n      {isOpen && <div className=\"fixed inset-0 bg-black/50 z-40 md:hidden\" onClick={() => setIsOpen(false)} />}\r\n\r\n      <aside className={cn(\r\n          \"fixed top-0 bottom-0 right-0 z-50 w-[320px] bg-zinc-950 border-l border-zinc-800 shadow-2xl transition-transform duration-300 ease-in-out flex flex-col\",\r\n          isOpen ? \"translate-x-0\" : \"translate-x-full md:translate-x-0\", // Siempre visible en Desktop\r\n          className \r\n      )}>\r\n        \r\n        {/* NAVEGACIÓN DESKTOP Y MOBILE */}\r\n        <div className=\"p-4 border-b border-zinc-900 bg-zinc-950\">\r\n            <h2 className=\"text-xs font-bold text-zinc-600 uppercase tracking-widest mb-2 px-2\">Menú</h2>\r\n            <nav className=\"space-y-1\">\r\n                <Link href=\"/\" className={navClass('/')}>\r\n                    <Home size={18} /> Resumen General\r\n                </Link>\r\n                <Link href=\"/simulator\" className={navClass('/simulator')}>\r\n                    <Calculator size={18} /> Simulador Mensual\r\n                </Link>\r\n                <Link href=\"/admin\" className={navClass('/admin')}>\r\n                    <Settings size={18} /> Configuración\r\n                </Link>\r\n            </nav>\r\n        </div>\r\n\r\n        <div className=\"mt-4 p-4 bg-zinc-900/50 rounded-xl border border-zinc-800/50\">\r\n            <div className=\"flex justify-between items-center mb-2 border-b border-zinc-800 pb-2\">\r\n                <span className=\"text-[10px] text-zinc-500 uppercase\">Patrimonio Total</span>\r\n                <span className=\"text-xs text-zinc-400 font-mono\">${totalPatrimony.toLocaleString()}</span>\r\n            </div>\r\n            <div className=\"text-center\">\r\n                <p className=\"text-[10px] text-zinc-400 uppercase tracking-widest font-bold\">Disponible para Gastar</p>\r\n                <p className={cn(\"text-2xl font-extrabold mt-1\", totalAvailable >= 0 ? \"text-emerald-400\" : \"text-rose-400\")}>\r\n                    ${totalAvailable.toLocaleString('es-CO')}\r\n                </p>\r\n            </div>\r\n            {totalReservedSavings > 0 && (\r\n                <div className=\"mt-2 text-center bg-blue-900/20 rounded py-1 border border-blue-900/30\">\r\n                    <p className=\"text-[10px] text-blue-400\">💰 Ahorro Intocable: <span className=\"font-bold\">${totalReservedSavings.toLocaleString()}</span></p>\r\n                </div>\r\n            )}\r\n        </div>\r\n\r\n        <div className=\"flex-1 overflow-y-auto p-4 space-y-3 pb-20 scrollbar-thin scrollbar-thumb-zinc-800\">\r\n          {visibleAccounts.length === 0 && <p className=\"text-center text-xs text-zinc-600 mt-10\">No hay cuentas creadas aún.</p>}\r\n          {visibleAccounts.map(acc => (\r\n            <RealisticAccountCard key={acc.id} account={acc} />\r\n          ))}\r\n        </div>\r\n      </aside>\r\n    </>\r\n  );\r\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 959, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/components/ui/sonner.tsx"],"sourcesContent":["\"use client\"\n\nimport {\n  CircleCheckIcon,\n  InfoIcon,\n  Loader2Icon,\n  OctagonXIcon,\n  TriangleAlertIcon,\n} from \"lucide-react\"\nimport { useTheme } from \"next-themes\"\nimport { Toaster as Sonner, type ToasterProps } from \"sonner\"\n\nconst Toaster = ({ ...props }: ToasterProps) => {\n  const { theme = \"system\" } = useTheme()\n\n  return (\n    <Sonner\n      theme={theme as ToasterProps[\"theme\"]}\n      className=\"toaster group\"\n      icons={{\n        success: <CircleCheckIcon className=\"size-4\" />,\n        info: <InfoIcon className=\"size-4\" />,\n        warning: <TriangleAlertIcon className=\"size-4\" />,\n        error: <OctagonXIcon className=\"size-4\" />,\n        loading: <Loader2Icon className=\"size-4 animate-spin\" />,\n      }}\n      style={\n        {\n          \"--normal-bg\": \"var(--popover)\",\n          \"--normal-text\": \"var(--popover-foreground)\",\n          \"--normal-border\": \"var(--border)\",\n          \"--border-radius\": \"var(--radius)\",\n        } as React.CSSProperties\n      }\n      {...props}\n    />\n  )\n}\n\nexport { Toaster }\n"],"names":[],"mappings":";;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAOA;AACA;;;AAVA;;;;AAYA,MAAM,UAAU,CAAC,EAAE,GAAG,OAAqB;;IACzC,MAAM,EAAE,QAAQ,QAAQ,EAAE,GAAG,IAAA,oNAAQ;IAErC,qBACE,kPAAC,2MAAM;QACL,OAAO;QACP,WAAU;QACV,OAAO;YACL,uBAAS,kPAAC,mSAAe;gBAAC,WAAU;;;;;;YACpC,oBAAM,kPAAC,0QAAQ;gBAAC,WAAU;;;;;;YAC1B,uBAAS,kPAAC,ySAAiB;gBAAC,WAAU;;;;;;YACtC,qBAAO,kPAAC,0RAAY;gBAAC,WAAU;;;;;;YAC/B,uBAAS,kPAAC,4RAAW;gBAAC,WAAU;;;;;;QAClC;QACA,OACE;YACE,eAAe;YACf,iBAAiB;YACjB,mBAAmB;YACnB,mBAAmB;QACrB;QAED,GAAG,KAAK;;;;;;AAGf;GAzBM;;QACyB,oNAAQ;;;KADjC"}}]
}