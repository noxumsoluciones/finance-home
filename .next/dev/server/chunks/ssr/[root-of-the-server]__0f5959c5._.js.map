{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 28, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\n\r\n// --- GLOBAL PRISMA ---\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    \r\n    // 1. Verificar firma del token\r\n    const payload = await verifyToken(token);\r\n    if (!payload) return null;\r\n    try {\r\n        const user = await prisma.user.findUnique({ \r\n            where: { id: payload.id as string } \r\n        });\r\n        // Si no se encuentra el usuario en BD, retornamos null (inválido)\r\n        return user; \r\n    } catch (error) {\r\n        console.log(error );\r\n        return null;\r\n    }\r\n\r\n    //return await verifyToken(token);\r\n}\r\n\r\n// --- CREAR USUARIO (Para el botón Admin) ---\r\nexport async function createNewUser(name: string, email: string, householdId: string) {\r\n    const currentUser = await getCurrentUser();\r\n    \r\n    // Validación de seguridad básica: Solo User Master puede crear usuarios\r\n    if (currentUser?.email !== process.env.GMAIL_USER) {\r\n        return { success: false, message: 'No autorizado' };\r\n    }\r\n\r\n    try {\r\n        const existing = await prisma.user.findUnique({ where: { email } });\r\n        if (existing) return { success: false, message: 'El usuario ya existe.' };\r\n        \r\n        const existinHouseHold = await prisma.user.findMany({ where: { householdId } });\r\n        console.log(\"existinHouseHold \", existinHouseHold);\r\n        if (!existinHouseHold){\r\n            await prisma.account.createMany({\r\n                data: [\r\n                    { name: 'Dinero Efectivo', bank: 'Efectivo', type: 'wallet', owner: name, color: '#25ab28ff', householdId: householdId },\r\n                    { name: 'Ahorro Global', bank: 'Ahorro', type: 'savings_virtual', owner: name, color: '#fba300ff', householdId: householdId } \r\n                ]\r\n            });    \r\n        } \r\n        \r\n        await prisma.user.create({\r\n            data: {\r\n                email,\r\n                name,\r\n                householdId,\r\n                token: 'INIT', // Token inicial placeholder\r\n              }\r\n          });\r\n        \r\n        revalidatePath('/admin');\r\n        return { success: true, message: 'Usuario creado exitosamente.' };\r\n    } catch (error) {\r\n        return { success: false, message: 'Error creando usuario en BD.' };\r\n    }\r\n    \r\n}\r\n\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@?!+_\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n    \r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    \r\n    if (!user || !user.token) return { success: false, message: 'Código incorrecto.' };\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO (SOLICITUD) ---\r\nexport async function requestRegistration(email: string, name: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        // Enviamos nombre, email y familia al correo\r\n        await sendRegistrationRequestEmail(email, name, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. Establecer cookie de Demo (Importante: path '/')\r\n    cookieStore.set('is_demo_mode', 'true', { \r\n        path: '/',\r\n        httpOnly: true,\r\n        maxAge: 60 * 60 * 24 // 1 día\r\n    });\r\n    \r\n    // 2. Borrar token anterior si existe para evitar conflictos\r\n    cookieStore.delete('auth_token');\r\n    \r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n\r\n    // --- DEMO DATA ---\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' },\r\n            unauthorized: false\r\n        };\r\n    }\r\n\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; \r\n    }\r\n\r\n    // --- USER DATA ---\r\n    const householdId = user.householdId; \r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({\r\n        where: { householdId },\r\n        // NO poner aquí un filtro solo para 'expense'. \r\n        // Si tienes filtros de tipo, deben incluir 'income' para que se vea la entrada de la transferencia.\r\n        orderBy: { date: 'desc' },\r\n        include: { \r\n            account: { select: { name: true, color: true } },\r\n            category: { select: { name: true } }\r\n        }\r\n    });\r\n\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user,\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES Y UPDATES TRANSACTIONS ---\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n    // 1. TRANSFERENCIA: CREA DOS MOVIMIENTOS\r\n    if (data.type === 'transfer') {\r\n        // Buscar/Crear categoría\r\n        let transferCat = await prisma.category.findFirst({ where: { householdId, name: 'Transferencia Propia' } });\r\n        if (!transferCat) {\r\n            transferCat = await prisma.category.create({ data: { householdId, name: 'Transferencia Propia', type: 'transfer', subCategories: JSON.stringify([]) } });\r\n        }\r\n\r\n        // A. SALIDA (Gasto - Cuenta Origen)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'expense', amount: data.amount, \r\n                accountId: data.accountId, \r\n                categoryId: transferCat.id, \r\n                description: `Transferencia a: ${data.destAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        // B. ENTRADA (Ingreso - Cuenta Destino)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'income', amount: data.amount, \r\n                accountId: data.relatedAccountId, \r\n                categoryId: transferCat.id, \r\n                description: `Recibido de: ${data.originAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } \r\n    \r\n    // 2. GASTO / INGRESO NORMAL\r\n    else {\r\n\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        \r\n        // --- GASTO NORMAL ---\r\n        await prisma.transaction.create({\r\n            data: { \r\n                householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount,\r\n                accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, \r\n                isFixed: data.isFixed || false, \r\n                isSavings: data.isSavings || false, \r\n                payWithSavings: data.payWithSavings || false,\r\n                didWithdraw: data.payWithSavings ? true : (data.didWithdraw ?? true)\r\n            }\r\n        });\r\n\r\n        /*if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }*/\r\n\r\n\r\n        \r\n        // --- LÓGICA DE SALDOS ---\r\n\r\n        // A. CASO \"GASTAR DE AHORRO\" (Expense + payWithSavings)\r\n        if (data.payWithSavings && data.type === 'expense') {\r\n            // Restamos del balance total Y del balanceSafe de la cuenta\r\n            await prisma.account.update({ \r\n                where: { id: data.accountId }, \r\n                data: { \r\n                    balance: { decrement: data.amount },\r\n                    balanceSafe: { decrement: data.amount } \r\n                } \r\n            });\r\n            // Restamos también del Ahorro Global (Cuenta Virtual)\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) {\r\n                await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n            }\r\n        }\r\n        \r\n        // B. CASO \"ES AHORRO\" (Guardar dinero)\r\n        else if (data.isSavings) {\r\n             // 1. Si es INGRESO y es ahorro: Sube Balance Total y Sube BalanceSafe\r\n             if (data.type === 'income') {\r\n                await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        balance: { increment: data.amount },\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });\r\n                let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             \r\n             } \r\n             // 2. Si es GASTO (Sacar del bolsillo diario para guardar): El balance total NO cambia (el dinero sigue en la cuenta), pero sube el BalanceSafe\r\n             // NOTA: Si el usuario quiere que \"salga\" de la cuenta, debería usar Transferencia. Asumimos que \"Gasto -> Es Ahorro\" es apartar dinero.\r\n             else if (data.type === 'expense') {\r\n                 /*await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        // No tocamos balance total porque el dinero no se ha ido del banco, solo cambió de \"estado\"\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });*/\r\n                // ---> NUEVA LÓGICA: RETIRO FÍSICO PARA AHORRO <---\r\n                 if (data.didWithdraw) {\r\n                     // a. Restamos de la cuenta origen (Banco)\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balance: { decrement: data.amount } } // Solo decrementa balance total, no balanceSafe, porque salió del banco\r\n                    });\r\n\r\n                    // b. Buscamos (o creamos) la cuenta \"Dinero Efectivo\"\r\n                    let cashAccount = await prisma.account.findFirst({ \r\n                        where: { householdId, name: 'Dinero Efectivo' } // Buscamos por nombre o tipo 'wallet'\r\n                    });\r\n\r\n                    if (!cashAccount) {\r\n                        cashAccount = await prisma.account.create({\r\n                            data: {\r\n                                householdId,\r\n                                name: 'Dinero Efectivo',\r\n                                bank: 'Efectivo',\r\n                                type: 'wallet',\r\n                                color: '#10b981',\r\n                                owner: 'Casa'\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    // c. Sumamos a \"Dinero Efectivo\" como Ahorro (BalanceSafe)\r\n                    // Aquí el dinero entra físicamente y se marca como reservado\r\n                    await prisma.account.update({\r\n                        where: { id: cashAccount.id },\r\n                        data: {\r\n                            balance: { increment: data.amount },\r\n                            balanceSafe: { increment: data.amount }\r\n                        }\r\n                    });\r\n\r\n                 } else {\r\n                     // ---> LÓGICA ANTIGUA: AHORRO VIRTUAL (No sale del banco) <---\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balanceSafe: { increment: data.amount } } \r\n                    });\r\n                 }\r\n\r\n                 // En AMBOS casos, el \"Ahorro Global\" (Espejo) aumenta\r\n                 let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                 if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n                 await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             }\r\n\r\n             \r\n        }\r\n\r\n        // C. CASO NORMAL (Gasto corriente o Ingreso corriente)\r\n        else {\r\n            const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n            if (shouldUpdateBalance) {\r\n                const multiplier = data.type === 'income' ? 1 : -1;\r\n                await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n            }\r\n        }\r\n\r\n        // Reglas Fijas y Crédito (Igual que antes)\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { householdId, description: data.description, categoryId: data.categoryId, budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || date.getDate(), isActive: true }\r\n            });\r\n        }\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');\r\n\r\n\r\n        // Lógica de Ahorro Global (Sumar o Restar)\r\n\r\n        /*\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n        if (data.payWithSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n        }\r\n\r\n        // Regla Fija\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { \r\n                    householdId, \r\n                    description: data.description, \r\n                    categoryId: data.categoryId, \r\n                    \r\n                    budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, \r\n                    accountIdToCharge: data.accountId, \r\n                    dayOfMonth: data.dayOfMonth || date.getDate(), \r\n                    isActive: true }\r\n            });\r\n        }\r\n\r\n\r\n        // --- CRÉDITO AUTOMÁTICO ---\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');*/\r\n}\r\n\r\n// Funciones CRUD estándar\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { id: data.id, name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, \r\n            description: data.description,\r\n            categoryId: data.categoryId,\r\n            accountIdToCharge: data.accountIdToCharge,\r\n            dayOfMonth: parseInt(data.dayOfMonth),householdId: user.householdId,budgetedAmount: parseFloat(data.budgetedAmount || '0'), staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null, isActive: true } }); revalidatePath('/admin'); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, \r\n            // Actualizamos ambos\r\n            //staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null,\r\n            budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId, name: 'Jhonattan' },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId, name: 'Jhonattan' }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId, name: 'Thannia' },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId, name: 'Thannia' }\r\n    });\r\n\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;IAwKsB,iBAAA,WAAA,GAAA,IAAA,oSAAA,EAAA,8CAAA,yRAAA,EAAA,KAAA,GAAA,+RAAA,EAAA"}},
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\n\r\n// --- GLOBAL PRISMA ---\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    \r\n    // 1. Verificar firma del token\r\n    const payload = await verifyToken(token);\r\n    if (!payload) return null;\r\n    try {\r\n        const user = await prisma.user.findUnique({ \r\n            where: { id: payload.id as string } \r\n        });\r\n        // Si no se encuentra el usuario en BD, retornamos null (inválido)\r\n        return user; \r\n    } catch (error) {\r\n        console.log(error );\r\n        return null;\r\n    }\r\n\r\n    //return await verifyToken(token);\r\n}\r\n\r\n// --- CREAR USUARIO (Para el botón Admin) ---\r\nexport async function createNewUser(name: string, email: string, householdId: string) {\r\n    const currentUser = await getCurrentUser();\r\n    \r\n    // Validación de seguridad básica: Solo User Master puede crear usuarios\r\n    if (currentUser?.email !== process.env.GMAIL_USER) {\r\n        return { success: false, message: 'No autorizado' };\r\n    }\r\n\r\n    try {\r\n        const existing = await prisma.user.findUnique({ where: { email } });\r\n        if (existing) return { success: false, message: 'El usuario ya existe.' };\r\n        \r\n        const existinHouseHold = await prisma.user.findMany({ where: { householdId } });\r\n        console.log(\"existinHouseHold \", existinHouseHold);\r\n        if (!existinHouseHold){\r\n            await prisma.account.createMany({\r\n                data: [\r\n                    { name: 'Dinero Efectivo', bank: 'Efectivo', type: 'wallet', owner: name, color: '#25ab28ff', householdId: householdId },\r\n                    { name: 'Ahorro Global', bank: 'Ahorro', type: 'savings_virtual', owner: name, color: '#fba300ff', householdId: householdId } \r\n                ]\r\n            });    \r\n        } \r\n        \r\n        await prisma.user.create({\r\n            data: {\r\n                email,\r\n                name,\r\n                householdId,\r\n                token: 'INIT', // Token inicial placeholder\r\n              }\r\n          });\r\n        \r\n        revalidatePath('/admin');\r\n        return { success: true, message: 'Usuario creado exitosamente.' };\r\n    } catch (error) {\r\n        return { success: false, message: 'Error creando usuario en BD.' };\r\n    }\r\n    \r\n}\r\n\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@?!+_\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n    \r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    \r\n    if (!user || !user.token) return { success: false, message: 'Código incorrecto.' };\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO (SOLICITUD) ---\r\nexport async function requestRegistration(email: string, name: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        // Enviamos nombre, email y familia al correo\r\n        await sendRegistrationRequestEmail(email, name, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. Establecer cookie de Demo (Importante: path '/')\r\n    cookieStore.set('is_demo_mode', 'true', { \r\n        path: '/',\r\n        httpOnly: true,\r\n        maxAge: 60 * 60 * 24 // 1 día\r\n    });\r\n    \r\n    // 2. Borrar token anterior si existe para evitar conflictos\r\n    cookieStore.delete('auth_token');\r\n    \r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n\r\n    // --- DEMO DATA ---\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' },\r\n            unauthorized: false\r\n        };\r\n    }\r\n\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; \r\n    }\r\n\r\n    // --- USER DATA ---\r\n    const householdId = user.householdId; \r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({\r\n        where: { householdId },\r\n        // NO poner aquí un filtro solo para 'expense'. \r\n        // Si tienes filtros de tipo, deben incluir 'income' para que se vea la entrada de la transferencia.\r\n        orderBy: { date: 'desc' },\r\n        include: { \r\n            account: { select: { name: true, color: true } },\r\n            category: { select: { name: true } }\r\n        }\r\n    });\r\n\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user,\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES Y UPDATES TRANSACTIONS ---\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n    // 1. TRANSFERENCIA: CREA DOS MOVIMIENTOS\r\n    if (data.type === 'transfer') {\r\n        // Buscar/Crear categoría\r\n        let transferCat = await prisma.category.findFirst({ where: { householdId, name: 'Transferencia Propia' } });\r\n        if (!transferCat) {\r\n            transferCat = await prisma.category.create({ data: { householdId, name: 'Transferencia Propia', type: 'transfer', subCategories: JSON.stringify([]) } });\r\n        }\r\n\r\n        // A. SALIDA (Gasto - Cuenta Origen)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'expense', amount: data.amount, \r\n                accountId: data.accountId, \r\n                categoryId: transferCat.id, \r\n                description: `Transferencia a: ${data.destAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        // B. ENTRADA (Ingreso - Cuenta Destino)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'income', amount: data.amount, \r\n                accountId: data.relatedAccountId, \r\n                categoryId: transferCat.id, \r\n                description: `Recibido de: ${data.originAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } \r\n    \r\n    // 2. GASTO / INGRESO NORMAL\r\n    else {\r\n\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        \r\n        // --- GASTO NORMAL ---\r\n        await prisma.transaction.create({\r\n            data: { \r\n                householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount,\r\n                accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, \r\n                isFixed: data.isFixed || false, \r\n                isSavings: data.isSavings || false, \r\n                payWithSavings: data.payWithSavings || false,\r\n                didWithdraw: data.payWithSavings ? true : (data.didWithdraw ?? true)\r\n            }\r\n        });\r\n\r\n        /*if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }*/\r\n\r\n\r\n        \r\n        // --- LÓGICA DE SALDOS ---\r\n\r\n        // A. CASO \"GASTAR DE AHORRO\" (Expense + payWithSavings)\r\n        if (data.payWithSavings && data.type === 'expense') {\r\n            // Restamos del balance total Y del balanceSafe de la cuenta\r\n            await prisma.account.update({ \r\n                where: { id: data.accountId }, \r\n                data: { \r\n                    balance: { decrement: data.amount },\r\n                    balanceSafe: { decrement: data.amount } \r\n                } \r\n            });\r\n            // Restamos también del Ahorro Global (Cuenta Virtual)\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) {\r\n                await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n            }\r\n        }\r\n        \r\n        // B. CASO \"ES AHORRO\" (Guardar dinero)\r\n        else if (data.isSavings) {\r\n             // 1. Si es INGRESO y es ahorro: Sube Balance Total y Sube BalanceSafe\r\n             if (data.type === 'income') {\r\n                await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        balance: { increment: data.amount },\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });\r\n                let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             \r\n             } \r\n             // 2. Si es GASTO (Sacar del bolsillo diario para guardar): El balance total NO cambia (el dinero sigue en la cuenta), pero sube el BalanceSafe\r\n             // NOTA: Si el usuario quiere que \"salga\" de la cuenta, debería usar Transferencia. Asumimos que \"Gasto -> Es Ahorro\" es apartar dinero.\r\n             else if (data.type === 'expense') {\r\n                 /*await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        // No tocamos balance total porque el dinero no se ha ido del banco, solo cambió de \"estado\"\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });*/\r\n                // ---> NUEVA LÓGICA: RETIRO FÍSICO PARA AHORRO <---\r\n                 if (data.didWithdraw) {\r\n                     // a. Restamos de la cuenta origen (Banco)\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balance: { decrement: data.amount } } // Solo decrementa balance total, no balanceSafe, porque salió del banco\r\n                    });\r\n\r\n                    // b. Buscamos (o creamos) la cuenta \"Dinero Efectivo\"\r\n                    let cashAccount = await prisma.account.findFirst({ \r\n                        where: { householdId, name: 'Dinero Efectivo' } // Buscamos por nombre o tipo 'wallet'\r\n                    });\r\n\r\n                    if (!cashAccount) {\r\n                        cashAccount = await prisma.account.create({\r\n                            data: {\r\n                                householdId,\r\n                                name: 'Dinero Efectivo',\r\n                                bank: 'Efectivo',\r\n                                type: 'wallet',\r\n                                color: '#10b981',\r\n                                owner: 'Casa'\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    // c. Sumamos a \"Dinero Efectivo\" como Ahorro (BalanceSafe)\r\n                    // Aquí el dinero entra físicamente y se marca como reservado\r\n                    await prisma.account.update({\r\n                        where: { id: cashAccount.id },\r\n                        data: {\r\n                            balance: { increment: data.amount },\r\n                            balanceSafe: { increment: data.amount }\r\n                        }\r\n                    });\r\n\r\n                 } else {\r\n                     // ---> LÓGICA ANTIGUA: AHORRO VIRTUAL (No sale del banco) <---\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balanceSafe: { increment: data.amount } } \r\n                    });\r\n                 }\r\n\r\n                 // En AMBOS casos, el \"Ahorro Global\" (Espejo) aumenta\r\n                 let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                 if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n                 await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             }\r\n\r\n             \r\n        }\r\n\r\n        // C. CASO NORMAL (Gasto corriente o Ingreso corriente)\r\n        else {\r\n            const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n            if (shouldUpdateBalance) {\r\n                const multiplier = data.type === 'income' ? 1 : -1;\r\n                await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n            }\r\n        }\r\n\r\n        // Reglas Fijas y Crédito (Igual que antes)\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { householdId, description: data.description, categoryId: data.categoryId, budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || date.getDate(), isActive: true }\r\n            });\r\n        }\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');\r\n\r\n\r\n        // Lógica de Ahorro Global (Sumar o Restar)\r\n\r\n        /*\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n        if (data.payWithSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n        }\r\n\r\n        // Regla Fija\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { \r\n                    householdId, \r\n                    description: data.description, \r\n                    categoryId: data.categoryId, \r\n                    \r\n                    budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, \r\n                    accountIdToCharge: data.accountId, \r\n                    dayOfMonth: data.dayOfMonth || date.getDate(), \r\n                    isActive: true }\r\n            });\r\n        }\r\n\r\n\r\n        // --- CRÉDITO AUTOMÁTICO ---\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');*/\r\n}\r\n\r\n// Funciones CRUD estándar\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { id: data.id, name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, \r\n            description: data.description,\r\n            categoryId: data.categoryId,\r\n            accountIdToCharge: data.accountIdToCharge,\r\n            dayOfMonth: parseInt(data.dayOfMonth),householdId: user.householdId,budgetedAmount: parseFloat(data.budgetedAmount || '0'), staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null, isActive: true } }); revalidatePath('/admin'); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, \r\n            // Actualizamos ambos\r\n            //staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null,\r\n            budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId, name: 'Jhonattan' },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId, name: 'Jhonattan' }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId, name: 'Thannia' },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId, name: 'Thannia' }\r\n    });\r\n\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;IA6NsB,oBAAA,WAAA,GAAA,IAAA,oSAAA,EAAA,8CAAA,yRAAA,EAAA,KAAA,GAAA,+RAAA,EAAA"}},
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\n\r\n// --- GLOBAL PRISMA ---\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    \r\n    // 1. Verificar firma del token\r\n    const payload = await verifyToken(token);\r\n    if (!payload) return null;\r\n    try {\r\n        const user = await prisma.user.findUnique({ \r\n            where: { id: payload.id as string } \r\n        });\r\n        // Si no se encuentra el usuario en BD, retornamos null (inválido)\r\n        return user; \r\n    } catch (error) {\r\n        console.log(error );\r\n        return null;\r\n    }\r\n\r\n    //return await verifyToken(token);\r\n}\r\n\r\n// --- CREAR USUARIO (Para el botón Admin) ---\r\nexport async function createNewUser(name: string, email: string, householdId: string) {\r\n    const currentUser = await getCurrentUser();\r\n    \r\n    // Validación de seguridad básica: Solo User Master puede crear usuarios\r\n    if (currentUser?.email !== process.env.GMAIL_USER) {\r\n        return { success: false, message: 'No autorizado' };\r\n    }\r\n\r\n    try {\r\n        const existing = await prisma.user.findUnique({ where: { email } });\r\n        if (existing) return { success: false, message: 'El usuario ya existe.' };\r\n        \r\n        const existinHouseHold = await prisma.user.findMany({ where: { householdId } });\r\n        console.log(\"existinHouseHold \", existinHouseHold);\r\n        if (!existinHouseHold){\r\n            await prisma.account.createMany({\r\n                data: [\r\n                    { name: 'Dinero Efectivo', bank: 'Efectivo', type: 'wallet', owner: name, color: '#25ab28ff', householdId: householdId },\r\n                    { name: 'Ahorro Global', bank: 'Ahorro', type: 'savings_virtual', owner: name, color: '#fba300ff', householdId: householdId } \r\n                ]\r\n            });    \r\n        } \r\n        \r\n        await prisma.user.create({\r\n            data: {\r\n                email,\r\n                name,\r\n                householdId,\r\n                token: 'INIT', // Token inicial placeholder\r\n              }\r\n          });\r\n        \r\n        revalidatePath('/admin');\r\n        return { success: true, message: 'Usuario creado exitosamente.' };\r\n    } catch (error) {\r\n        return { success: false, message: 'Error creando usuario en BD.' };\r\n    }\r\n    \r\n}\r\n\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@?!+_\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n    \r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    \r\n    if (!user || !user.token) return { success: false, message: 'Código incorrecto.' };\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO (SOLICITUD) ---\r\nexport async function requestRegistration(email: string, name: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        // Enviamos nombre, email y familia al correo\r\n        await sendRegistrationRequestEmail(email, name, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. Establecer cookie de Demo (Importante: path '/')\r\n    cookieStore.set('is_demo_mode', 'true', { \r\n        path: '/',\r\n        httpOnly: true,\r\n        maxAge: 60 * 60 * 24 // 1 día\r\n    });\r\n    \r\n    // 2. Borrar token anterior si existe para evitar conflictos\r\n    cookieStore.delete('auth_token');\r\n    \r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n\r\n    // --- DEMO DATA ---\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' },\r\n            unauthorized: false\r\n        };\r\n    }\r\n\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; \r\n    }\r\n\r\n    // --- USER DATA ---\r\n    const householdId = user.householdId; \r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({\r\n        where: { householdId },\r\n        // NO poner aquí un filtro solo para 'expense'. \r\n        // Si tienes filtros de tipo, deben incluir 'income' para que se vea la entrada de la transferencia.\r\n        orderBy: { date: 'desc' },\r\n        include: { \r\n            account: { select: { name: true, color: true } },\r\n            category: { select: { name: true } }\r\n        }\r\n    });\r\n\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user,\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES Y UPDATES TRANSACTIONS ---\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n    // 1. TRANSFERENCIA: CREA DOS MOVIMIENTOS\r\n    if (data.type === 'transfer') {\r\n        // Buscar/Crear categoría\r\n        let transferCat = await prisma.category.findFirst({ where: { householdId, name: 'Transferencia Propia' } });\r\n        if (!transferCat) {\r\n            transferCat = await prisma.category.create({ data: { householdId, name: 'Transferencia Propia', type: 'transfer', subCategories: JSON.stringify([]) } });\r\n        }\r\n\r\n        // A. SALIDA (Gasto - Cuenta Origen)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'expense', amount: data.amount, \r\n                accountId: data.accountId, \r\n                categoryId: transferCat.id, \r\n                description: `Transferencia a: ${data.destAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        // B. ENTRADA (Ingreso - Cuenta Destino)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'income', amount: data.amount, \r\n                accountId: data.relatedAccountId, \r\n                categoryId: transferCat.id, \r\n                description: `Recibido de: ${data.originAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } \r\n    \r\n    // 2. GASTO / INGRESO NORMAL\r\n    else {\r\n\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        \r\n        // --- GASTO NORMAL ---\r\n        await prisma.transaction.create({\r\n            data: { \r\n                householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount,\r\n                accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, \r\n                isFixed: data.isFixed || false, \r\n                isSavings: data.isSavings || false, \r\n                payWithSavings: data.payWithSavings || false,\r\n                didWithdraw: data.payWithSavings ? true : (data.didWithdraw ?? true)\r\n            }\r\n        });\r\n\r\n        /*if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }*/\r\n\r\n\r\n        \r\n        // --- LÓGICA DE SALDOS ---\r\n\r\n        // A. CASO \"GASTAR DE AHORRO\" (Expense + payWithSavings)\r\n        if (data.payWithSavings && data.type === 'expense') {\r\n            // Restamos del balance total Y del balanceSafe de la cuenta\r\n            await prisma.account.update({ \r\n                where: { id: data.accountId }, \r\n                data: { \r\n                    balance: { decrement: data.amount },\r\n                    balanceSafe: { decrement: data.amount } \r\n                } \r\n            });\r\n            // Restamos también del Ahorro Global (Cuenta Virtual)\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) {\r\n                await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n            }\r\n        }\r\n        \r\n        // B. CASO \"ES AHORRO\" (Guardar dinero)\r\n        else if (data.isSavings) {\r\n             // 1. Si es INGRESO y es ahorro: Sube Balance Total y Sube BalanceSafe\r\n             if (data.type === 'income') {\r\n                await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        balance: { increment: data.amount },\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });\r\n                let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             \r\n             } \r\n             // 2. Si es GASTO (Sacar del bolsillo diario para guardar): El balance total NO cambia (el dinero sigue en la cuenta), pero sube el BalanceSafe\r\n             // NOTA: Si el usuario quiere que \"salga\" de la cuenta, debería usar Transferencia. Asumimos que \"Gasto -> Es Ahorro\" es apartar dinero.\r\n             else if (data.type === 'expense') {\r\n                 /*await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        // No tocamos balance total porque el dinero no se ha ido del banco, solo cambió de \"estado\"\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });*/\r\n                // ---> NUEVA LÓGICA: RETIRO FÍSICO PARA AHORRO <---\r\n                 if (data.didWithdraw) {\r\n                     // a. Restamos de la cuenta origen (Banco)\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balance: { decrement: data.amount } } // Solo decrementa balance total, no balanceSafe, porque salió del banco\r\n                    });\r\n\r\n                    // b. Buscamos (o creamos) la cuenta \"Dinero Efectivo\"\r\n                    let cashAccount = await prisma.account.findFirst({ \r\n                        where: { householdId, name: 'Dinero Efectivo' } // Buscamos por nombre o tipo 'wallet'\r\n                    });\r\n\r\n                    if (!cashAccount) {\r\n                        cashAccount = await prisma.account.create({\r\n                            data: {\r\n                                householdId,\r\n                                name: 'Dinero Efectivo',\r\n                                bank: 'Efectivo',\r\n                                type: 'wallet',\r\n                                color: '#10b981',\r\n                                owner: 'Casa'\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    // c. Sumamos a \"Dinero Efectivo\" como Ahorro (BalanceSafe)\r\n                    // Aquí el dinero entra físicamente y se marca como reservado\r\n                    await prisma.account.update({\r\n                        where: { id: cashAccount.id },\r\n                        data: {\r\n                            balance: { increment: data.amount },\r\n                            balanceSafe: { increment: data.amount }\r\n                        }\r\n                    });\r\n\r\n                 } else {\r\n                     // ---> LÓGICA ANTIGUA: AHORRO VIRTUAL (No sale del banco) <---\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balanceSafe: { increment: data.amount } } \r\n                    });\r\n                 }\r\n\r\n                 // En AMBOS casos, el \"Ahorro Global\" (Espejo) aumenta\r\n                 let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                 if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n                 await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             }\r\n\r\n             \r\n        }\r\n\r\n        // C. CASO NORMAL (Gasto corriente o Ingreso corriente)\r\n        else {\r\n            const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n            if (shouldUpdateBalance) {\r\n                const multiplier = data.type === 'income' ? 1 : -1;\r\n                await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n            }\r\n        }\r\n\r\n        // Reglas Fijas y Crédito (Igual que antes)\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { householdId, description: data.description, categoryId: data.categoryId, budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || date.getDate(), isActive: true }\r\n            });\r\n        }\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');\r\n\r\n\r\n        // Lógica de Ahorro Global (Sumar o Restar)\r\n\r\n        /*\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n        if (data.payWithSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n        }\r\n\r\n        // Regla Fija\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { \r\n                    householdId, \r\n                    description: data.description, \r\n                    categoryId: data.categoryId, \r\n                    \r\n                    budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, \r\n                    accountIdToCharge: data.accountId, \r\n                    dayOfMonth: data.dayOfMonth || date.getDate(), \r\n                    isActive: true }\r\n            });\r\n        }\r\n\r\n\r\n        // --- CRÉDITO AUTOMÁTICO ---\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');*/\r\n}\r\n\r\n// Funciones CRUD estándar\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { id: data.id, name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, \r\n            description: data.description,\r\n            categoryId: data.categoryId,\r\n            accountIdToCharge: data.accountIdToCharge,\r\n            dayOfMonth: parseInt(data.dayOfMonth),householdId: user.householdId,budgetedAmount: parseFloat(data.budgetedAmount || '0'), staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null, isActive: true } }); revalidatePath('/admin'); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, \r\n            // Actualizamos ambos\r\n            //staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null,\r\n            budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId, name: 'Jhonattan' },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId, name: 'Jhonattan' }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId, name: 'Thannia' },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId, name: 'Thannia' }\r\n    });\r\n\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;IA8bsB,gBAAA,WAAA,GAAA,IAAA,oSAAA,EAAA,8CAAA,yRAAA,EAAA,KAAA,GAAA,+RAAA,EAAA"}},
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\n\r\n// --- GLOBAL PRISMA ---\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    \r\n    // 1. Verificar firma del token\r\n    const payload = await verifyToken(token);\r\n    if (!payload) return null;\r\n    try {\r\n        const user = await prisma.user.findUnique({ \r\n            where: { id: payload.id as string } \r\n        });\r\n        // Si no se encuentra el usuario en BD, retornamos null (inválido)\r\n        return user; \r\n    } catch (error) {\r\n        console.log(error );\r\n        return null;\r\n    }\r\n\r\n    //return await verifyToken(token);\r\n}\r\n\r\n// --- CREAR USUARIO (Para el botón Admin) ---\r\nexport async function createNewUser(name: string, email: string, householdId: string) {\r\n    const currentUser = await getCurrentUser();\r\n    \r\n    // Validación de seguridad básica: Solo User Master puede crear usuarios\r\n    if (currentUser?.email !== process.env.GMAIL_USER) {\r\n        return { success: false, message: 'No autorizado' };\r\n    }\r\n\r\n    try {\r\n        const existing = await prisma.user.findUnique({ where: { email } });\r\n        if (existing) return { success: false, message: 'El usuario ya existe.' };\r\n        \r\n        const existinHouseHold = await prisma.user.findMany({ where: { householdId } });\r\n        console.log(\"existinHouseHold \", existinHouseHold);\r\n        if (!existinHouseHold){\r\n            await prisma.account.createMany({\r\n                data: [\r\n                    { name: 'Dinero Efectivo', bank: 'Efectivo', type: 'wallet', owner: name, color: '#25ab28ff', householdId: householdId },\r\n                    { name: 'Ahorro Global', bank: 'Ahorro', type: 'savings_virtual', owner: name, color: '#fba300ff', householdId: householdId } \r\n                ]\r\n            });    \r\n        } \r\n        \r\n        await prisma.user.create({\r\n            data: {\r\n                email,\r\n                name,\r\n                householdId,\r\n                token: 'INIT', // Token inicial placeholder\r\n              }\r\n          });\r\n        \r\n        revalidatePath('/admin');\r\n        return { success: true, message: 'Usuario creado exitosamente.' };\r\n    } catch (error) {\r\n        return { success: false, message: 'Error creando usuario en BD.' };\r\n    }\r\n    \r\n}\r\n\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@?!+_\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n    \r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    \r\n    if (!user || !user.token) return { success: false, message: 'Código incorrecto.' };\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO (SOLICITUD) ---\r\nexport async function requestRegistration(email: string, name: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        // Enviamos nombre, email y familia al correo\r\n        await sendRegistrationRequestEmail(email, name, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. Establecer cookie de Demo (Importante: path '/')\r\n    cookieStore.set('is_demo_mode', 'true', { \r\n        path: '/',\r\n        httpOnly: true,\r\n        maxAge: 60 * 60 * 24 // 1 día\r\n    });\r\n    \r\n    // 2. Borrar token anterior si existe para evitar conflictos\r\n    cookieStore.delete('auth_token');\r\n    \r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n\r\n    // --- DEMO DATA ---\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' },\r\n            unauthorized: false\r\n        };\r\n    }\r\n\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; \r\n    }\r\n\r\n    // --- USER DATA ---\r\n    const householdId = user.householdId; \r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({\r\n        where: { householdId },\r\n        // NO poner aquí un filtro solo para 'expense'. \r\n        // Si tienes filtros de tipo, deben incluir 'income' para que se vea la entrada de la transferencia.\r\n        orderBy: { date: 'desc' },\r\n        include: { \r\n            account: { select: { name: true, color: true } },\r\n            category: { select: { name: true } }\r\n        }\r\n    });\r\n\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user,\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES Y UPDATES TRANSACTIONS ---\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n    // 1. TRANSFERENCIA: CREA DOS MOVIMIENTOS\r\n    if (data.type === 'transfer') {\r\n        // Buscar/Crear categoría\r\n        let transferCat = await prisma.category.findFirst({ where: { householdId, name: 'Transferencia Propia' } });\r\n        if (!transferCat) {\r\n            transferCat = await prisma.category.create({ data: { householdId, name: 'Transferencia Propia', type: 'transfer', subCategories: JSON.stringify([]) } });\r\n        }\r\n\r\n        // A. SALIDA (Gasto - Cuenta Origen)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'expense', amount: data.amount, \r\n                accountId: data.accountId, \r\n                categoryId: transferCat.id, \r\n                description: `Transferencia a: ${data.destAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        // B. ENTRADA (Ingreso - Cuenta Destino)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'income', amount: data.amount, \r\n                accountId: data.relatedAccountId, \r\n                categoryId: transferCat.id, \r\n                description: `Recibido de: ${data.originAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } \r\n    \r\n    // 2. GASTO / INGRESO NORMAL\r\n    else {\r\n\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        \r\n        // --- GASTO NORMAL ---\r\n        await prisma.transaction.create({\r\n            data: { \r\n                householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount,\r\n                accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, \r\n                isFixed: data.isFixed || false, \r\n                isSavings: data.isSavings || false, \r\n                payWithSavings: data.payWithSavings || false,\r\n                didWithdraw: data.payWithSavings ? true : (data.didWithdraw ?? true)\r\n            }\r\n        });\r\n\r\n        /*if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }*/\r\n\r\n\r\n        \r\n        // --- LÓGICA DE SALDOS ---\r\n\r\n        // A. CASO \"GASTAR DE AHORRO\" (Expense + payWithSavings)\r\n        if (data.payWithSavings && data.type === 'expense') {\r\n            // Restamos del balance total Y del balanceSafe de la cuenta\r\n            await prisma.account.update({ \r\n                where: { id: data.accountId }, \r\n                data: { \r\n                    balance: { decrement: data.amount },\r\n                    balanceSafe: { decrement: data.amount } \r\n                } \r\n            });\r\n            // Restamos también del Ahorro Global (Cuenta Virtual)\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) {\r\n                await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n            }\r\n        }\r\n        \r\n        // B. CASO \"ES AHORRO\" (Guardar dinero)\r\n        else if (data.isSavings) {\r\n             // 1. Si es INGRESO y es ahorro: Sube Balance Total y Sube BalanceSafe\r\n             if (data.type === 'income') {\r\n                await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        balance: { increment: data.amount },\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });\r\n                let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             \r\n             } \r\n             // 2. Si es GASTO (Sacar del bolsillo diario para guardar): El balance total NO cambia (el dinero sigue en la cuenta), pero sube el BalanceSafe\r\n             // NOTA: Si el usuario quiere que \"salga\" de la cuenta, debería usar Transferencia. Asumimos que \"Gasto -> Es Ahorro\" es apartar dinero.\r\n             else if (data.type === 'expense') {\r\n                 /*await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        // No tocamos balance total porque el dinero no se ha ido del banco, solo cambió de \"estado\"\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });*/\r\n                // ---> NUEVA LÓGICA: RETIRO FÍSICO PARA AHORRO <---\r\n                 if (data.didWithdraw) {\r\n                     // a. Restamos de la cuenta origen (Banco)\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balance: { decrement: data.amount } } // Solo decrementa balance total, no balanceSafe, porque salió del banco\r\n                    });\r\n\r\n                    // b. Buscamos (o creamos) la cuenta \"Dinero Efectivo\"\r\n                    let cashAccount = await prisma.account.findFirst({ \r\n                        where: { householdId, name: 'Dinero Efectivo' } // Buscamos por nombre o tipo 'wallet'\r\n                    });\r\n\r\n                    if (!cashAccount) {\r\n                        cashAccount = await prisma.account.create({\r\n                            data: {\r\n                                householdId,\r\n                                name: 'Dinero Efectivo',\r\n                                bank: 'Efectivo',\r\n                                type: 'wallet',\r\n                                color: '#10b981',\r\n                                owner: 'Casa'\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    // c. Sumamos a \"Dinero Efectivo\" como Ahorro (BalanceSafe)\r\n                    // Aquí el dinero entra físicamente y se marca como reservado\r\n                    await prisma.account.update({\r\n                        where: { id: cashAccount.id },\r\n                        data: {\r\n                            balance: { increment: data.amount },\r\n                            balanceSafe: { increment: data.amount }\r\n                        }\r\n                    });\r\n\r\n                 } else {\r\n                     // ---> LÓGICA ANTIGUA: AHORRO VIRTUAL (No sale del banco) <---\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balanceSafe: { increment: data.amount } } \r\n                    });\r\n                 }\r\n\r\n                 // En AMBOS casos, el \"Ahorro Global\" (Espejo) aumenta\r\n                 let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                 if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n                 await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             }\r\n\r\n             \r\n        }\r\n\r\n        // C. CASO NORMAL (Gasto corriente o Ingreso corriente)\r\n        else {\r\n            const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n            if (shouldUpdateBalance) {\r\n                const multiplier = data.type === 'income' ? 1 : -1;\r\n                await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n            }\r\n        }\r\n\r\n        // Reglas Fijas y Crédito (Igual que antes)\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { householdId, description: data.description, categoryId: data.categoryId, budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || date.getDate(), isActive: true }\r\n            });\r\n        }\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');\r\n\r\n\r\n        // Lógica de Ahorro Global (Sumar o Restar)\r\n\r\n        /*\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n        if (data.payWithSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n        }\r\n\r\n        // Regla Fija\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { \r\n                    householdId, \r\n                    description: data.description, \r\n                    categoryId: data.categoryId, \r\n                    \r\n                    budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, \r\n                    accountIdToCharge: data.accountId, \r\n                    dayOfMonth: data.dayOfMonth || date.getDate(), \r\n                    isActive: true }\r\n            });\r\n        }\r\n\r\n\r\n        // --- CRÉDITO AUTOMÁTICO ---\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');*/\r\n}\r\n\r\n// Funciones CRUD estándar\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { id: data.id, name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, \r\n            description: data.description,\r\n            categoryId: data.categoryId,\r\n            accountIdToCharge: data.accountIdToCharge,\r\n            dayOfMonth: parseInt(data.dayOfMonth),householdId: user.householdId,budgetedAmount: parseFloat(data.budgetedAmount || '0'), staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null, isActive: true } }); revalidatePath('/admin'); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, \r\n            // Actualizamos ambos\r\n            //staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null,\r\n            budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId, name: 'Jhonattan' },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId, name: 'Jhonattan' }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId, name: 'Thannia' },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId, name: 'Thannia' }\r\n    });\r\n\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;IA+bsB,gBAAA,WAAA,GAAA,IAAA,oSAAA,EAAA,8CAAA,yRAAA,EAAA,KAAA,GAAA,+RAAA,EAAA"}},
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\n\r\n// --- GLOBAL PRISMA ---\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    \r\n    // 1. Verificar firma del token\r\n    const payload = await verifyToken(token);\r\n    if (!payload) return null;\r\n    try {\r\n        const user = await prisma.user.findUnique({ \r\n            where: { id: payload.id as string } \r\n        });\r\n        // Si no se encuentra el usuario en BD, retornamos null (inválido)\r\n        return user; \r\n    } catch (error) {\r\n        console.log(error );\r\n        return null;\r\n    }\r\n\r\n    //return await verifyToken(token);\r\n}\r\n\r\n// --- CREAR USUARIO (Para el botón Admin) ---\r\nexport async function createNewUser(name: string, email: string, householdId: string) {\r\n    const currentUser = await getCurrentUser();\r\n    \r\n    // Validación de seguridad básica: Solo User Master puede crear usuarios\r\n    if (currentUser?.email !== process.env.GMAIL_USER) {\r\n        return { success: false, message: 'No autorizado' };\r\n    }\r\n\r\n    try {\r\n        const existing = await prisma.user.findUnique({ where: { email } });\r\n        if (existing) return { success: false, message: 'El usuario ya existe.' };\r\n        \r\n        const existinHouseHold = await prisma.user.findMany({ where: { householdId } });\r\n        console.log(\"existinHouseHold \", existinHouseHold);\r\n        if (!existinHouseHold){\r\n            await prisma.account.createMany({\r\n                data: [\r\n                    { name: 'Dinero Efectivo', bank: 'Efectivo', type: 'wallet', owner: name, color: '#25ab28ff', householdId: householdId },\r\n                    { name: 'Ahorro Global', bank: 'Ahorro', type: 'savings_virtual', owner: name, color: '#fba300ff', householdId: householdId } \r\n                ]\r\n            });    \r\n        } \r\n        \r\n        await prisma.user.create({\r\n            data: {\r\n                email,\r\n                name,\r\n                householdId,\r\n                token: 'INIT', // Token inicial placeholder\r\n              }\r\n          });\r\n        \r\n        revalidatePath('/admin');\r\n        return { success: true, message: 'Usuario creado exitosamente.' };\r\n    } catch (error) {\r\n        return { success: false, message: 'Error creando usuario en BD.' };\r\n    }\r\n    \r\n}\r\n\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@?!+_\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n    \r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    \r\n    if (!user || !user.token) return { success: false, message: 'Código incorrecto.' };\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO (SOLICITUD) ---\r\nexport async function requestRegistration(email: string, name: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        // Enviamos nombre, email y familia al correo\r\n        await sendRegistrationRequestEmail(email, name, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. Establecer cookie de Demo (Importante: path '/')\r\n    cookieStore.set('is_demo_mode', 'true', { \r\n        path: '/',\r\n        httpOnly: true,\r\n        maxAge: 60 * 60 * 24 // 1 día\r\n    });\r\n    \r\n    // 2. Borrar token anterior si existe para evitar conflictos\r\n    cookieStore.delete('auth_token');\r\n    \r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n\r\n    // --- DEMO DATA ---\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' },\r\n            unauthorized: false\r\n        };\r\n    }\r\n\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; \r\n    }\r\n\r\n    // --- USER DATA ---\r\n    const householdId = user.householdId; \r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({\r\n        where: { householdId },\r\n        // NO poner aquí un filtro solo para 'expense'. \r\n        // Si tienes filtros de tipo, deben incluir 'income' para que se vea la entrada de la transferencia.\r\n        orderBy: { date: 'desc' },\r\n        include: { \r\n            account: { select: { name: true, color: true } },\r\n            category: { select: { name: true } }\r\n        }\r\n    });\r\n\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user,\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES Y UPDATES TRANSACTIONS ---\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n    // 1. TRANSFERENCIA: CREA DOS MOVIMIENTOS\r\n    if (data.type === 'transfer') {\r\n        // Buscar/Crear categoría\r\n        let transferCat = await prisma.category.findFirst({ where: { householdId, name: 'Transferencia Propia' } });\r\n        if (!transferCat) {\r\n            transferCat = await prisma.category.create({ data: { householdId, name: 'Transferencia Propia', type: 'transfer', subCategories: JSON.stringify([]) } });\r\n        }\r\n\r\n        // A. SALIDA (Gasto - Cuenta Origen)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'expense', amount: data.amount, \r\n                accountId: data.accountId, \r\n                categoryId: transferCat.id, \r\n                description: `Transferencia a: ${data.destAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        // B. ENTRADA (Ingreso - Cuenta Destino)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'income', amount: data.amount, \r\n                accountId: data.relatedAccountId, \r\n                categoryId: transferCat.id, \r\n                description: `Recibido de: ${data.originAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } \r\n    \r\n    // 2. GASTO / INGRESO NORMAL\r\n    else {\r\n\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        \r\n        // --- GASTO NORMAL ---\r\n        await prisma.transaction.create({\r\n            data: { \r\n                householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount,\r\n                accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, \r\n                isFixed: data.isFixed || false, \r\n                isSavings: data.isSavings || false, \r\n                payWithSavings: data.payWithSavings || false,\r\n                didWithdraw: data.payWithSavings ? true : (data.didWithdraw ?? true)\r\n            }\r\n        });\r\n\r\n        /*if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }*/\r\n\r\n\r\n        \r\n        // --- LÓGICA DE SALDOS ---\r\n\r\n        // A. CASO \"GASTAR DE AHORRO\" (Expense + payWithSavings)\r\n        if (data.payWithSavings && data.type === 'expense') {\r\n            // Restamos del balance total Y del balanceSafe de la cuenta\r\n            await prisma.account.update({ \r\n                where: { id: data.accountId }, \r\n                data: { \r\n                    balance: { decrement: data.amount },\r\n                    balanceSafe: { decrement: data.amount } \r\n                } \r\n            });\r\n            // Restamos también del Ahorro Global (Cuenta Virtual)\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) {\r\n                await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n            }\r\n        }\r\n        \r\n        // B. CASO \"ES AHORRO\" (Guardar dinero)\r\n        else if (data.isSavings) {\r\n             // 1. Si es INGRESO y es ahorro: Sube Balance Total y Sube BalanceSafe\r\n             if (data.type === 'income') {\r\n                await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        balance: { increment: data.amount },\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });\r\n                let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             \r\n             } \r\n             // 2. Si es GASTO (Sacar del bolsillo diario para guardar): El balance total NO cambia (el dinero sigue en la cuenta), pero sube el BalanceSafe\r\n             // NOTA: Si el usuario quiere que \"salga\" de la cuenta, debería usar Transferencia. Asumimos que \"Gasto -> Es Ahorro\" es apartar dinero.\r\n             else if (data.type === 'expense') {\r\n                 /*await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        // No tocamos balance total porque el dinero no se ha ido del banco, solo cambió de \"estado\"\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });*/\r\n                // ---> NUEVA LÓGICA: RETIRO FÍSICO PARA AHORRO <---\r\n                 if (data.didWithdraw) {\r\n                     // a. Restamos de la cuenta origen (Banco)\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balance: { decrement: data.amount } } // Solo decrementa balance total, no balanceSafe, porque salió del banco\r\n                    });\r\n\r\n                    // b. Buscamos (o creamos) la cuenta \"Dinero Efectivo\"\r\n                    let cashAccount = await prisma.account.findFirst({ \r\n                        where: { householdId, name: 'Dinero Efectivo' } // Buscamos por nombre o tipo 'wallet'\r\n                    });\r\n\r\n                    if (!cashAccount) {\r\n                        cashAccount = await prisma.account.create({\r\n                            data: {\r\n                                householdId,\r\n                                name: 'Dinero Efectivo',\r\n                                bank: 'Efectivo',\r\n                                type: 'wallet',\r\n                                color: '#10b981',\r\n                                owner: 'Casa'\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    // c. Sumamos a \"Dinero Efectivo\" como Ahorro (BalanceSafe)\r\n                    // Aquí el dinero entra físicamente y se marca como reservado\r\n                    await prisma.account.update({\r\n                        where: { id: cashAccount.id },\r\n                        data: {\r\n                            balance: { increment: data.amount },\r\n                            balanceSafe: { increment: data.amount }\r\n                        }\r\n                    });\r\n\r\n                 } else {\r\n                     // ---> LÓGICA ANTIGUA: AHORRO VIRTUAL (No sale del banco) <---\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balanceSafe: { increment: data.amount } } \r\n                    });\r\n                 }\r\n\r\n                 // En AMBOS casos, el \"Ahorro Global\" (Espejo) aumenta\r\n                 let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                 if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n                 await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             }\r\n\r\n             \r\n        }\r\n\r\n        // C. CASO NORMAL (Gasto corriente o Ingreso corriente)\r\n        else {\r\n            const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n            if (shouldUpdateBalance) {\r\n                const multiplier = data.type === 'income' ? 1 : -1;\r\n                await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n            }\r\n        }\r\n\r\n        // Reglas Fijas y Crédito (Igual que antes)\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { householdId, description: data.description, categoryId: data.categoryId, budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || date.getDate(), isActive: true }\r\n            });\r\n        }\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');\r\n\r\n\r\n        // Lógica de Ahorro Global (Sumar o Restar)\r\n\r\n        /*\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n        if (data.payWithSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n        }\r\n\r\n        // Regla Fija\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { \r\n                    householdId, \r\n                    description: data.description, \r\n                    categoryId: data.categoryId, \r\n                    \r\n                    budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, \r\n                    accountIdToCharge: data.accountId, \r\n                    dayOfMonth: data.dayOfMonth || date.getDate(), \r\n                    isActive: true }\r\n            });\r\n        }\r\n\r\n\r\n        // --- CRÉDITO AUTOMÁTICO ---\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');*/\r\n}\r\n\r\n// Funciones CRUD estándar\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { id: data.id, name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, \r\n            description: data.description,\r\n            categoryId: data.categoryId,\r\n            accountIdToCharge: data.accountIdToCharge,\r\n            dayOfMonth: parseInt(data.dayOfMonth),householdId: user.householdId,budgetedAmount: parseFloat(data.budgetedAmount || '0'), staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null, isActive: true } }); revalidatePath('/admin'); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, \r\n            // Actualizamos ambos\r\n            //staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null,\r\n            budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId, name: 'Jhonattan' },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId, name: 'Jhonattan' }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId, name: 'Thannia' },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId, name: 'Thannia' }\r\n    });\r\n\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;IAicsB,iBAAA,WAAA,GAAA,IAAA,oSAAA,EAAA,8CAAA,yRAAA,EAAA,KAAA,GAAA,+RAAA,EAAA"}},
    {"offset": {"line": 88, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\n\r\n// --- GLOBAL PRISMA ---\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    \r\n    // 1. Verificar firma del token\r\n    const payload = await verifyToken(token);\r\n    if (!payload) return null;\r\n    try {\r\n        const user = await prisma.user.findUnique({ \r\n            where: { id: payload.id as string } \r\n        });\r\n        // Si no se encuentra el usuario en BD, retornamos null (inválido)\r\n        return user; \r\n    } catch (error) {\r\n        console.log(error );\r\n        return null;\r\n    }\r\n\r\n    //return await verifyToken(token);\r\n}\r\n\r\n// --- CREAR USUARIO (Para el botón Admin) ---\r\nexport async function createNewUser(name: string, email: string, householdId: string) {\r\n    const currentUser = await getCurrentUser();\r\n    \r\n    // Validación de seguridad básica: Solo User Master puede crear usuarios\r\n    if (currentUser?.email !== process.env.GMAIL_USER) {\r\n        return { success: false, message: 'No autorizado' };\r\n    }\r\n\r\n    try {\r\n        const existing = await prisma.user.findUnique({ where: { email } });\r\n        if (existing) return { success: false, message: 'El usuario ya existe.' };\r\n        \r\n        const existinHouseHold = await prisma.user.findMany({ where: { householdId } });\r\n        console.log(\"existinHouseHold \", existinHouseHold);\r\n        if (!existinHouseHold){\r\n            await prisma.account.createMany({\r\n                data: [\r\n                    { name: 'Dinero Efectivo', bank: 'Efectivo', type: 'wallet', owner: name, color: '#25ab28ff', householdId: householdId },\r\n                    { name: 'Ahorro Global', bank: 'Ahorro', type: 'savings_virtual', owner: name, color: '#fba300ff', householdId: householdId } \r\n                ]\r\n            });    \r\n        } \r\n        \r\n        await prisma.user.create({\r\n            data: {\r\n                email,\r\n                name,\r\n                householdId,\r\n                token: 'INIT', // Token inicial placeholder\r\n              }\r\n          });\r\n        \r\n        revalidatePath('/admin');\r\n        return { success: true, message: 'Usuario creado exitosamente.' };\r\n    } catch (error) {\r\n        return { success: false, message: 'Error creando usuario en BD.' };\r\n    }\r\n    \r\n}\r\n\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@?!+_\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n    \r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    \r\n    if (!user || !user.token) return { success: false, message: 'Código incorrecto.' };\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO (SOLICITUD) ---\r\nexport async function requestRegistration(email: string, name: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        // Enviamos nombre, email y familia al correo\r\n        await sendRegistrationRequestEmail(email, name, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. Establecer cookie de Demo (Importante: path '/')\r\n    cookieStore.set('is_demo_mode', 'true', { \r\n        path: '/',\r\n        httpOnly: true,\r\n        maxAge: 60 * 60 * 24 // 1 día\r\n    });\r\n    \r\n    // 2. Borrar token anterior si existe para evitar conflictos\r\n    cookieStore.delete('auth_token');\r\n    \r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n\r\n    // --- DEMO DATA ---\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' },\r\n            unauthorized: false\r\n        };\r\n    }\r\n\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; \r\n    }\r\n\r\n    // --- USER DATA ---\r\n    const householdId = user.householdId; \r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({\r\n        where: { householdId },\r\n        // NO poner aquí un filtro solo para 'expense'. \r\n        // Si tienes filtros de tipo, deben incluir 'income' para que se vea la entrada de la transferencia.\r\n        orderBy: { date: 'desc' },\r\n        include: { \r\n            account: { select: { name: true, color: true } },\r\n            category: { select: { name: true } }\r\n        }\r\n    });\r\n\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user,\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES Y UPDATES TRANSACTIONS ---\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n    // 1. TRANSFERENCIA: CREA DOS MOVIMIENTOS\r\n    if (data.type === 'transfer') {\r\n        // Buscar/Crear categoría\r\n        let transferCat = await prisma.category.findFirst({ where: { householdId, name: 'Transferencia Propia' } });\r\n        if (!transferCat) {\r\n            transferCat = await prisma.category.create({ data: { householdId, name: 'Transferencia Propia', type: 'transfer', subCategories: JSON.stringify([]) } });\r\n        }\r\n\r\n        // A. SALIDA (Gasto - Cuenta Origen)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'expense', amount: data.amount, \r\n                accountId: data.accountId, \r\n                categoryId: transferCat.id, \r\n                description: `Transferencia a: ${data.destAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        // B. ENTRADA (Ingreso - Cuenta Destino)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'income', amount: data.amount, \r\n                accountId: data.relatedAccountId, \r\n                categoryId: transferCat.id, \r\n                description: `Recibido de: ${data.originAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } \r\n    \r\n    // 2. GASTO / INGRESO NORMAL\r\n    else {\r\n\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        \r\n        // --- GASTO NORMAL ---\r\n        await prisma.transaction.create({\r\n            data: { \r\n                householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount,\r\n                accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, \r\n                isFixed: data.isFixed || false, \r\n                isSavings: data.isSavings || false, \r\n                payWithSavings: data.payWithSavings || false,\r\n                didWithdraw: data.payWithSavings ? true : (data.didWithdraw ?? true)\r\n            }\r\n        });\r\n\r\n        /*if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }*/\r\n\r\n\r\n        \r\n        // --- LÓGICA DE SALDOS ---\r\n\r\n        // A. CASO \"GASTAR DE AHORRO\" (Expense + payWithSavings)\r\n        if (data.payWithSavings && data.type === 'expense') {\r\n            // Restamos del balance total Y del balanceSafe de la cuenta\r\n            await prisma.account.update({ \r\n                where: { id: data.accountId }, \r\n                data: { \r\n                    balance: { decrement: data.amount },\r\n                    balanceSafe: { decrement: data.amount } \r\n                } \r\n            });\r\n            // Restamos también del Ahorro Global (Cuenta Virtual)\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) {\r\n                await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n            }\r\n        }\r\n        \r\n        // B. CASO \"ES AHORRO\" (Guardar dinero)\r\n        else if (data.isSavings) {\r\n             // 1. Si es INGRESO y es ahorro: Sube Balance Total y Sube BalanceSafe\r\n             if (data.type === 'income') {\r\n                await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        balance: { increment: data.amount },\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });\r\n                let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             \r\n             } \r\n             // 2. Si es GASTO (Sacar del bolsillo diario para guardar): El balance total NO cambia (el dinero sigue en la cuenta), pero sube el BalanceSafe\r\n             // NOTA: Si el usuario quiere que \"salga\" de la cuenta, debería usar Transferencia. Asumimos que \"Gasto -> Es Ahorro\" es apartar dinero.\r\n             else if (data.type === 'expense') {\r\n                 /*await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        // No tocamos balance total porque el dinero no se ha ido del banco, solo cambió de \"estado\"\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });*/\r\n                // ---> NUEVA LÓGICA: RETIRO FÍSICO PARA AHORRO <---\r\n                 if (data.didWithdraw) {\r\n                     // a. Restamos de la cuenta origen (Banco)\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balance: { decrement: data.amount } } // Solo decrementa balance total, no balanceSafe, porque salió del banco\r\n                    });\r\n\r\n                    // b. Buscamos (o creamos) la cuenta \"Dinero Efectivo\"\r\n                    let cashAccount = await prisma.account.findFirst({ \r\n                        where: { householdId, name: 'Dinero Efectivo' } // Buscamos por nombre o tipo 'wallet'\r\n                    });\r\n\r\n                    if (!cashAccount) {\r\n                        cashAccount = await prisma.account.create({\r\n                            data: {\r\n                                householdId,\r\n                                name: 'Dinero Efectivo',\r\n                                bank: 'Efectivo',\r\n                                type: 'wallet',\r\n                                color: '#10b981',\r\n                                owner: 'Casa'\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    // c. Sumamos a \"Dinero Efectivo\" como Ahorro (BalanceSafe)\r\n                    // Aquí el dinero entra físicamente y se marca como reservado\r\n                    await prisma.account.update({\r\n                        where: { id: cashAccount.id },\r\n                        data: {\r\n                            balance: { increment: data.amount },\r\n                            balanceSafe: { increment: data.amount }\r\n                        }\r\n                    });\r\n\r\n                 } else {\r\n                     // ---> LÓGICA ANTIGUA: AHORRO VIRTUAL (No sale del banco) <---\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balanceSafe: { increment: data.amount } } \r\n                    });\r\n                 }\r\n\r\n                 // En AMBOS casos, el \"Ahorro Global\" (Espejo) aumenta\r\n                 let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                 if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n                 await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             }\r\n\r\n             \r\n        }\r\n\r\n        // C. CASO NORMAL (Gasto corriente o Ingreso corriente)\r\n        else {\r\n            const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n            if (shouldUpdateBalance) {\r\n                const multiplier = data.type === 'income' ? 1 : -1;\r\n                await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n            }\r\n        }\r\n\r\n        // Reglas Fijas y Crédito (Igual que antes)\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { householdId, description: data.description, categoryId: data.categoryId, budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || date.getDate(), isActive: true }\r\n            });\r\n        }\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');\r\n\r\n\r\n        // Lógica de Ahorro Global (Sumar o Restar)\r\n\r\n        /*\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n        if (data.payWithSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n        }\r\n\r\n        // Regla Fija\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { \r\n                    householdId, \r\n                    description: data.description, \r\n                    categoryId: data.categoryId, \r\n                    \r\n                    budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, \r\n                    accountIdToCharge: data.accountId, \r\n                    dayOfMonth: data.dayOfMonth || date.getDate(), \r\n                    isActive: true }\r\n            });\r\n        }\r\n\r\n\r\n        // --- CRÉDITO AUTOMÁTICO ---\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');*/\r\n}\r\n\r\n// Funciones CRUD estándar\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { id: data.id, name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, \r\n            description: data.description,\r\n            categoryId: data.categoryId,\r\n            accountIdToCharge: data.accountIdToCharge,\r\n            dayOfMonth: parseInt(data.dayOfMonth),householdId: user.householdId,budgetedAmount: parseFloat(data.budgetedAmount || '0'), staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null, isActive: true } }); revalidatePath('/admin'); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, \r\n            // Actualizamos ambos\r\n            //staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null,\r\n            budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId, name: 'Jhonattan' },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId, name: 'Jhonattan' }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId, name: 'Thannia' },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId, name: 'Thannia' }\r\n    });\r\n\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;IA+csB,oBAAA,WAAA,GAAA,IAAA,oSAAA,EAAA,8CAAA,yRAAA,EAAA,KAAA,GAAA,+RAAA,EAAA"}},
    {"offset": {"line": 100, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\n\r\n// --- GLOBAL PRISMA ---\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    \r\n    // 1. Verificar firma del token\r\n    const payload = await verifyToken(token);\r\n    if (!payload) return null;\r\n    try {\r\n        const user = await prisma.user.findUnique({ \r\n            where: { id: payload.id as string } \r\n        });\r\n        // Si no se encuentra el usuario en BD, retornamos null (inválido)\r\n        return user; \r\n    } catch (error) {\r\n        console.log(error );\r\n        return null;\r\n    }\r\n\r\n    //return await verifyToken(token);\r\n}\r\n\r\n// --- CREAR USUARIO (Para el botón Admin) ---\r\nexport async function createNewUser(name: string, email: string, householdId: string) {\r\n    const currentUser = await getCurrentUser();\r\n    \r\n    // Validación de seguridad básica: Solo User Master puede crear usuarios\r\n    if (currentUser?.email !== process.env.GMAIL_USER) {\r\n        return { success: false, message: 'No autorizado' };\r\n    }\r\n\r\n    try {\r\n        const existing = await prisma.user.findUnique({ where: { email } });\r\n        if (existing) return { success: false, message: 'El usuario ya existe.' };\r\n        \r\n        const existinHouseHold = await prisma.user.findMany({ where: { householdId } });\r\n        console.log(\"existinHouseHold \", existinHouseHold);\r\n        if (!existinHouseHold){\r\n            await prisma.account.createMany({\r\n                data: [\r\n                    { name: 'Dinero Efectivo', bank: 'Efectivo', type: 'wallet', owner: name, color: '#25ab28ff', householdId: householdId },\r\n                    { name: 'Ahorro Global', bank: 'Ahorro', type: 'savings_virtual', owner: name, color: '#fba300ff', householdId: householdId } \r\n                ]\r\n            });    \r\n        } \r\n        \r\n        await prisma.user.create({\r\n            data: {\r\n                email,\r\n                name,\r\n                householdId,\r\n                token: 'INIT', // Token inicial placeholder\r\n              }\r\n          });\r\n        \r\n        revalidatePath('/admin');\r\n        return { success: true, message: 'Usuario creado exitosamente.' };\r\n    } catch (error) {\r\n        return { success: false, message: 'Error creando usuario en BD.' };\r\n    }\r\n    \r\n}\r\n\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@?!+_\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n    \r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    \r\n    if (!user || !user.token) return { success: false, message: 'Código incorrecto.' };\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO (SOLICITUD) ---\r\nexport async function requestRegistration(email: string, name: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        // Enviamos nombre, email y familia al correo\r\n        await sendRegistrationRequestEmail(email, name, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. Establecer cookie de Demo (Importante: path '/')\r\n    cookieStore.set('is_demo_mode', 'true', { \r\n        path: '/',\r\n        httpOnly: true,\r\n        maxAge: 60 * 60 * 24 // 1 día\r\n    });\r\n    \r\n    // 2. Borrar token anterior si existe para evitar conflictos\r\n    cookieStore.delete('auth_token');\r\n    \r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n\r\n    // --- DEMO DATA ---\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' },\r\n            unauthorized: false\r\n        };\r\n    }\r\n\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; \r\n    }\r\n\r\n    // --- USER DATA ---\r\n    const householdId = user.householdId; \r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({\r\n        where: { householdId },\r\n        // NO poner aquí un filtro solo para 'expense'. \r\n        // Si tienes filtros de tipo, deben incluir 'income' para que se vea la entrada de la transferencia.\r\n        orderBy: { date: 'desc' },\r\n        include: { \r\n            account: { select: { name: true, color: true } },\r\n            category: { select: { name: true } }\r\n        }\r\n    });\r\n\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user,\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES Y UPDATES TRANSACTIONS ---\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n    // 1. TRANSFERENCIA: CREA DOS MOVIMIENTOS\r\n    if (data.type === 'transfer') {\r\n        // Buscar/Crear categoría\r\n        let transferCat = await prisma.category.findFirst({ where: { householdId, name: 'Transferencia Propia' } });\r\n        if (!transferCat) {\r\n            transferCat = await prisma.category.create({ data: { householdId, name: 'Transferencia Propia', type: 'transfer', subCategories: JSON.stringify([]) } });\r\n        }\r\n\r\n        // A. SALIDA (Gasto - Cuenta Origen)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'expense', amount: data.amount, \r\n                accountId: data.accountId, \r\n                categoryId: transferCat.id, \r\n                description: `Transferencia a: ${data.destAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        // B. ENTRADA (Ingreso - Cuenta Destino)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'income', amount: data.amount, \r\n                accountId: data.relatedAccountId, \r\n                categoryId: transferCat.id, \r\n                description: `Recibido de: ${data.originAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } \r\n    \r\n    // 2. GASTO / INGRESO NORMAL\r\n    else {\r\n\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        \r\n        // --- GASTO NORMAL ---\r\n        await prisma.transaction.create({\r\n            data: { \r\n                householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount,\r\n                accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, \r\n                isFixed: data.isFixed || false, \r\n                isSavings: data.isSavings || false, \r\n                payWithSavings: data.payWithSavings || false,\r\n                didWithdraw: data.payWithSavings ? true : (data.didWithdraw ?? true)\r\n            }\r\n        });\r\n\r\n        /*if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }*/\r\n\r\n\r\n        \r\n        // --- LÓGICA DE SALDOS ---\r\n\r\n        // A. CASO \"GASTAR DE AHORRO\" (Expense + payWithSavings)\r\n        if (data.payWithSavings && data.type === 'expense') {\r\n            // Restamos del balance total Y del balanceSafe de la cuenta\r\n            await prisma.account.update({ \r\n                where: { id: data.accountId }, \r\n                data: { \r\n                    balance: { decrement: data.amount },\r\n                    balanceSafe: { decrement: data.amount } \r\n                } \r\n            });\r\n            // Restamos también del Ahorro Global (Cuenta Virtual)\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) {\r\n                await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n            }\r\n        }\r\n        \r\n        // B. CASO \"ES AHORRO\" (Guardar dinero)\r\n        else if (data.isSavings) {\r\n             // 1. Si es INGRESO y es ahorro: Sube Balance Total y Sube BalanceSafe\r\n             if (data.type === 'income') {\r\n                await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        balance: { increment: data.amount },\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });\r\n                let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             \r\n             } \r\n             // 2. Si es GASTO (Sacar del bolsillo diario para guardar): El balance total NO cambia (el dinero sigue en la cuenta), pero sube el BalanceSafe\r\n             // NOTA: Si el usuario quiere que \"salga\" de la cuenta, debería usar Transferencia. Asumimos que \"Gasto -> Es Ahorro\" es apartar dinero.\r\n             else if (data.type === 'expense') {\r\n                 /*await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        // No tocamos balance total porque el dinero no se ha ido del banco, solo cambió de \"estado\"\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });*/\r\n                // ---> NUEVA LÓGICA: RETIRO FÍSICO PARA AHORRO <---\r\n                 if (data.didWithdraw) {\r\n                     // a. Restamos de la cuenta origen (Banco)\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balance: { decrement: data.amount } } // Solo decrementa balance total, no balanceSafe, porque salió del banco\r\n                    });\r\n\r\n                    // b. Buscamos (o creamos) la cuenta \"Dinero Efectivo\"\r\n                    let cashAccount = await prisma.account.findFirst({ \r\n                        where: { householdId, name: 'Dinero Efectivo' } // Buscamos por nombre o tipo 'wallet'\r\n                    });\r\n\r\n                    if (!cashAccount) {\r\n                        cashAccount = await prisma.account.create({\r\n                            data: {\r\n                                householdId,\r\n                                name: 'Dinero Efectivo',\r\n                                bank: 'Efectivo',\r\n                                type: 'wallet',\r\n                                color: '#10b981',\r\n                                owner: 'Casa'\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    // c. Sumamos a \"Dinero Efectivo\" como Ahorro (BalanceSafe)\r\n                    // Aquí el dinero entra físicamente y se marca como reservado\r\n                    await prisma.account.update({\r\n                        where: { id: cashAccount.id },\r\n                        data: {\r\n                            balance: { increment: data.amount },\r\n                            balanceSafe: { increment: data.amount }\r\n                        }\r\n                    });\r\n\r\n                 } else {\r\n                     // ---> LÓGICA ANTIGUA: AHORRO VIRTUAL (No sale del banco) <---\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balanceSafe: { increment: data.amount } } \r\n                    });\r\n                 }\r\n\r\n                 // En AMBOS casos, el \"Ahorro Global\" (Espejo) aumenta\r\n                 let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                 if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n                 await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             }\r\n\r\n             \r\n        }\r\n\r\n        // C. CASO NORMAL (Gasto corriente o Ingreso corriente)\r\n        else {\r\n            const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n            if (shouldUpdateBalance) {\r\n                const multiplier = data.type === 'income' ? 1 : -1;\r\n                await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n            }\r\n        }\r\n\r\n        // Reglas Fijas y Crédito (Igual que antes)\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { householdId, description: data.description, categoryId: data.categoryId, budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || date.getDate(), isActive: true }\r\n            });\r\n        }\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');\r\n\r\n\r\n        // Lógica de Ahorro Global (Sumar o Restar)\r\n\r\n        /*\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n        if (data.payWithSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n        }\r\n\r\n        // Regla Fija\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { \r\n                    householdId, \r\n                    description: data.description, \r\n                    categoryId: data.categoryId, \r\n                    \r\n                    budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, \r\n                    accountIdToCharge: data.accountId, \r\n                    dayOfMonth: data.dayOfMonth || date.getDate(), \r\n                    isActive: true }\r\n            });\r\n        }\r\n\r\n\r\n        // --- CRÉDITO AUTOMÁTICO ---\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');*/\r\n}\r\n\r\n// Funciones CRUD estándar\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { id: data.id, name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, \r\n            description: data.description,\r\n            categoryId: data.categoryId,\r\n            accountIdToCharge: data.accountIdToCharge,\r\n            dayOfMonth: parseInt(data.dayOfMonth),householdId: user.householdId,budgetedAmount: parseFloat(data.budgetedAmount || '0'), staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null, isActive: true } }); revalidatePath('/admin'); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, \r\n            // Actualizamos ambos\r\n            //staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null,\r\n            budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId, name: 'Jhonattan' },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId, name: 'Jhonattan' }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId, name: 'Thannia' },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId, name: 'Thannia' }\r\n    });\r\n\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;IAgdsB,sBAAA,WAAA,GAAA,IAAA,oSAAA,EAAA,8CAAA,yRAAA,EAAA,KAAA,GAAA,+RAAA,EAAA"}},
    {"offset": {"line": 112, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\n\r\n// --- GLOBAL PRISMA ---\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    \r\n    // 1. Verificar firma del token\r\n    const payload = await verifyToken(token);\r\n    if (!payload) return null;\r\n    try {\r\n        const user = await prisma.user.findUnique({ \r\n            where: { id: payload.id as string } \r\n        });\r\n        // Si no se encuentra el usuario en BD, retornamos null (inválido)\r\n        return user; \r\n    } catch (error) {\r\n        console.log(error );\r\n        return null;\r\n    }\r\n\r\n    //return await verifyToken(token);\r\n}\r\n\r\n// --- CREAR USUARIO (Para el botón Admin) ---\r\nexport async function createNewUser(name: string, email: string, householdId: string) {\r\n    const currentUser = await getCurrentUser();\r\n    \r\n    // Validación de seguridad básica: Solo User Master puede crear usuarios\r\n    if (currentUser?.email !== process.env.GMAIL_USER) {\r\n        return { success: false, message: 'No autorizado' };\r\n    }\r\n\r\n    try {\r\n        const existing = await prisma.user.findUnique({ where: { email } });\r\n        if (existing) return { success: false, message: 'El usuario ya existe.' };\r\n        \r\n        const existinHouseHold = await prisma.user.findMany({ where: { householdId } });\r\n        console.log(\"existinHouseHold \", existinHouseHold);\r\n        if (!existinHouseHold){\r\n            await prisma.account.createMany({\r\n                data: [\r\n                    { name: 'Dinero Efectivo', bank: 'Efectivo', type: 'wallet', owner: name, color: '#25ab28ff', householdId: householdId },\r\n                    { name: 'Ahorro Global', bank: 'Ahorro', type: 'savings_virtual', owner: name, color: '#fba300ff', householdId: householdId } \r\n                ]\r\n            });    \r\n        } \r\n        \r\n        await prisma.user.create({\r\n            data: {\r\n                email,\r\n                name,\r\n                householdId,\r\n                token: 'INIT', // Token inicial placeholder\r\n              }\r\n          });\r\n        \r\n        revalidatePath('/admin');\r\n        return { success: true, message: 'Usuario creado exitosamente.' };\r\n    } catch (error) {\r\n        return { success: false, message: 'Error creando usuario en BD.' };\r\n    }\r\n    \r\n}\r\n\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@?!+_\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n    \r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    \r\n    if (!user || !user.token) return { success: false, message: 'Código incorrecto.' };\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO (SOLICITUD) ---\r\nexport async function requestRegistration(email: string, name: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        // Enviamos nombre, email y familia al correo\r\n        await sendRegistrationRequestEmail(email, name, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. Establecer cookie de Demo (Importante: path '/')\r\n    cookieStore.set('is_demo_mode', 'true', { \r\n        path: '/',\r\n        httpOnly: true,\r\n        maxAge: 60 * 60 * 24 // 1 día\r\n    });\r\n    \r\n    // 2. Borrar token anterior si existe para evitar conflictos\r\n    cookieStore.delete('auth_token');\r\n    \r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n\r\n    // --- DEMO DATA ---\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' },\r\n            unauthorized: false\r\n        };\r\n    }\r\n\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; \r\n    }\r\n\r\n    // --- USER DATA ---\r\n    const householdId = user.householdId; \r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({\r\n        where: { householdId },\r\n        // NO poner aquí un filtro solo para 'expense'. \r\n        // Si tienes filtros de tipo, deben incluir 'income' para que se vea la entrada de la transferencia.\r\n        orderBy: { date: 'desc' },\r\n        include: { \r\n            account: { select: { name: true, color: true } },\r\n            category: { select: { name: true } }\r\n        }\r\n    });\r\n\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user,\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES Y UPDATES TRANSACTIONS ---\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n    // 1. TRANSFERENCIA: CREA DOS MOVIMIENTOS\r\n    if (data.type === 'transfer') {\r\n        // Buscar/Crear categoría\r\n        let transferCat = await prisma.category.findFirst({ where: { householdId, name: 'Transferencia Propia' } });\r\n        if (!transferCat) {\r\n            transferCat = await prisma.category.create({ data: { householdId, name: 'Transferencia Propia', type: 'transfer', subCategories: JSON.stringify([]) } });\r\n        }\r\n\r\n        // A. SALIDA (Gasto - Cuenta Origen)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'expense', amount: data.amount, \r\n                accountId: data.accountId, \r\n                categoryId: transferCat.id, \r\n                description: `Transferencia a: ${data.destAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        // B. ENTRADA (Ingreso - Cuenta Destino)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'income', amount: data.amount, \r\n                accountId: data.relatedAccountId, \r\n                categoryId: transferCat.id, \r\n                description: `Recibido de: ${data.originAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } \r\n    \r\n    // 2. GASTO / INGRESO NORMAL\r\n    else {\r\n\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        \r\n        // --- GASTO NORMAL ---\r\n        await prisma.transaction.create({\r\n            data: { \r\n                householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount,\r\n                accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, \r\n                isFixed: data.isFixed || false, \r\n                isSavings: data.isSavings || false, \r\n                payWithSavings: data.payWithSavings || false,\r\n                didWithdraw: data.payWithSavings ? true : (data.didWithdraw ?? true)\r\n            }\r\n        });\r\n\r\n        /*if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }*/\r\n\r\n\r\n        \r\n        // --- LÓGICA DE SALDOS ---\r\n\r\n        // A. CASO \"GASTAR DE AHORRO\" (Expense + payWithSavings)\r\n        if (data.payWithSavings && data.type === 'expense') {\r\n            // Restamos del balance total Y del balanceSafe de la cuenta\r\n            await prisma.account.update({ \r\n                where: { id: data.accountId }, \r\n                data: { \r\n                    balance: { decrement: data.amount },\r\n                    balanceSafe: { decrement: data.amount } \r\n                } \r\n            });\r\n            // Restamos también del Ahorro Global (Cuenta Virtual)\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) {\r\n                await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n            }\r\n        }\r\n        \r\n        // B. CASO \"ES AHORRO\" (Guardar dinero)\r\n        else if (data.isSavings) {\r\n             // 1. Si es INGRESO y es ahorro: Sube Balance Total y Sube BalanceSafe\r\n             if (data.type === 'income') {\r\n                await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        balance: { increment: data.amount },\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });\r\n                let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             \r\n             } \r\n             // 2. Si es GASTO (Sacar del bolsillo diario para guardar): El balance total NO cambia (el dinero sigue en la cuenta), pero sube el BalanceSafe\r\n             // NOTA: Si el usuario quiere que \"salga\" de la cuenta, debería usar Transferencia. Asumimos que \"Gasto -> Es Ahorro\" es apartar dinero.\r\n             else if (data.type === 'expense') {\r\n                 /*await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        // No tocamos balance total porque el dinero no se ha ido del banco, solo cambió de \"estado\"\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });*/\r\n                // ---> NUEVA LÓGICA: RETIRO FÍSICO PARA AHORRO <---\r\n                 if (data.didWithdraw) {\r\n                     // a. Restamos de la cuenta origen (Banco)\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balance: { decrement: data.amount } } // Solo decrementa balance total, no balanceSafe, porque salió del banco\r\n                    });\r\n\r\n                    // b. Buscamos (o creamos) la cuenta \"Dinero Efectivo\"\r\n                    let cashAccount = await prisma.account.findFirst({ \r\n                        where: { householdId, name: 'Dinero Efectivo' } // Buscamos por nombre o tipo 'wallet'\r\n                    });\r\n\r\n                    if (!cashAccount) {\r\n                        cashAccount = await prisma.account.create({\r\n                            data: {\r\n                                householdId,\r\n                                name: 'Dinero Efectivo',\r\n                                bank: 'Efectivo',\r\n                                type: 'wallet',\r\n                                color: '#10b981',\r\n                                owner: 'Casa'\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    // c. Sumamos a \"Dinero Efectivo\" como Ahorro (BalanceSafe)\r\n                    // Aquí el dinero entra físicamente y se marca como reservado\r\n                    await prisma.account.update({\r\n                        where: { id: cashAccount.id },\r\n                        data: {\r\n                            balance: { increment: data.amount },\r\n                            balanceSafe: { increment: data.amount }\r\n                        }\r\n                    });\r\n\r\n                 } else {\r\n                     // ---> LÓGICA ANTIGUA: AHORRO VIRTUAL (No sale del banco) <---\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balanceSafe: { increment: data.amount } } \r\n                    });\r\n                 }\r\n\r\n                 // En AMBOS casos, el \"Ahorro Global\" (Espejo) aumenta\r\n                 let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                 if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n                 await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             }\r\n\r\n             \r\n        }\r\n\r\n        // C. CASO NORMAL (Gasto corriente o Ingreso corriente)\r\n        else {\r\n            const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n            if (shouldUpdateBalance) {\r\n                const multiplier = data.type === 'income' ? 1 : -1;\r\n                await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n            }\r\n        }\r\n\r\n        // Reglas Fijas y Crédito (Igual que antes)\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { householdId, description: data.description, categoryId: data.categoryId, budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || date.getDate(), isActive: true }\r\n            });\r\n        }\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');\r\n\r\n\r\n        // Lógica de Ahorro Global (Sumar o Restar)\r\n\r\n        /*\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n        if (data.payWithSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n        }\r\n\r\n        // Regla Fija\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { \r\n                    householdId, \r\n                    description: data.description, \r\n                    categoryId: data.categoryId, \r\n                    \r\n                    budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, \r\n                    accountIdToCharge: data.accountId, \r\n                    dayOfMonth: data.dayOfMonth || date.getDate(), \r\n                    isActive: true }\r\n            });\r\n        }\r\n\r\n\r\n        // --- CRÉDITO AUTOMÁTICO ---\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');*/\r\n}\r\n\r\n// Funciones CRUD estándar\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { id: data.id, name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, \r\n            description: data.description,\r\n            categoryId: data.categoryId,\r\n            accountIdToCharge: data.accountIdToCharge,\r\n            dayOfMonth: parseInt(data.dayOfMonth),householdId: user.householdId,budgetedAmount: parseFloat(data.budgetedAmount || '0'), staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null, isActive: true } }); revalidatePath('/admin'); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, \r\n            // Actualizamos ambos\r\n            //staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null,\r\n            budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId, name: 'Jhonattan' },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId, name: 'Jhonattan' }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId, name: 'Thannia' },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId, name: 'Thannia' }\r\n    });\r\n\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;IAqcsB,kBAAA,WAAA,GAAA,IAAA,oSAAA,EAAA,8CAAA,yRAAA,EAAA,KAAA,GAAA,+RAAA,EAAA"}},
    {"offset": {"line": 124, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\n\r\n// --- GLOBAL PRISMA ---\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    \r\n    // 1. Verificar firma del token\r\n    const payload = await verifyToken(token);\r\n    if (!payload) return null;\r\n    try {\r\n        const user = await prisma.user.findUnique({ \r\n            where: { id: payload.id as string } \r\n        });\r\n        // Si no se encuentra el usuario en BD, retornamos null (inválido)\r\n        return user; \r\n    } catch (error) {\r\n        console.log(error );\r\n        return null;\r\n    }\r\n\r\n    //return await verifyToken(token);\r\n}\r\n\r\n// --- CREAR USUARIO (Para el botón Admin) ---\r\nexport async function createNewUser(name: string, email: string, householdId: string) {\r\n    const currentUser = await getCurrentUser();\r\n    \r\n    // Validación de seguridad básica: Solo User Master puede crear usuarios\r\n    if (currentUser?.email !== process.env.GMAIL_USER) {\r\n        return { success: false, message: 'No autorizado' };\r\n    }\r\n\r\n    try {\r\n        const existing = await prisma.user.findUnique({ where: { email } });\r\n        if (existing) return { success: false, message: 'El usuario ya existe.' };\r\n        \r\n        const existinHouseHold = await prisma.user.findMany({ where: { householdId } });\r\n        console.log(\"existinHouseHold \", existinHouseHold);\r\n        if (!existinHouseHold){\r\n            await prisma.account.createMany({\r\n                data: [\r\n                    { name: 'Dinero Efectivo', bank: 'Efectivo', type: 'wallet', owner: name, color: '#25ab28ff', householdId: householdId },\r\n                    { name: 'Ahorro Global', bank: 'Ahorro', type: 'savings_virtual', owner: name, color: '#fba300ff', householdId: householdId } \r\n                ]\r\n            });    \r\n        } \r\n        \r\n        await prisma.user.create({\r\n            data: {\r\n                email,\r\n                name,\r\n                householdId,\r\n                token: 'INIT', // Token inicial placeholder\r\n              }\r\n          });\r\n        \r\n        revalidatePath('/admin');\r\n        return { success: true, message: 'Usuario creado exitosamente.' };\r\n    } catch (error) {\r\n        return { success: false, message: 'Error creando usuario en BD.' };\r\n    }\r\n    \r\n}\r\n\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@?!+_\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n    \r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    \r\n    if (!user || !user.token) return { success: false, message: 'Código incorrecto.' };\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO (SOLICITUD) ---\r\nexport async function requestRegistration(email: string, name: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        // Enviamos nombre, email y familia al correo\r\n        await sendRegistrationRequestEmail(email, name, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. Establecer cookie de Demo (Importante: path '/')\r\n    cookieStore.set('is_demo_mode', 'true', { \r\n        path: '/',\r\n        httpOnly: true,\r\n        maxAge: 60 * 60 * 24 // 1 día\r\n    });\r\n    \r\n    // 2. Borrar token anterior si existe para evitar conflictos\r\n    cookieStore.delete('auth_token');\r\n    \r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n\r\n    // --- DEMO DATA ---\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' },\r\n            unauthorized: false\r\n        };\r\n    }\r\n\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; \r\n    }\r\n\r\n    // --- USER DATA ---\r\n    const householdId = user.householdId; \r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({\r\n        where: { householdId },\r\n        // NO poner aquí un filtro solo para 'expense'. \r\n        // Si tienes filtros de tipo, deben incluir 'income' para que se vea la entrada de la transferencia.\r\n        orderBy: { date: 'desc' },\r\n        include: { \r\n            account: { select: { name: true, color: true } },\r\n            category: { select: { name: true } }\r\n        }\r\n    });\r\n\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user,\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES Y UPDATES TRANSACTIONS ---\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n    // 1. TRANSFERENCIA: CREA DOS MOVIMIENTOS\r\n    if (data.type === 'transfer') {\r\n        // Buscar/Crear categoría\r\n        let transferCat = await prisma.category.findFirst({ where: { householdId, name: 'Transferencia Propia' } });\r\n        if (!transferCat) {\r\n            transferCat = await prisma.category.create({ data: { householdId, name: 'Transferencia Propia', type: 'transfer', subCategories: JSON.stringify([]) } });\r\n        }\r\n\r\n        // A. SALIDA (Gasto - Cuenta Origen)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'expense', amount: data.amount, \r\n                accountId: data.accountId, \r\n                categoryId: transferCat.id, \r\n                description: `Transferencia a: ${data.destAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        // B. ENTRADA (Ingreso - Cuenta Destino)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'income', amount: data.amount, \r\n                accountId: data.relatedAccountId, \r\n                categoryId: transferCat.id, \r\n                description: `Recibido de: ${data.originAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } \r\n    \r\n    // 2. GASTO / INGRESO NORMAL\r\n    else {\r\n\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        \r\n        // --- GASTO NORMAL ---\r\n        await prisma.transaction.create({\r\n            data: { \r\n                householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount,\r\n                accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, \r\n                isFixed: data.isFixed || false, \r\n                isSavings: data.isSavings || false, \r\n                payWithSavings: data.payWithSavings || false,\r\n                didWithdraw: data.payWithSavings ? true : (data.didWithdraw ?? true)\r\n            }\r\n        });\r\n\r\n        /*if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }*/\r\n\r\n\r\n        \r\n        // --- LÓGICA DE SALDOS ---\r\n\r\n        // A. CASO \"GASTAR DE AHORRO\" (Expense + payWithSavings)\r\n        if (data.payWithSavings && data.type === 'expense') {\r\n            // Restamos del balance total Y del balanceSafe de la cuenta\r\n            await prisma.account.update({ \r\n                where: { id: data.accountId }, \r\n                data: { \r\n                    balance: { decrement: data.amount },\r\n                    balanceSafe: { decrement: data.amount } \r\n                } \r\n            });\r\n            // Restamos también del Ahorro Global (Cuenta Virtual)\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) {\r\n                await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n            }\r\n        }\r\n        \r\n        // B. CASO \"ES AHORRO\" (Guardar dinero)\r\n        else if (data.isSavings) {\r\n             // 1. Si es INGRESO y es ahorro: Sube Balance Total y Sube BalanceSafe\r\n             if (data.type === 'income') {\r\n                await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        balance: { increment: data.amount },\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });\r\n                let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             \r\n             } \r\n             // 2. Si es GASTO (Sacar del bolsillo diario para guardar): El balance total NO cambia (el dinero sigue en la cuenta), pero sube el BalanceSafe\r\n             // NOTA: Si el usuario quiere que \"salga\" de la cuenta, debería usar Transferencia. Asumimos que \"Gasto -> Es Ahorro\" es apartar dinero.\r\n             else if (data.type === 'expense') {\r\n                 /*await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        // No tocamos balance total porque el dinero no se ha ido del banco, solo cambió de \"estado\"\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });*/\r\n                // ---> NUEVA LÓGICA: RETIRO FÍSICO PARA AHORRO <---\r\n                 if (data.didWithdraw) {\r\n                     // a. Restamos de la cuenta origen (Banco)\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balance: { decrement: data.amount } } // Solo decrementa balance total, no balanceSafe, porque salió del banco\r\n                    });\r\n\r\n                    // b. Buscamos (o creamos) la cuenta \"Dinero Efectivo\"\r\n                    let cashAccount = await prisma.account.findFirst({ \r\n                        where: { householdId, name: 'Dinero Efectivo' } // Buscamos por nombre o tipo 'wallet'\r\n                    });\r\n\r\n                    if (!cashAccount) {\r\n                        cashAccount = await prisma.account.create({\r\n                            data: {\r\n                                householdId,\r\n                                name: 'Dinero Efectivo',\r\n                                bank: 'Efectivo',\r\n                                type: 'wallet',\r\n                                color: '#10b981',\r\n                                owner: 'Casa'\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    // c. Sumamos a \"Dinero Efectivo\" como Ahorro (BalanceSafe)\r\n                    // Aquí el dinero entra físicamente y se marca como reservado\r\n                    await prisma.account.update({\r\n                        where: { id: cashAccount.id },\r\n                        data: {\r\n                            balance: { increment: data.amount },\r\n                            balanceSafe: { increment: data.amount }\r\n                        }\r\n                    });\r\n\r\n                 } else {\r\n                     // ---> LÓGICA ANTIGUA: AHORRO VIRTUAL (No sale del banco) <---\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balanceSafe: { increment: data.amount } } \r\n                    });\r\n                 }\r\n\r\n                 // En AMBOS casos, el \"Ahorro Global\" (Espejo) aumenta\r\n                 let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                 if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n                 await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             }\r\n\r\n             \r\n        }\r\n\r\n        // C. CASO NORMAL (Gasto corriente o Ingreso corriente)\r\n        else {\r\n            const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n            if (shouldUpdateBalance) {\r\n                const multiplier = data.type === 'income' ? 1 : -1;\r\n                await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n            }\r\n        }\r\n\r\n        // Reglas Fijas y Crédito (Igual que antes)\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { householdId, description: data.description, categoryId: data.categoryId, budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || date.getDate(), isActive: true }\r\n            });\r\n        }\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');\r\n\r\n\r\n        // Lógica de Ahorro Global (Sumar o Restar)\r\n\r\n        /*\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n        if (data.payWithSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n        }\r\n\r\n        // Regla Fija\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { \r\n                    householdId, \r\n                    description: data.description, \r\n                    categoryId: data.categoryId, \r\n                    \r\n                    budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, \r\n                    accountIdToCharge: data.accountId, \r\n                    dayOfMonth: data.dayOfMonth || date.getDate(), \r\n                    isActive: true }\r\n            });\r\n        }\r\n\r\n\r\n        // --- CRÉDITO AUTOMÁTICO ---\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');*/\r\n}\r\n\r\n// Funciones CRUD estándar\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { id: data.id, name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, \r\n            description: data.description,\r\n            categoryId: data.categoryId,\r\n            accountIdToCharge: data.accountIdToCharge,\r\n            dayOfMonth: parseInt(data.dayOfMonth),householdId: user.householdId,budgetedAmount: parseFloat(data.budgetedAmount || '0'), staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null, isActive: true } }); revalidatePath('/admin'); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, \r\n            // Actualizamos ambos\r\n            //staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null,\r\n            budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId, name: 'Jhonattan' },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId, name: 'Jhonattan' }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId, name: 'Thannia' },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId, name: 'Thannia' }\r\n    });\r\n\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;IAkcsB,iBAAA,WAAA,GAAA,IAAA,oSAAA,EAAA,8CAAA,yRAAA,EAAA,KAAA,GAAA,+RAAA,EAAA"}},
    {"offset": {"line": 136, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\n\r\n// --- GLOBAL PRISMA ---\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    \r\n    // 1. Verificar firma del token\r\n    const payload = await verifyToken(token);\r\n    if (!payload) return null;\r\n    try {\r\n        const user = await prisma.user.findUnique({ \r\n            where: { id: payload.id as string } \r\n        });\r\n        // Si no se encuentra el usuario en BD, retornamos null (inválido)\r\n        return user; \r\n    } catch (error) {\r\n        console.log(error );\r\n        return null;\r\n    }\r\n\r\n    //return await verifyToken(token);\r\n}\r\n\r\n// --- CREAR USUARIO (Para el botón Admin) ---\r\nexport async function createNewUser(name: string, email: string, householdId: string) {\r\n    const currentUser = await getCurrentUser();\r\n    \r\n    // Validación de seguridad básica: Solo User Master puede crear usuarios\r\n    if (currentUser?.email !== process.env.GMAIL_USER) {\r\n        return { success: false, message: 'No autorizado' };\r\n    }\r\n\r\n    try {\r\n        const existing = await prisma.user.findUnique({ where: { email } });\r\n        if (existing) return { success: false, message: 'El usuario ya existe.' };\r\n        \r\n        const existinHouseHold = await prisma.user.findMany({ where: { householdId } });\r\n        console.log(\"existinHouseHold \", existinHouseHold);\r\n        if (!existinHouseHold){\r\n            await prisma.account.createMany({\r\n                data: [\r\n                    { name: 'Dinero Efectivo', bank: 'Efectivo', type: 'wallet', owner: name, color: '#25ab28ff', householdId: householdId },\r\n                    { name: 'Ahorro Global', bank: 'Ahorro', type: 'savings_virtual', owner: name, color: '#fba300ff', householdId: householdId } \r\n                ]\r\n            });    \r\n        } \r\n        \r\n        await prisma.user.create({\r\n            data: {\r\n                email,\r\n                name,\r\n                householdId,\r\n                token: 'INIT', // Token inicial placeholder\r\n              }\r\n          });\r\n        \r\n        revalidatePath('/admin');\r\n        return { success: true, message: 'Usuario creado exitosamente.' };\r\n    } catch (error) {\r\n        return { success: false, message: 'Error creando usuario en BD.' };\r\n    }\r\n    \r\n}\r\n\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@?!+_\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n    \r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    \r\n    if (!user || !user.token) return { success: false, message: 'Código incorrecto.' };\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO (SOLICITUD) ---\r\nexport async function requestRegistration(email: string, name: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        // Enviamos nombre, email y familia al correo\r\n        await sendRegistrationRequestEmail(email, name, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. Establecer cookie de Demo (Importante: path '/')\r\n    cookieStore.set('is_demo_mode', 'true', { \r\n        path: '/',\r\n        httpOnly: true,\r\n        maxAge: 60 * 60 * 24 // 1 día\r\n    });\r\n    \r\n    // 2. Borrar token anterior si existe para evitar conflictos\r\n    cookieStore.delete('auth_token');\r\n    \r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n\r\n    // --- DEMO DATA ---\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' },\r\n            unauthorized: false\r\n        };\r\n    }\r\n\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; \r\n    }\r\n\r\n    // --- USER DATA ---\r\n    const householdId = user.householdId; \r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({\r\n        where: { householdId },\r\n        // NO poner aquí un filtro solo para 'expense'. \r\n        // Si tienes filtros de tipo, deben incluir 'income' para que se vea la entrada de la transferencia.\r\n        orderBy: { date: 'desc' },\r\n        include: { \r\n            account: { select: { name: true, color: true } },\r\n            category: { select: { name: true } }\r\n        }\r\n    });\r\n\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user,\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES Y UPDATES TRANSACTIONS ---\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n    // 1. TRANSFERENCIA: CREA DOS MOVIMIENTOS\r\n    if (data.type === 'transfer') {\r\n        // Buscar/Crear categoría\r\n        let transferCat = await prisma.category.findFirst({ where: { householdId, name: 'Transferencia Propia' } });\r\n        if (!transferCat) {\r\n            transferCat = await prisma.category.create({ data: { householdId, name: 'Transferencia Propia', type: 'transfer', subCategories: JSON.stringify([]) } });\r\n        }\r\n\r\n        // A. SALIDA (Gasto - Cuenta Origen)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'expense', amount: data.amount, \r\n                accountId: data.accountId, \r\n                categoryId: transferCat.id, \r\n                description: `Transferencia a: ${data.destAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        // B. ENTRADA (Ingreso - Cuenta Destino)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'income', amount: data.amount, \r\n                accountId: data.relatedAccountId, \r\n                categoryId: transferCat.id, \r\n                description: `Recibido de: ${data.originAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } \r\n    \r\n    // 2. GASTO / INGRESO NORMAL\r\n    else {\r\n\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        \r\n        // --- GASTO NORMAL ---\r\n        await prisma.transaction.create({\r\n            data: { \r\n                householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount,\r\n                accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, \r\n                isFixed: data.isFixed || false, \r\n                isSavings: data.isSavings || false, \r\n                payWithSavings: data.payWithSavings || false,\r\n                didWithdraw: data.payWithSavings ? true : (data.didWithdraw ?? true)\r\n            }\r\n        });\r\n\r\n        /*if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }*/\r\n\r\n\r\n        \r\n        // --- LÓGICA DE SALDOS ---\r\n\r\n        // A. CASO \"GASTAR DE AHORRO\" (Expense + payWithSavings)\r\n        if (data.payWithSavings && data.type === 'expense') {\r\n            // Restamos del balance total Y del balanceSafe de la cuenta\r\n            await prisma.account.update({ \r\n                where: { id: data.accountId }, \r\n                data: { \r\n                    balance: { decrement: data.amount },\r\n                    balanceSafe: { decrement: data.amount } \r\n                } \r\n            });\r\n            // Restamos también del Ahorro Global (Cuenta Virtual)\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) {\r\n                await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n            }\r\n        }\r\n        \r\n        // B. CASO \"ES AHORRO\" (Guardar dinero)\r\n        else if (data.isSavings) {\r\n             // 1. Si es INGRESO y es ahorro: Sube Balance Total y Sube BalanceSafe\r\n             if (data.type === 'income') {\r\n                await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        balance: { increment: data.amount },\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });\r\n                let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             \r\n             } \r\n             // 2. Si es GASTO (Sacar del bolsillo diario para guardar): El balance total NO cambia (el dinero sigue en la cuenta), pero sube el BalanceSafe\r\n             // NOTA: Si el usuario quiere que \"salga\" de la cuenta, debería usar Transferencia. Asumimos que \"Gasto -> Es Ahorro\" es apartar dinero.\r\n             else if (data.type === 'expense') {\r\n                 /*await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        // No tocamos balance total porque el dinero no se ha ido del banco, solo cambió de \"estado\"\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });*/\r\n                // ---> NUEVA LÓGICA: RETIRO FÍSICO PARA AHORRO <---\r\n                 if (data.didWithdraw) {\r\n                     // a. Restamos de la cuenta origen (Banco)\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balance: { decrement: data.amount } } // Solo decrementa balance total, no balanceSafe, porque salió del banco\r\n                    });\r\n\r\n                    // b. Buscamos (o creamos) la cuenta \"Dinero Efectivo\"\r\n                    let cashAccount = await prisma.account.findFirst({ \r\n                        where: { householdId, name: 'Dinero Efectivo' } // Buscamos por nombre o tipo 'wallet'\r\n                    });\r\n\r\n                    if (!cashAccount) {\r\n                        cashAccount = await prisma.account.create({\r\n                            data: {\r\n                                householdId,\r\n                                name: 'Dinero Efectivo',\r\n                                bank: 'Efectivo',\r\n                                type: 'wallet',\r\n                                color: '#10b981',\r\n                                owner: 'Casa'\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    // c. Sumamos a \"Dinero Efectivo\" como Ahorro (BalanceSafe)\r\n                    // Aquí el dinero entra físicamente y se marca como reservado\r\n                    await prisma.account.update({\r\n                        where: { id: cashAccount.id },\r\n                        data: {\r\n                            balance: { increment: data.amount },\r\n                            balanceSafe: { increment: data.amount }\r\n                        }\r\n                    });\r\n\r\n                 } else {\r\n                     // ---> LÓGICA ANTIGUA: AHORRO VIRTUAL (No sale del banco) <---\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balanceSafe: { increment: data.amount } } \r\n                    });\r\n                 }\r\n\r\n                 // En AMBOS casos, el \"Ahorro Global\" (Espejo) aumenta\r\n                 let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                 if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n                 await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             }\r\n\r\n             \r\n        }\r\n\r\n        // C. CASO NORMAL (Gasto corriente o Ingreso corriente)\r\n        else {\r\n            const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n            if (shouldUpdateBalance) {\r\n                const multiplier = data.type === 'income' ? 1 : -1;\r\n                await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n            }\r\n        }\r\n\r\n        // Reglas Fijas y Crédito (Igual que antes)\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { householdId, description: data.description, categoryId: data.categoryId, budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || date.getDate(), isActive: true }\r\n            });\r\n        }\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');\r\n\r\n\r\n        // Lógica de Ahorro Global (Sumar o Restar)\r\n\r\n        /*\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n        if (data.payWithSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n        }\r\n\r\n        // Regla Fija\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { \r\n                    householdId, \r\n                    description: data.description, \r\n                    categoryId: data.categoryId, \r\n                    \r\n                    budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, \r\n                    accountIdToCharge: data.accountId, \r\n                    dayOfMonth: data.dayOfMonth || date.getDate(), \r\n                    isActive: true }\r\n            });\r\n        }\r\n\r\n\r\n        // --- CRÉDITO AUTOMÁTICO ---\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');*/\r\n}\r\n\r\n// Funciones CRUD estándar\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { id: data.id, name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, \r\n            description: data.description,\r\n            categoryId: data.categoryId,\r\n            accountIdToCharge: data.accountIdToCharge,\r\n            dayOfMonth: parseInt(data.dayOfMonth),householdId: user.householdId,budgetedAmount: parseFloat(data.budgetedAmount || '0'), staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null, isActive: true } }); revalidatePath('/admin'); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, \r\n            // Actualizamos ambos\r\n            //staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null,\r\n            budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId, name: 'Jhonattan' },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId, name: 'Jhonattan' }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId, name: 'Thannia' },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId, name: 'Thannia' }\r\n    });\r\n\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;IAmcsB,iBAAA,WAAA,GAAA,IAAA,oSAAA,EAAA,8CAAA,yRAAA,EAAA,KAAA,GAAA,+RAAA,EAAA"}},
    {"offset": {"line": 148, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\n\r\n// --- GLOBAL PRISMA ---\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    \r\n    // 1. Verificar firma del token\r\n    const payload = await verifyToken(token);\r\n    if (!payload) return null;\r\n    try {\r\n        const user = await prisma.user.findUnique({ \r\n            where: { id: payload.id as string } \r\n        });\r\n        // Si no se encuentra el usuario en BD, retornamos null (inválido)\r\n        return user; \r\n    } catch (error) {\r\n        console.log(error );\r\n        return null;\r\n    }\r\n\r\n    //return await verifyToken(token);\r\n}\r\n\r\n// --- CREAR USUARIO (Para el botón Admin) ---\r\nexport async function createNewUser(name: string, email: string, householdId: string) {\r\n    const currentUser = await getCurrentUser();\r\n    \r\n    // Validación de seguridad básica: Solo User Master puede crear usuarios\r\n    if (currentUser?.email !== process.env.GMAIL_USER) {\r\n        return { success: false, message: 'No autorizado' };\r\n    }\r\n\r\n    try {\r\n        const existing = await prisma.user.findUnique({ where: { email } });\r\n        if (existing) return { success: false, message: 'El usuario ya existe.' };\r\n        \r\n        const existinHouseHold = await prisma.user.findMany({ where: { householdId } });\r\n        console.log(\"existinHouseHold \", existinHouseHold);\r\n        if (!existinHouseHold){\r\n            await prisma.account.createMany({\r\n                data: [\r\n                    { name: 'Dinero Efectivo', bank: 'Efectivo', type: 'wallet', owner: name, color: '#25ab28ff', householdId: householdId },\r\n                    { name: 'Ahorro Global', bank: 'Ahorro', type: 'savings_virtual', owner: name, color: '#fba300ff', householdId: householdId } \r\n                ]\r\n            });    \r\n        } \r\n        \r\n        await prisma.user.create({\r\n            data: {\r\n                email,\r\n                name,\r\n                householdId,\r\n                token: 'INIT', // Token inicial placeholder\r\n              }\r\n          });\r\n        \r\n        revalidatePath('/admin');\r\n        return { success: true, message: 'Usuario creado exitosamente.' };\r\n    } catch (error) {\r\n        return { success: false, message: 'Error creando usuario en BD.' };\r\n    }\r\n    \r\n}\r\n\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@?!+_\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n    \r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    \r\n    if (!user || !user.token) return { success: false, message: 'Código incorrecto.' };\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO (SOLICITUD) ---\r\nexport async function requestRegistration(email: string, name: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        // Enviamos nombre, email y familia al correo\r\n        await sendRegistrationRequestEmail(email, name, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. Establecer cookie de Demo (Importante: path '/')\r\n    cookieStore.set('is_demo_mode', 'true', { \r\n        path: '/',\r\n        httpOnly: true,\r\n        maxAge: 60 * 60 * 24 // 1 día\r\n    });\r\n    \r\n    // 2. Borrar token anterior si existe para evitar conflictos\r\n    cookieStore.delete('auth_token');\r\n    \r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n\r\n    // --- DEMO DATA ---\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' },\r\n            unauthorized: false\r\n        };\r\n    }\r\n\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; \r\n    }\r\n\r\n    // --- USER DATA ---\r\n    const householdId = user.householdId; \r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({\r\n        where: { householdId },\r\n        // NO poner aquí un filtro solo para 'expense'. \r\n        // Si tienes filtros de tipo, deben incluir 'income' para que se vea la entrada de la transferencia.\r\n        orderBy: { date: 'desc' },\r\n        include: { \r\n            account: { select: { name: true, color: true } },\r\n            category: { select: { name: true } }\r\n        }\r\n    });\r\n\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user,\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES Y UPDATES TRANSACTIONS ---\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n    // 1. TRANSFERENCIA: CREA DOS MOVIMIENTOS\r\n    if (data.type === 'transfer') {\r\n        // Buscar/Crear categoría\r\n        let transferCat = await prisma.category.findFirst({ where: { householdId, name: 'Transferencia Propia' } });\r\n        if (!transferCat) {\r\n            transferCat = await prisma.category.create({ data: { householdId, name: 'Transferencia Propia', type: 'transfer', subCategories: JSON.stringify([]) } });\r\n        }\r\n\r\n        // A. SALIDA (Gasto - Cuenta Origen)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'expense', amount: data.amount, \r\n                accountId: data.accountId, \r\n                categoryId: transferCat.id, \r\n                description: `Transferencia a: ${data.destAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        // B. ENTRADA (Ingreso - Cuenta Destino)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'income', amount: data.amount, \r\n                accountId: data.relatedAccountId, \r\n                categoryId: transferCat.id, \r\n                description: `Recibido de: ${data.originAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } \r\n    \r\n    // 2. GASTO / INGRESO NORMAL\r\n    else {\r\n\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        \r\n        // --- GASTO NORMAL ---\r\n        await prisma.transaction.create({\r\n            data: { \r\n                householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount,\r\n                accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, \r\n                isFixed: data.isFixed || false, \r\n                isSavings: data.isSavings || false, \r\n                payWithSavings: data.payWithSavings || false,\r\n                didWithdraw: data.payWithSavings ? true : (data.didWithdraw ?? true)\r\n            }\r\n        });\r\n\r\n        /*if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }*/\r\n\r\n\r\n        \r\n        // --- LÓGICA DE SALDOS ---\r\n\r\n        // A. CASO \"GASTAR DE AHORRO\" (Expense + payWithSavings)\r\n        if (data.payWithSavings && data.type === 'expense') {\r\n            // Restamos del balance total Y del balanceSafe de la cuenta\r\n            await prisma.account.update({ \r\n                where: { id: data.accountId }, \r\n                data: { \r\n                    balance: { decrement: data.amount },\r\n                    balanceSafe: { decrement: data.amount } \r\n                } \r\n            });\r\n            // Restamos también del Ahorro Global (Cuenta Virtual)\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) {\r\n                await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n            }\r\n        }\r\n        \r\n        // B. CASO \"ES AHORRO\" (Guardar dinero)\r\n        else if (data.isSavings) {\r\n             // 1. Si es INGRESO y es ahorro: Sube Balance Total y Sube BalanceSafe\r\n             if (data.type === 'income') {\r\n                await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        balance: { increment: data.amount },\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });\r\n                let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             \r\n             } \r\n             // 2. Si es GASTO (Sacar del bolsillo diario para guardar): El balance total NO cambia (el dinero sigue en la cuenta), pero sube el BalanceSafe\r\n             // NOTA: Si el usuario quiere que \"salga\" de la cuenta, debería usar Transferencia. Asumimos que \"Gasto -> Es Ahorro\" es apartar dinero.\r\n             else if (data.type === 'expense') {\r\n                 /*await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        // No tocamos balance total porque el dinero no se ha ido del banco, solo cambió de \"estado\"\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });*/\r\n                // ---> NUEVA LÓGICA: RETIRO FÍSICO PARA AHORRO <---\r\n                 if (data.didWithdraw) {\r\n                     // a. Restamos de la cuenta origen (Banco)\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balance: { decrement: data.amount } } // Solo decrementa balance total, no balanceSafe, porque salió del banco\r\n                    });\r\n\r\n                    // b. Buscamos (o creamos) la cuenta \"Dinero Efectivo\"\r\n                    let cashAccount = await prisma.account.findFirst({ \r\n                        where: { householdId, name: 'Dinero Efectivo' } // Buscamos por nombre o tipo 'wallet'\r\n                    });\r\n\r\n                    if (!cashAccount) {\r\n                        cashAccount = await prisma.account.create({\r\n                            data: {\r\n                                householdId,\r\n                                name: 'Dinero Efectivo',\r\n                                bank: 'Efectivo',\r\n                                type: 'wallet',\r\n                                color: '#10b981',\r\n                                owner: 'Casa'\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    // c. Sumamos a \"Dinero Efectivo\" como Ahorro (BalanceSafe)\r\n                    // Aquí el dinero entra físicamente y se marca como reservado\r\n                    await prisma.account.update({\r\n                        where: { id: cashAccount.id },\r\n                        data: {\r\n                            balance: { increment: data.amount },\r\n                            balanceSafe: { increment: data.amount }\r\n                        }\r\n                    });\r\n\r\n                 } else {\r\n                     // ---> LÓGICA ANTIGUA: AHORRO VIRTUAL (No sale del banco) <---\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balanceSafe: { increment: data.amount } } \r\n                    });\r\n                 }\r\n\r\n                 // En AMBOS casos, el \"Ahorro Global\" (Espejo) aumenta\r\n                 let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                 if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n                 await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             }\r\n\r\n             \r\n        }\r\n\r\n        // C. CASO NORMAL (Gasto corriente o Ingreso corriente)\r\n        else {\r\n            const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n            if (shouldUpdateBalance) {\r\n                const multiplier = data.type === 'income' ? 1 : -1;\r\n                await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n            }\r\n        }\r\n\r\n        // Reglas Fijas y Crédito (Igual que antes)\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { householdId, description: data.description, categoryId: data.categoryId, budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || date.getDate(), isActive: true }\r\n            });\r\n        }\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');\r\n\r\n\r\n        // Lógica de Ahorro Global (Sumar o Restar)\r\n\r\n        /*\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n        if (data.payWithSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n        }\r\n\r\n        // Regla Fija\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { \r\n                    householdId, \r\n                    description: data.description, \r\n                    categoryId: data.categoryId, \r\n                    \r\n                    budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, \r\n                    accountIdToCharge: data.accountId, \r\n                    dayOfMonth: data.dayOfMonth || date.getDate(), \r\n                    isActive: true }\r\n            });\r\n        }\r\n\r\n\r\n        // --- CRÉDITO AUTOMÁTICO ---\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');*/\r\n}\r\n\r\n// Funciones CRUD estándar\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { id: data.id, name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, \r\n            description: data.description,\r\n            categoryId: data.categoryId,\r\n            accountIdToCharge: data.accountIdToCharge,\r\n            dayOfMonth: parseInt(data.dayOfMonth),householdId: user.householdId,budgetedAmount: parseFloat(data.budgetedAmount || '0'), staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null, isActive: true } }); revalidatePath('/admin'); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, \r\n            // Actualizamos ambos\r\n            //staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null,\r\n            budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId, name: 'Jhonattan' },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId, name: 'Jhonattan' }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId, name: 'Thannia' },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId, name: 'Thannia' }\r\n    });\r\n\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;IAocsB,oBAAA,WAAA,GAAA,IAAA,oSAAA,EAAA,8CAAA,yRAAA,EAAA,KAAA,GAAA,+RAAA,EAAA"}},
    {"offset": {"line": 160, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\n\r\n// --- GLOBAL PRISMA ---\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    \r\n    // 1. Verificar firma del token\r\n    const payload = await verifyToken(token);\r\n    if (!payload) return null;\r\n    try {\r\n        const user = await prisma.user.findUnique({ \r\n            where: { id: payload.id as string } \r\n        });\r\n        // Si no se encuentra el usuario en BD, retornamos null (inválido)\r\n        return user; \r\n    } catch (error) {\r\n        console.log(error );\r\n        return null;\r\n    }\r\n\r\n    //return await verifyToken(token);\r\n}\r\n\r\n// --- CREAR USUARIO (Para el botón Admin) ---\r\nexport async function createNewUser(name: string, email: string, householdId: string) {\r\n    const currentUser = await getCurrentUser();\r\n    \r\n    // Validación de seguridad básica: Solo User Master puede crear usuarios\r\n    if (currentUser?.email !== process.env.GMAIL_USER) {\r\n        return { success: false, message: 'No autorizado' };\r\n    }\r\n\r\n    try {\r\n        const existing = await prisma.user.findUnique({ where: { email } });\r\n        if (existing) return { success: false, message: 'El usuario ya existe.' };\r\n        \r\n        const existinHouseHold = await prisma.user.findMany({ where: { householdId } });\r\n        console.log(\"existinHouseHold \", existinHouseHold);\r\n        if (!existinHouseHold){\r\n            await prisma.account.createMany({\r\n                data: [\r\n                    { name: 'Dinero Efectivo', bank: 'Efectivo', type: 'wallet', owner: name, color: '#25ab28ff', householdId: householdId },\r\n                    { name: 'Ahorro Global', bank: 'Ahorro', type: 'savings_virtual', owner: name, color: '#fba300ff', householdId: householdId } \r\n                ]\r\n            });    \r\n        } \r\n        \r\n        await prisma.user.create({\r\n            data: {\r\n                email,\r\n                name,\r\n                householdId,\r\n                token: 'INIT', // Token inicial placeholder\r\n              }\r\n          });\r\n        \r\n        revalidatePath('/admin');\r\n        return { success: true, message: 'Usuario creado exitosamente.' };\r\n    } catch (error) {\r\n        return { success: false, message: 'Error creando usuario en BD.' };\r\n    }\r\n    \r\n}\r\n\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@?!+_\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n    \r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    \r\n    if (!user || !user.token) return { success: false, message: 'Código incorrecto.' };\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO (SOLICITUD) ---\r\nexport async function requestRegistration(email: string, name: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        // Enviamos nombre, email y familia al correo\r\n        await sendRegistrationRequestEmail(email, name, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. Establecer cookie de Demo (Importante: path '/')\r\n    cookieStore.set('is_demo_mode', 'true', { \r\n        path: '/',\r\n        httpOnly: true,\r\n        maxAge: 60 * 60 * 24 // 1 día\r\n    });\r\n    \r\n    // 2. Borrar token anterior si existe para evitar conflictos\r\n    cookieStore.delete('auth_token');\r\n    \r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n\r\n    // --- DEMO DATA ---\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' },\r\n            unauthorized: false\r\n        };\r\n    }\r\n\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; \r\n    }\r\n\r\n    // --- USER DATA ---\r\n    const householdId = user.householdId; \r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({\r\n        where: { householdId },\r\n        // NO poner aquí un filtro solo para 'expense'. \r\n        // Si tienes filtros de tipo, deben incluir 'income' para que se vea la entrada de la transferencia.\r\n        orderBy: { date: 'desc' },\r\n        include: { \r\n            account: { select: { name: true, color: true } },\r\n            category: { select: { name: true } }\r\n        }\r\n    });\r\n\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user,\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES Y UPDATES TRANSACTIONS ---\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n    // 1. TRANSFERENCIA: CREA DOS MOVIMIENTOS\r\n    if (data.type === 'transfer') {\r\n        // Buscar/Crear categoría\r\n        let transferCat = await prisma.category.findFirst({ where: { householdId, name: 'Transferencia Propia' } });\r\n        if (!transferCat) {\r\n            transferCat = await prisma.category.create({ data: { householdId, name: 'Transferencia Propia', type: 'transfer', subCategories: JSON.stringify([]) } });\r\n        }\r\n\r\n        // A. SALIDA (Gasto - Cuenta Origen)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'expense', amount: data.amount, \r\n                accountId: data.accountId, \r\n                categoryId: transferCat.id, \r\n                description: `Transferencia a: ${data.destAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        // B. ENTRADA (Ingreso - Cuenta Destino)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'income', amount: data.amount, \r\n                accountId: data.relatedAccountId, \r\n                categoryId: transferCat.id, \r\n                description: `Recibido de: ${data.originAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } \r\n    \r\n    // 2. GASTO / INGRESO NORMAL\r\n    else {\r\n\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        \r\n        // --- GASTO NORMAL ---\r\n        await prisma.transaction.create({\r\n            data: { \r\n                householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount,\r\n                accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, \r\n                isFixed: data.isFixed || false, \r\n                isSavings: data.isSavings || false, \r\n                payWithSavings: data.payWithSavings || false,\r\n                didWithdraw: data.payWithSavings ? true : (data.didWithdraw ?? true)\r\n            }\r\n        });\r\n\r\n        /*if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }*/\r\n\r\n\r\n        \r\n        // --- LÓGICA DE SALDOS ---\r\n\r\n        // A. CASO \"GASTAR DE AHORRO\" (Expense + payWithSavings)\r\n        if (data.payWithSavings && data.type === 'expense') {\r\n            // Restamos del balance total Y del balanceSafe de la cuenta\r\n            await prisma.account.update({ \r\n                where: { id: data.accountId }, \r\n                data: { \r\n                    balance: { decrement: data.amount },\r\n                    balanceSafe: { decrement: data.amount } \r\n                } \r\n            });\r\n            // Restamos también del Ahorro Global (Cuenta Virtual)\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) {\r\n                await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n            }\r\n        }\r\n        \r\n        // B. CASO \"ES AHORRO\" (Guardar dinero)\r\n        else if (data.isSavings) {\r\n             // 1. Si es INGRESO y es ahorro: Sube Balance Total y Sube BalanceSafe\r\n             if (data.type === 'income') {\r\n                await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        balance: { increment: data.amount },\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });\r\n                let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             \r\n             } \r\n             // 2. Si es GASTO (Sacar del bolsillo diario para guardar): El balance total NO cambia (el dinero sigue en la cuenta), pero sube el BalanceSafe\r\n             // NOTA: Si el usuario quiere que \"salga\" de la cuenta, debería usar Transferencia. Asumimos que \"Gasto -> Es Ahorro\" es apartar dinero.\r\n             else if (data.type === 'expense') {\r\n                 /*await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        // No tocamos balance total porque el dinero no se ha ido del banco, solo cambió de \"estado\"\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });*/\r\n                // ---> NUEVA LÓGICA: RETIRO FÍSICO PARA AHORRO <---\r\n                 if (data.didWithdraw) {\r\n                     // a. Restamos de la cuenta origen (Banco)\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balance: { decrement: data.amount } } // Solo decrementa balance total, no balanceSafe, porque salió del banco\r\n                    });\r\n\r\n                    // b. Buscamos (o creamos) la cuenta \"Dinero Efectivo\"\r\n                    let cashAccount = await prisma.account.findFirst({ \r\n                        where: { householdId, name: 'Dinero Efectivo' } // Buscamos por nombre o tipo 'wallet'\r\n                    });\r\n\r\n                    if (!cashAccount) {\r\n                        cashAccount = await prisma.account.create({\r\n                            data: {\r\n                                householdId,\r\n                                name: 'Dinero Efectivo',\r\n                                bank: 'Efectivo',\r\n                                type: 'wallet',\r\n                                color: '#10b981',\r\n                                owner: 'Casa'\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    // c. Sumamos a \"Dinero Efectivo\" como Ahorro (BalanceSafe)\r\n                    // Aquí el dinero entra físicamente y se marca como reservado\r\n                    await prisma.account.update({\r\n                        where: { id: cashAccount.id },\r\n                        data: {\r\n                            balance: { increment: data.amount },\r\n                            balanceSafe: { increment: data.amount }\r\n                        }\r\n                    });\r\n\r\n                 } else {\r\n                     // ---> LÓGICA ANTIGUA: AHORRO VIRTUAL (No sale del banco) <---\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balanceSafe: { increment: data.amount } } \r\n                    });\r\n                 }\r\n\r\n                 // En AMBOS casos, el \"Ahorro Global\" (Espejo) aumenta\r\n                 let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                 if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n                 await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             }\r\n\r\n             \r\n        }\r\n\r\n        // C. CASO NORMAL (Gasto corriente o Ingreso corriente)\r\n        else {\r\n            const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n            if (shouldUpdateBalance) {\r\n                const multiplier = data.type === 'income' ? 1 : -1;\r\n                await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n            }\r\n        }\r\n\r\n        // Reglas Fijas y Crédito (Igual que antes)\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { householdId, description: data.description, categoryId: data.categoryId, budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || date.getDate(), isActive: true }\r\n            });\r\n        }\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');\r\n\r\n\r\n        // Lógica de Ahorro Global (Sumar o Restar)\r\n\r\n        /*\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n        if (data.payWithSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n        }\r\n\r\n        // Regla Fija\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { \r\n                    householdId, \r\n                    description: data.description, \r\n                    categoryId: data.categoryId, \r\n                    \r\n                    budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, \r\n                    accountIdToCharge: data.accountId, \r\n                    dayOfMonth: data.dayOfMonth || date.getDate(), \r\n                    isActive: true }\r\n            });\r\n        }\r\n\r\n\r\n        // --- CRÉDITO AUTOMÁTICO ---\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');*/\r\n}\r\n\r\n// Funciones CRUD estándar\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { id: data.id, name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, \r\n            description: data.description,\r\n            categoryId: data.categoryId,\r\n            accountIdToCharge: data.accountIdToCharge,\r\n            dayOfMonth: parseInt(data.dayOfMonth),householdId: user.householdId,budgetedAmount: parseFloat(data.budgetedAmount || '0'), staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null, isActive: true } }); revalidatePath('/admin'); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, \r\n            // Actualizamos ambos\r\n            //staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null,\r\n            budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId, name: 'Jhonattan' },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId, name: 'Jhonattan' }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId, name: 'Thannia' },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId, name: 'Thannia' }\r\n    });\r\n\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;IAgcsB,gBAAA,WAAA,GAAA,IAAA,oSAAA,EAAA,8CAAA,yRAAA,EAAA,KAAA,GAAA,+RAAA,EAAA"}},
    {"offset": {"line": 172, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\n\r\n// --- GLOBAL PRISMA ---\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    \r\n    // 1. Verificar firma del token\r\n    const payload = await verifyToken(token);\r\n    if (!payload) return null;\r\n    try {\r\n        const user = await prisma.user.findUnique({ \r\n            where: { id: payload.id as string } \r\n        });\r\n        // Si no se encuentra el usuario en BD, retornamos null (inválido)\r\n        return user; \r\n    } catch (error) {\r\n        console.log(error );\r\n        return null;\r\n    }\r\n\r\n    //return await verifyToken(token);\r\n}\r\n\r\n// --- CREAR USUARIO (Para el botón Admin) ---\r\nexport async function createNewUser(name: string, email: string, householdId: string) {\r\n    const currentUser = await getCurrentUser();\r\n    \r\n    // Validación de seguridad básica: Solo User Master puede crear usuarios\r\n    if (currentUser?.email !== process.env.GMAIL_USER) {\r\n        return { success: false, message: 'No autorizado' };\r\n    }\r\n\r\n    try {\r\n        const existing = await prisma.user.findUnique({ where: { email } });\r\n        if (existing) return { success: false, message: 'El usuario ya existe.' };\r\n        \r\n        const existinHouseHold = await prisma.user.findMany({ where: { householdId } });\r\n        console.log(\"existinHouseHold \", existinHouseHold);\r\n        if (!existinHouseHold){\r\n            await prisma.account.createMany({\r\n                data: [\r\n                    { name: 'Dinero Efectivo', bank: 'Efectivo', type: 'wallet', owner: name, color: '#25ab28ff', householdId: householdId },\r\n                    { name: 'Ahorro Global', bank: 'Ahorro', type: 'savings_virtual', owner: name, color: '#fba300ff', householdId: householdId } \r\n                ]\r\n            });    \r\n        } \r\n        \r\n        await prisma.user.create({\r\n            data: {\r\n                email,\r\n                name,\r\n                householdId,\r\n                token: 'INIT', // Token inicial placeholder\r\n              }\r\n          });\r\n        \r\n        revalidatePath('/admin');\r\n        return { success: true, message: 'Usuario creado exitosamente.' };\r\n    } catch (error) {\r\n        return { success: false, message: 'Error creando usuario en BD.' };\r\n    }\r\n    \r\n}\r\n\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@?!+_\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n    \r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    \r\n    if (!user || !user.token) return { success: false, message: 'Código incorrecto.' };\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO (SOLICITUD) ---\r\nexport async function requestRegistration(email: string, name: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        // Enviamos nombre, email y familia al correo\r\n        await sendRegistrationRequestEmail(email, name, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. Establecer cookie de Demo (Importante: path '/')\r\n    cookieStore.set('is_demo_mode', 'true', { \r\n        path: '/',\r\n        httpOnly: true,\r\n        maxAge: 60 * 60 * 24 // 1 día\r\n    });\r\n    \r\n    // 2. Borrar token anterior si existe para evitar conflictos\r\n    cookieStore.delete('auth_token');\r\n    \r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n\r\n    // --- DEMO DATA ---\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' },\r\n            unauthorized: false\r\n        };\r\n    }\r\n\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; \r\n    }\r\n\r\n    // --- USER DATA ---\r\n    const householdId = user.householdId; \r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({\r\n        where: { householdId },\r\n        // NO poner aquí un filtro solo para 'expense'. \r\n        // Si tienes filtros de tipo, deben incluir 'income' para que se vea la entrada de la transferencia.\r\n        orderBy: { date: 'desc' },\r\n        include: { \r\n            account: { select: { name: true, color: true } },\r\n            category: { select: { name: true } }\r\n        }\r\n    });\r\n\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user,\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES Y UPDATES TRANSACTIONS ---\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n    // 1. TRANSFERENCIA: CREA DOS MOVIMIENTOS\r\n    if (data.type === 'transfer') {\r\n        // Buscar/Crear categoría\r\n        let transferCat = await prisma.category.findFirst({ where: { householdId, name: 'Transferencia Propia' } });\r\n        if (!transferCat) {\r\n            transferCat = await prisma.category.create({ data: { householdId, name: 'Transferencia Propia', type: 'transfer', subCategories: JSON.stringify([]) } });\r\n        }\r\n\r\n        // A. SALIDA (Gasto - Cuenta Origen)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'expense', amount: data.amount, \r\n                accountId: data.accountId, \r\n                categoryId: transferCat.id, \r\n                description: `Transferencia a: ${data.destAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        // B. ENTRADA (Ingreso - Cuenta Destino)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'income', amount: data.amount, \r\n                accountId: data.relatedAccountId, \r\n                categoryId: transferCat.id, \r\n                description: `Recibido de: ${data.originAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } \r\n    \r\n    // 2. GASTO / INGRESO NORMAL\r\n    else {\r\n\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        \r\n        // --- GASTO NORMAL ---\r\n        await prisma.transaction.create({\r\n            data: { \r\n                householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount,\r\n                accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, \r\n                isFixed: data.isFixed || false, \r\n                isSavings: data.isSavings || false, \r\n                payWithSavings: data.payWithSavings || false,\r\n                didWithdraw: data.payWithSavings ? true : (data.didWithdraw ?? true)\r\n            }\r\n        });\r\n\r\n        /*if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }*/\r\n\r\n\r\n        \r\n        // --- LÓGICA DE SALDOS ---\r\n\r\n        // A. CASO \"GASTAR DE AHORRO\" (Expense + payWithSavings)\r\n        if (data.payWithSavings && data.type === 'expense') {\r\n            // Restamos del balance total Y del balanceSafe de la cuenta\r\n            await prisma.account.update({ \r\n                where: { id: data.accountId }, \r\n                data: { \r\n                    balance: { decrement: data.amount },\r\n                    balanceSafe: { decrement: data.amount } \r\n                } \r\n            });\r\n            // Restamos también del Ahorro Global (Cuenta Virtual)\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) {\r\n                await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n            }\r\n        }\r\n        \r\n        // B. CASO \"ES AHORRO\" (Guardar dinero)\r\n        else if (data.isSavings) {\r\n             // 1. Si es INGRESO y es ahorro: Sube Balance Total y Sube BalanceSafe\r\n             if (data.type === 'income') {\r\n                await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        balance: { increment: data.amount },\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });\r\n                let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             \r\n             } \r\n             // 2. Si es GASTO (Sacar del bolsillo diario para guardar): El balance total NO cambia (el dinero sigue en la cuenta), pero sube el BalanceSafe\r\n             // NOTA: Si el usuario quiere que \"salga\" de la cuenta, debería usar Transferencia. Asumimos que \"Gasto -> Es Ahorro\" es apartar dinero.\r\n             else if (data.type === 'expense') {\r\n                 /*await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        // No tocamos balance total porque el dinero no se ha ido del banco, solo cambió de \"estado\"\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });*/\r\n                // ---> NUEVA LÓGICA: RETIRO FÍSICO PARA AHORRO <---\r\n                 if (data.didWithdraw) {\r\n                     // a. Restamos de la cuenta origen (Banco)\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balance: { decrement: data.amount } } // Solo decrementa balance total, no balanceSafe, porque salió del banco\r\n                    });\r\n\r\n                    // b. Buscamos (o creamos) la cuenta \"Dinero Efectivo\"\r\n                    let cashAccount = await prisma.account.findFirst({ \r\n                        where: { householdId, name: 'Dinero Efectivo' } // Buscamos por nombre o tipo 'wallet'\r\n                    });\r\n\r\n                    if (!cashAccount) {\r\n                        cashAccount = await prisma.account.create({\r\n                            data: {\r\n                                householdId,\r\n                                name: 'Dinero Efectivo',\r\n                                bank: 'Efectivo',\r\n                                type: 'wallet',\r\n                                color: '#10b981',\r\n                                owner: 'Casa'\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    // c. Sumamos a \"Dinero Efectivo\" como Ahorro (BalanceSafe)\r\n                    // Aquí el dinero entra físicamente y se marca como reservado\r\n                    await prisma.account.update({\r\n                        where: { id: cashAccount.id },\r\n                        data: {\r\n                            balance: { increment: data.amount },\r\n                            balanceSafe: { increment: data.amount }\r\n                        }\r\n                    });\r\n\r\n                 } else {\r\n                     // ---> LÓGICA ANTIGUA: AHORRO VIRTUAL (No sale del banco) <---\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balanceSafe: { increment: data.amount } } \r\n                    });\r\n                 }\r\n\r\n                 // En AMBOS casos, el \"Ahorro Global\" (Espejo) aumenta\r\n                 let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                 if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n                 await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             }\r\n\r\n             \r\n        }\r\n\r\n        // C. CASO NORMAL (Gasto corriente o Ingreso corriente)\r\n        else {\r\n            const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n            if (shouldUpdateBalance) {\r\n                const multiplier = data.type === 'income' ? 1 : -1;\r\n                await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n            }\r\n        }\r\n\r\n        // Reglas Fijas y Crédito (Igual que antes)\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { householdId, description: data.description, categoryId: data.categoryId, budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || date.getDate(), isActive: true }\r\n            });\r\n        }\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');\r\n\r\n\r\n        // Lógica de Ahorro Global (Sumar o Restar)\r\n\r\n        /*\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n        if (data.payWithSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n        }\r\n\r\n        // Regla Fija\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { \r\n                    householdId, \r\n                    description: data.description, \r\n                    categoryId: data.categoryId, \r\n                    \r\n                    budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, \r\n                    accountIdToCharge: data.accountId, \r\n                    dayOfMonth: data.dayOfMonth || date.getDate(), \r\n                    isActive: true }\r\n            });\r\n        }\r\n\r\n\r\n        // --- CRÉDITO AUTOMÁTICO ---\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');*/\r\n}\r\n\r\n// Funciones CRUD estándar\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { id: data.id, name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, \r\n            description: data.description,\r\n            categoryId: data.categoryId,\r\n            accountIdToCharge: data.accountIdToCharge,\r\n            dayOfMonth: parseInt(data.dayOfMonth),householdId: user.householdId,budgetedAmount: parseFloat(data.budgetedAmount || '0'), staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null, isActive: true } }); revalidatePath('/admin'); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, \r\n            // Actualizamos ambos\r\n            //staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null,\r\n            budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId, name: 'Jhonattan' },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId, name: 'Jhonattan' }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId, name: 'Thannia' },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId, name: 'Thannia' }\r\n    });\r\n\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;IA0csB,kBAAA,WAAA,GAAA,IAAA,oSAAA,EAAA,8CAAA,yRAAA,EAAA,KAAA,GAAA,+RAAA,EAAA"}},
    {"offset": {"line": 184, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\n\r\n// --- GLOBAL PRISMA ---\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    \r\n    // 1. Verificar firma del token\r\n    const payload = await verifyToken(token);\r\n    if (!payload) return null;\r\n    try {\r\n        const user = await prisma.user.findUnique({ \r\n            where: { id: payload.id as string } \r\n        });\r\n        // Si no se encuentra el usuario en BD, retornamos null (inválido)\r\n        return user; \r\n    } catch (error) {\r\n        console.log(error );\r\n        return null;\r\n    }\r\n\r\n    //return await verifyToken(token);\r\n}\r\n\r\n// --- CREAR USUARIO (Para el botón Admin) ---\r\nexport async function createNewUser(name: string, email: string, householdId: string) {\r\n    const currentUser = await getCurrentUser();\r\n    \r\n    // Validación de seguridad básica: Solo User Master puede crear usuarios\r\n    if (currentUser?.email !== process.env.GMAIL_USER) {\r\n        return { success: false, message: 'No autorizado' };\r\n    }\r\n\r\n    try {\r\n        const existing = await prisma.user.findUnique({ where: { email } });\r\n        if (existing) return { success: false, message: 'El usuario ya existe.' };\r\n        \r\n        const existinHouseHold = await prisma.user.findMany({ where: { householdId } });\r\n        console.log(\"existinHouseHold \", existinHouseHold);\r\n        if (!existinHouseHold){\r\n            await prisma.account.createMany({\r\n                data: [\r\n                    { name: 'Dinero Efectivo', bank: 'Efectivo', type: 'wallet', owner: name, color: '#25ab28ff', householdId: householdId },\r\n                    { name: 'Ahorro Global', bank: 'Ahorro', type: 'savings_virtual', owner: name, color: '#fba300ff', householdId: householdId } \r\n                ]\r\n            });    \r\n        } \r\n        \r\n        await prisma.user.create({\r\n            data: {\r\n                email,\r\n                name,\r\n                householdId,\r\n                token: 'INIT', // Token inicial placeholder\r\n              }\r\n          });\r\n        \r\n        revalidatePath('/admin');\r\n        return { success: true, message: 'Usuario creado exitosamente.' };\r\n    } catch (error) {\r\n        return { success: false, message: 'Error creando usuario en BD.' };\r\n    }\r\n    \r\n}\r\n\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@?!+_\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n    \r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    \r\n    if (!user || !user.token) return { success: false, message: 'Código incorrecto.' };\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO (SOLICITUD) ---\r\nexport async function requestRegistration(email: string, name: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        // Enviamos nombre, email y familia al correo\r\n        await sendRegistrationRequestEmail(email, name, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. Establecer cookie de Demo (Importante: path '/')\r\n    cookieStore.set('is_demo_mode', 'true', { \r\n        path: '/',\r\n        httpOnly: true,\r\n        maxAge: 60 * 60 * 24 // 1 día\r\n    });\r\n    \r\n    // 2. Borrar token anterior si existe para evitar conflictos\r\n    cookieStore.delete('auth_token');\r\n    \r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n\r\n    // --- DEMO DATA ---\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' },\r\n            unauthorized: false\r\n        };\r\n    }\r\n\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; \r\n    }\r\n\r\n    // --- USER DATA ---\r\n    const householdId = user.householdId; \r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({\r\n        where: { householdId },\r\n        // NO poner aquí un filtro solo para 'expense'. \r\n        // Si tienes filtros de tipo, deben incluir 'income' para que se vea la entrada de la transferencia.\r\n        orderBy: { date: 'desc' },\r\n        include: { \r\n            account: { select: { name: true, color: true } },\r\n            category: { select: { name: true } }\r\n        }\r\n    });\r\n\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user,\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES Y UPDATES TRANSACTIONS ---\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n    // 1. TRANSFERENCIA: CREA DOS MOVIMIENTOS\r\n    if (data.type === 'transfer') {\r\n        // Buscar/Crear categoría\r\n        let transferCat = await prisma.category.findFirst({ where: { householdId, name: 'Transferencia Propia' } });\r\n        if (!transferCat) {\r\n            transferCat = await prisma.category.create({ data: { householdId, name: 'Transferencia Propia', type: 'transfer', subCategories: JSON.stringify([]) } });\r\n        }\r\n\r\n        // A. SALIDA (Gasto - Cuenta Origen)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'expense', amount: data.amount, \r\n                accountId: data.accountId, \r\n                categoryId: transferCat.id, \r\n                description: `Transferencia a: ${data.destAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        // B. ENTRADA (Ingreso - Cuenta Destino)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'income', amount: data.amount, \r\n                accountId: data.relatedAccountId, \r\n                categoryId: transferCat.id, \r\n                description: `Recibido de: ${data.originAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } \r\n    \r\n    // 2. GASTO / INGRESO NORMAL\r\n    else {\r\n\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        \r\n        // --- GASTO NORMAL ---\r\n        await prisma.transaction.create({\r\n            data: { \r\n                householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount,\r\n                accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, \r\n                isFixed: data.isFixed || false, \r\n                isSavings: data.isSavings || false, \r\n                payWithSavings: data.payWithSavings || false,\r\n                didWithdraw: data.payWithSavings ? true : (data.didWithdraw ?? true)\r\n            }\r\n        });\r\n\r\n        /*if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }*/\r\n\r\n\r\n        \r\n        // --- LÓGICA DE SALDOS ---\r\n\r\n        // A. CASO \"GASTAR DE AHORRO\" (Expense + payWithSavings)\r\n        if (data.payWithSavings && data.type === 'expense') {\r\n            // Restamos del balance total Y del balanceSafe de la cuenta\r\n            await prisma.account.update({ \r\n                where: { id: data.accountId }, \r\n                data: { \r\n                    balance: { decrement: data.amount },\r\n                    balanceSafe: { decrement: data.amount } \r\n                } \r\n            });\r\n            // Restamos también del Ahorro Global (Cuenta Virtual)\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) {\r\n                await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n            }\r\n        }\r\n        \r\n        // B. CASO \"ES AHORRO\" (Guardar dinero)\r\n        else if (data.isSavings) {\r\n             // 1. Si es INGRESO y es ahorro: Sube Balance Total y Sube BalanceSafe\r\n             if (data.type === 'income') {\r\n                await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        balance: { increment: data.amount },\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });\r\n                let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             \r\n             } \r\n             // 2. Si es GASTO (Sacar del bolsillo diario para guardar): El balance total NO cambia (el dinero sigue en la cuenta), pero sube el BalanceSafe\r\n             // NOTA: Si el usuario quiere que \"salga\" de la cuenta, debería usar Transferencia. Asumimos que \"Gasto -> Es Ahorro\" es apartar dinero.\r\n             else if (data.type === 'expense') {\r\n                 /*await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        // No tocamos balance total porque el dinero no se ha ido del banco, solo cambió de \"estado\"\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });*/\r\n                // ---> NUEVA LÓGICA: RETIRO FÍSICO PARA AHORRO <---\r\n                 if (data.didWithdraw) {\r\n                     // a. Restamos de la cuenta origen (Banco)\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balance: { decrement: data.amount } } // Solo decrementa balance total, no balanceSafe, porque salió del banco\r\n                    });\r\n\r\n                    // b. Buscamos (o creamos) la cuenta \"Dinero Efectivo\"\r\n                    let cashAccount = await prisma.account.findFirst({ \r\n                        where: { householdId, name: 'Dinero Efectivo' } // Buscamos por nombre o tipo 'wallet'\r\n                    });\r\n\r\n                    if (!cashAccount) {\r\n                        cashAccount = await prisma.account.create({\r\n                            data: {\r\n                                householdId,\r\n                                name: 'Dinero Efectivo',\r\n                                bank: 'Efectivo',\r\n                                type: 'wallet',\r\n                                color: '#10b981',\r\n                                owner: 'Casa'\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    // c. Sumamos a \"Dinero Efectivo\" como Ahorro (BalanceSafe)\r\n                    // Aquí el dinero entra físicamente y se marca como reservado\r\n                    await prisma.account.update({\r\n                        where: { id: cashAccount.id },\r\n                        data: {\r\n                            balance: { increment: data.amount },\r\n                            balanceSafe: { increment: data.amount }\r\n                        }\r\n                    });\r\n\r\n                 } else {\r\n                     // ---> LÓGICA ANTIGUA: AHORRO VIRTUAL (No sale del banco) <---\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balanceSafe: { increment: data.amount } } \r\n                    });\r\n                 }\r\n\r\n                 // En AMBOS casos, el \"Ahorro Global\" (Espejo) aumenta\r\n                 let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                 if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n                 await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             }\r\n\r\n             \r\n        }\r\n\r\n        // C. CASO NORMAL (Gasto corriente o Ingreso corriente)\r\n        else {\r\n            const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n            if (shouldUpdateBalance) {\r\n                const multiplier = data.type === 'income' ? 1 : -1;\r\n                await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n            }\r\n        }\r\n\r\n        // Reglas Fijas y Crédito (Igual que antes)\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { householdId, description: data.description, categoryId: data.categoryId, budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || date.getDate(), isActive: true }\r\n            });\r\n        }\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');\r\n\r\n\r\n        // Lógica de Ahorro Global (Sumar o Restar)\r\n\r\n        /*\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n        if (data.payWithSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n        }\r\n\r\n        // Regla Fija\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { \r\n                    householdId, \r\n                    description: data.description, \r\n                    categoryId: data.categoryId, \r\n                    \r\n                    budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, \r\n                    accountIdToCharge: data.accountId, \r\n                    dayOfMonth: data.dayOfMonth || date.getDate(), \r\n                    isActive: true }\r\n            });\r\n        }\r\n\r\n\r\n        // --- CRÉDITO AUTOMÁTICO ---\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');*/\r\n}\r\n\r\n// Funciones CRUD estándar\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { id: data.id, name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, \r\n            description: data.description,\r\n            categoryId: data.categoryId,\r\n            accountIdToCharge: data.accountIdToCharge,\r\n            dayOfMonth: parseInt(data.dayOfMonth),householdId: user.householdId,budgetedAmount: parseFloat(data.budgetedAmount || '0'), staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null, isActive: true } }); revalidatePath('/admin'); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, \r\n            // Actualizamos ambos\r\n            //staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null,\r\n            budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId, name: 'Jhonattan' },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId, name: 'Jhonattan' }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId, name: 'Thannia' },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId, name: 'Thannia' }\r\n    });\r\n\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;IA8csB,kBAAA,WAAA,GAAA,IAAA,oSAAA,EAAA,8CAAA,yRAAA,EAAA,KAAA,GAAA,+RAAA,EAAA"}},
    {"offset": {"line": 202, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/context/FinanceContext.tsx"],"sourcesContent":["// context/FinanceContext.tsx\r\n\"use client\";\r\nimport { useRouter } from 'next/navigation';\r\nimport React, { createContext, useContext, useEffect, useState } from 'react';\r\nimport { Account, Category, Transaction, FixedExpenseRule } from '@/types';\r\n// 1. IMPORTAR LAS NUEVAS ACCIONES\r\nimport {\r\n    getFinanceData, createTransaction, createAccount, deleteAccount, createCategory,\r\n    saveSimulatorItem, deleteSimulatorItem, createFixedRule,\r\n    deleteCategory as deleteCategoryAction, updateCategory as updateCategoryAction,\r\n    // Nuevas:\r\n    deleteTransaction as deleteTransactionAction,\r\n    updateAccount as updateAccountAction,\r\n    updateFixedRule as updateFixedRuleAction,\r\n    deleteFixedRule as deleteFixedRuleAction\r\n} from '@/app/actions';\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\nimport { generateDemoData } from '@/lib/demoData'; // Importa el generador\r\n\r\ninterface SimulatorItem {\r\n    id: string;\r\n    name: string;\r\n    amount: number;\r\n    type: 'income' | 'expense' | 'transfer';\r\n    isFixed: boolean;\r\n}\r\n\r\ninterface FinanceContextType {\r\n    currentUser: { email: string; householdId: string } | null;\r\n    accounts: Account[];\r\n    transactions: Transaction[];\r\n    categories: Category[];\r\n    fixedRules: FixedExpenseRule[];\r\n    simulatorItems: SimulatorItem[];\r\n\r\n    addTransaction: (t: any) => Promise<void>;\r\n    addAccount: (a: any) => Promise<void>;\r\n    deleteAccountAction: (id: string) => Promise<void>;\r\n    addCategory: (c: any) => Promise<void>;\r\n    addFixedRule: (r: any) => Promise<void>;\r\n\r\n    // Simulador\r\n    addSimItem: (item: any) => Promise<void>;\r\n    removeSimItem: (id: string) => Promise<void>;\r\n\r\n    // Funciones COMPLETAS (Ya no vacías)\r\n    updateTransaction: (t: any) => void;\r\n    deleteTransaction: (id: string) => void;\r\n    updateAccount: (a: any) => void;\r\n    deleteCategory: (id: string) => void;\r\n    addSubCategory: (id: string, sub: string) => void;\r\n    removeSubCategory: (id: string, sub: string) => void;\r\n    updateFixedRule: (r: any) => void;\r\n    deleteFixedRule: (id: string) => void;\r\n    markRuleAsPaid: (id: string, date: string) => void;\r\n\r\n    refreshData: () => Promise<void>;\r\n}\r\n\r\nconst FinanceContext = createContext<FinanceContextType | undefined>(undefined);\r\n\r\nexport const FinanceProvider = ({ children }: { children: React.ReactNode }) => {\r\n    // 2. INICIALIZAR ROUTER\r\n    const router = useRouter();\r\n    const [accounts, setAccounts] = useState<Account[]>([]);\r\n    const [transactions, setTransactions] = useState<Transaction[]>([]);\r\n    const [categories, setCategories] = useState<Category[]>([]);\r\n    const [fixedRules, setFixedRules] = useState<FixedExpenseRule[]>([]);\r\n    const [simulatorItems, setSimulatorItems] = useState<SimulatorItem[]>([]);\r\n    const [currentUser, setCurrentUser] = useState<{ email: string; householdId: string } | null>(null);\r\n    // CARGAR DATOS\r\n    useEffect(() => {\r\n        const initData = async () => {\r\n            try {\r\n                const data = await getFinanceData();\r\n\r\n                // CASO NO AUTORIZADO\r\n                // @ts-ignore\r\n                if (data.unauthorized) {\r\n                    // Si estamos en /login no hacemos nada, si estamos dentro, el middleware o el usuario redirige\r\n                    return;\r\n                }\r\n\r\n                // CASO DEMO o REAL (Ambos traen estructura similar ahora)\r\n                // @ts-ignore\r\n                setAccounts(data.accounts || []);\r\n                // @ts-ignore\r\n                setTransactions(data.transactions || []);\r\n                // @ts-ignore\r\n                setCategories(data.categories || []);\r\n                // @ts-ignore\r\n                setFixedRules(data.fixedRules || []);\r\n                // @ts-ignore\r\n                setSimulatorItems(data.simulatorItems || []);\r\n                // @ts-ignore\r\n                setCurrentUser(data.currentUser || null);\r\n\r\n            } catch (e) { console.error(e); }\r\n        };\r\n        initData();\r\n    }, []);\r\n\r\n\r\n\r\n    // --- TRANSACCIONES ---\r\n    const addTransaction = async (t: any) => {\r\n        // CASO 1: TRANSFERENCIA (Crear 2 Movimientos visuales)\r\n        if (t.type === 'transfer') {\r\n            const txExpense = {\r\n                ...t,\r\n                id: uuidv4(),\r\n                type: 'expense',\r\n                description: `Transferencia a: ${t.destAccountName}`, // Mismo texto que Actions\r\n                isTransfer: true,\r\n                didWithdraw: true\r\n            };\r\n            const txIncome = {\r\n                ...t,\r\n                id: uuidv4(),\r\n                type: 'income',\r\n                accountId: t.relatedAccountId,\r\n                relatedAccountId: t.accountId,\r\n                description: `Recibido de: ${t.originAccountName}`, // Mismo texto que Actions\r\n                isTransfer: true,\r\n                didWithdraw: false\r\n            };\r\n\r\n            // Agregamos AMBOS al estado\r\n            setTransactions(prev => [txExpense, txIncome, ...prev]);\r\n\r\n            // Actualizar saldos\r\n            setAccounts(prev => prev.map(acc => {\r\n                if (acc.id === t.accountId) return { ...acc, balance: acc.balance - t.amount };\r\n                if (acc.id === t.relatedAccountId) return { ...acc, balance: acc.balance + t.amount };\r\n                return acc;\r\n            }));\r\n        }\r\n\r\n        // CASO 2: GASTO / INGRESO NORMAL\r\n        else {\r\n            const tempId = uuidv4();\r\n            const optimisticTx = { ...t, id: tempId };\r\n            setTransactions(prev => [optimisticTx, ...prev]);\r\n\r\n            /*\r\n            const shouldUpdateBalance = t.type === 'expense' && t.isSavings ? t.didWithdraw : true;\r\n            if (shouldUpdateBalance) {\r\n                const multiplier = t.type === 'income' ? 1 : -1;\r\n                setAccounts(prev => prev.map(acc => {\r\n                    if (acc.id === t.accountId) return { ...acc, balance: acc.balance + (t.amount * multiplier) };\r\n                    return acc;\r\n                }));\r\n            }\r\n\r\n            // Optimista Ahorro (Suma)\r\n            if (t.isSavings) {\r\n                setAccounts(prev => {\r\n                    const hasVirtual = prev.some(a => a.type === 'savings_virtual');\r\n                    if (hasVirtual) return prev.map(a => a.type === 'savings_virtual' ? { ...a, balance: a.balance + t.amount } : a);\r\n                    return prev;\r\n                });\r\n            }\r\n            // Optimista Gastar de Ahorro (Resta) -> NUEVO\r\n            if (t.payWithSavings) {\r\n                setAccounts(prev => {\r\n                    const hasVirtual = prev.some(a => a.type === 'savings_virtual');\r\n                    if (hasVirtual) return prev.map(a => a.type === 'savings_virtual' ? { ...a, balance: a.balance - t.amount } : a);\r\n                    return prev;\r\n                });\r\n            }\r\n\r\n            // Optimista Regla Fija\r\n            if (t.createFixedRule && t.type === 'expense') {\r\n                const newOptimisticRule: FixedExpenseRule = {\r\n                    id: uuidv4(),\r\n                    householdId: currentUser?.householdId || 'demo',\r\n                    description: t.description,\r\n                    categoryId: t.categoryId,\r\n                    budgetedAmount: t.amount,\r\n                    accountIdToCharge: t.accountId,\r\n                    dayOfMonth: t.dayOfMonth || new Date().getDate(),\r\n                    isActive: true\r\n                };\r\n                setFixedRules(prev => [...prev, newOptimisticRule]);\r\n            }*/\r\n\r\n            // Lógica de Saldos Visuales\r\n            setAccounts(prev => prev.map(acc => {\r\n                // A. Si es Gasto de Ahorro: Restamos Balance y Restamos BalanceSafe de la cuenta real\r\n                if (t.payWithSavings && t.type === 'expense' && acc.id === t.accountId) {\r\n                    return {\r\n                        ...acc,\r\n                        balance: acc.balance - t.amount,\r\n                        balanceSafe: (acc.balanceSafe || 0) - t.amount\r\n                    };\r\n                }\r\n\r\n                // B. Si es Guardar Ahorro (Expense): Solo sube BalanceSafe, Balance total igual\r\n                if (t.isSavings && t.type === 'expense' && acc.id === t.accountId) {\r\n                    return { ...acc, balanceSafe: (acc.balanceSafe || 0) + t.amount };\r\n                }\r\n\r\n                // C. Si es Ingreso Ahorro: Suben ambos\r\n                if (t.isSavings && t.type === 'income' && acc.id === t.accountId) {\r\n                    return { ...acc, balance: acc.balance + t.amount, balanceSafe: (acc.balanceSafe || 0) + t.amount };\r\n                }\r\n\r\n                // D. Gasto/Ingreso Normal\r\n                if (!t.isSavings && !t.payWithSavings && acc.id === t.accountId) {\r\n                    const multiplier = t.type === 'income' ? 1 : -1;\r\n                    // Solo si didWithdraw es true (o undefined que asume true)\r\n                    if (t.didWithdraw !== false) {\r\n                        return { ...acc, balance: acc.balance + (t.amount * multiplier) };\r\n                    }\r\n                }\r\n\r\n                // E. Actualizar Cuenta Virtual Global (Ahorro)\r\n                if (acc.type === 'savings_virtual') {\r\n                    if (t.isSavings) return { ...acc, balance: acc.balance + t.amount };\r\n                    if (t.payWithSavings) return { ...acc, balance: acc.balance - t.amount };\r\n                }\r\n\r\n                return acc;\r\n            }));\r\n            // 2. NUEVO: Actualización optimista de Reglas Fijas (Admin)\r\n            // Si marcamos \"Guardar como recurrente\", lo agregamos visualmente a la lista de reglas\r\n            if (t.createFixedRule && t.type === 'expense') {\r\n                const newOptimisticRule: FixedExpenseRule = {\r\n                    id: uuidv4(), // ID temporal hasta recargar\r\n                    householdId: currentUser?.householdId || 'demo',\r\n                    description: t.description,\r\n                    categoryId: t.categoryId,\r\n                    budgetedAmount: t.amount,\r\n                    accountIdToCharge: t.accountId,\r\n                    dayOfMonth: t.dayOfMonth || new Date().getDate(),\r\n                    isActive: true\r\n                };\r\n                setFixedRules(prev => [...prev, newOptimisticRule]);\r\n            }\r\n        }\r\n\r\n\r\n\r\n        // 3. Llamada al Servidor\r\n        await createTransaction(t);\r\n        await refreshData();\r\n    };\r\n\r\n\r\n    const deleteTransaction = async (id: string) => {\r\n        // 1. Optimistic UI\r\n        const tx = transactions.find(t => t.id === id);\r\n        setTransactions(prev => prev.filter(t => t.id !== id));\r\n\r\n        // Revertir saldo visualmente (básico)\r\n        if (tx && tx.type !== 'transfer') {\r\n            const multiplier = tx.type === 'income' ? -1 : 1; // Inverso para borrar\r\n            setAccounts(prev => prev.map(a => a.id === tx.accountId ? { ...a, balance: a.balance + (tx.amount * multiplier) } : a));\r\n        }\r\n        // 2. Server Action\r\n        await deleteTransactionAction(id);\r\n    };\r\n\r\n    const updateTransaction = async (t: any) => {\r\n        // Implementación futura si deseas editar montos\r\n        console.log(\"Edit not implemented yet\");\r\n    };\r\n\r\n    // --- CUENTAS ---\r\n    const addAccount = async (a: any) => {\r\n        setAccounts(prev => [...prev, a]);\r\n        await createAccount(a);\r\n    };\r\n\r\n    const deleteAccountAction = async (id: string) => {\r\n        setAccounts(prev => prev.filter(x => x.id !== id));\r\n        await deleteAccount(id);\r\n    };\r\n\r\n    const updateAccount = async (a: any) => {\r\n        setAccounts(prev => prev.map(acc => acc.id === a.id ? a : acc));\r\n        await updateAccountAction(a);\r\n    };\r\n\r\n    // --- CATEGORÍAS ---\r\n    const addCategory = async (c: any) => {\r\n        setCategories(prev => [...prev, c]);\r\n        await createCategory(c);\r\n    };\r\n\r\n    const deleteCategory = async (id: string) => {\r\n        setCategories(prev => prev.filter(c => c.id !== id));\r\n        await deleteCategoryAction(id);\r\n    };\r\n\r\n    const addSubCategory = async (catId: string, subName: string) => {\r\n        if (!subName) return;\r\n        const categoryToUpdate = categories.find(c => c.id === catId);\r\n        if (!categoryToUpdate) return;\r\n        const newSubCategories = [...(categoryToUpdate.subCategories || []), subName];\r\n        setCategories(prev => prev.map(c => c.id === catId ? { ...c, subCategories: newSubCategories } : c));\r\n        await updateCategoryAction({ ...categoryToUpdate, subCategories: newSubCategories });\r\n    };\r\n\r\n    const removeSubCategory = async (catId: string, subName: string) => {\r\n        const categoryToUpdate = categories.find(c => c.id === catId);\r\n        if (!categoryToUpdate) return;\r\n        const newSubCategories = categoryToUpdate.subCategories.filter(s => s !== subName);\r\n        setCategories(prev => prev.map(c => c.id === catId ? { ...c, subCategories: newSubCategories } : c));\r\n        await updateCategoryAction({ ...categoryToUpdate, subCategories: newSubCategories });\r\n    };\r\n\r\n    // --- REGLAS FIJAS ---\r\n    const addFixedRule = async (r: any) => {\r\n        setFixedRules(prev => [...prev, r]);\r\n        await createFixedRule(r);\r\n    };\r\n\r\n    const updateFixedRule = async (r: any) => {\r\n        setFixedRules(prev => prev.map(rule => rule.id === r.id ? r : rule));\r\n        await updateFixedRuleAction(r);\r\n    };\r\n\r\n    const deleteFixedRule = async (id: string) => {\r\n        setFixedRules(prev => prev.filter(r => r.id !== id));\r\n        await deleteFixedRuleAction(id);\r\n    };\r\n\r\n    const markRuleAsPaid = (id: string, date: string) => {\r\n        // Implementación opcional visual\r\n        console.log(\"Rule marked as paid\", id);\r\n    };\r\n\r\n    // --- SIMULADOR ---\r\n    const addSimItem = async (item: any) => {\r\n        setSimulatorItems(prev => {\r\n            const exists = prev.find(i => i.id === item.id);\r\n            if (exists) return prev.map(i => i.id === item.id ? item : i);\r\n            return [...prev, item];\r\n        });\r\n        await saveSimulatorItem(item);\r\n    };\r\n\r\n    const removeSimItem = async (id: string) => {\r\n        setSimulatorItems(prev => prev.filter(i => i.id !== id));\r\n        await deleteSimulatorItem(id);\r\n    };\r\n\r\n    const refreshData = async () => {\r\n        try {\r\n            const data = await getFinanceData();\r\n\r\n            // Verificamos si data existe y no es no autorizado\r\n            if (data && !(data as any).unauthorizeds) {\r\n\r\n                // --- CORRECCIÓN AQUÍ: DOBLE CASTING ---\r\n                // Usamos 'as unknown as Account[]' para forzar la conversión\r\n                // ignorando que Prisma aún no \"ve\" el campo balanceSafe en sus tipos automáticos.\r\n                setAccounts((data.accounts || []) as unknown as Account[]);\r\n\r\n                setTransactions((data.transactions || []) as unknown as Transaction[]);\r\n                setCategories((data.categories || []) as unknown as Category[]);\r\n\r\n                if (data.fixedRules) {\r\n                    setFixedRules((data.fixedRules || []) as unknown as FixedExpenseRule[]);\r\n                }\r\n                if (data.simulatorItems) {\r\n                    setSimulatorItems((data.simulatorItems || []) as unknown as SimulatorItem[]);\r\n                }\r\n                if (data.currentUser) {\r\n                    setCurrentUser(data.currentUser as any);\r\n                }\r\n                router.push('/login'); // <--- TE MANDA AL LOGIN\r\n                return;\r\n            }\r\n        } catch (error) {\r\n            console.error(\"Error recargando datos:\", error);\r\n        }\r\n    };\r\n    useEffect(() => {\r\n        refreshData();\r\n    }, []);\r\n\r\n    return (\r\n        <FinanceContext.Provider value={{\r\n            currentUser, accounts, transactions, categories, fixedRules, simulatorItems,\r\n            addTransaction, addAccount, deleteAccountAction, addCategory, addFixedRule,\r\n            addSimItem, removeSimItem, deleteCategory, addSubCategory, removeSubCategory,\r\n            // AHORA SÍ PASAMOS LAS IMPLEMENTACIONES REALES\r\n            updateTransaction,\r\n            deleteTransaction,\r\n            updateAccount,\r\n            updateFixedRule,\r\n            deleteFixedRule,\r\n            markRuleAsPaid,\r\n            refreshData\r\n        }}>\r\n            {children}\r\n        </FinanceContext.Provider>\r\n    );\r\n\r\n\r\n\r\n};\r\n\r\nexport const useFinance = () => {\r\n    const context = useContext(FinanceContext);\r\n    if (!context) throw new Error(\"useFinance Error\");\r\n    return context;\r\n};"],"names":[],"mappings":"AAAA,6BAA6B;;;;;;;;AAE7B;AACA;AAEA,kCAAkC;AAClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AAfA;;;;;;AA2DA,MAAM,+BAAiB,IAAA,2QAAa,EAAiC;AAE9D,MAAM,kBAAkB,CAAC,EAAE,QAAQ,EAAiC;IACvE,wBAAwB;IACxB,MAAM,SAAS,IAAA,oMAAS;IACxB,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,sQAAQ,EAAY,EAAE;IACtD,MAAM,CAAC,cAAc,gBAAgB,GAAG,IAAA,sQAAQ,EAAgB,EAAE;IAClE,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,sQAAQ,EAAa,EAAE;IAC3D,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,sQAAQ,EAAqB,EAAE;IACnE,MAAM,CAAC,gBAAgB,kBAAkB,GAAG,IAAA,sQAAQ,EAAkB,EAAE;IACxE,MAAM,CAAC,aAAa,eAAe,GAAG,IAAA,sQAAQ,EAAgD;IAC9F,eAAe;IACf,IAAA,uQAAS,EAAC;QACN,MAAM,WAAW;YACb,IAAI;gBACA,MAAM,OAAO,MAAM,IAAA,kNAAc;gBAEjC,qBAAqB;gBACrB,aAAa;gBACb,IAAI,KAAK,YAAY,EAAE;oBACnB,+FAA+F;oBAC/F;gBACJ;gBAEA,0DAA0D;gBAC1D,aAAa;gBACb,YAAY,KAAK,QAAQ,IAAI,EAAE;gBAC/B,aAAa;gBACb,gBAAgB,KAAK,YAAY,IAAI,EAAE;gBACvC,aAAa;gBACb,cAAc,KAAK,UAAU,IAAI,EAAE;gBACnC,aAAa;gBACb,cAAc,KAAK,UAAU,IAAI,EAAE;gBACnC,aAAa;gBACb,kBAAkB,KAAK,cAAc,IAAI,EAAE;gBAC3C,aAAa;gBACb,eAAe,KAAK,WAAW,IAAI;YAEvC,EAAE,OAAO,GAAG;gBAAE,QAAQ,KAAK,CAAC;YAAI;QACpC;QACA;IACJ,GAAG,EAAE;IAIL,wBAAwB;IACxB,MAAM,iBAAiB,OAAO;QAC1B,uDAAuD;QACvD,IAAI,EAAE,IAAI,KAAK,YAAY;YACvB,MAAM,YAAY;gBACd,GAAG,CAAC;gBACJ,IAAI,IAAA,sOAAM;gBACV,MAAM;gBACN,aAAa,CAAC,iBAAiB,EAAE,EAAE,eAAe,EAAE;gBACpD,YAAY;gBACZ,aAAa;YACjB;YACA,MAAM,WAAW;gBACb,GAAG,CAAC;gBACJ,IAAI,IAAA,sOAAM;gBACV,MAAM;gBACN,WAAW,EAAE,gBAAgB;gBAC7B,kBAAkB,EAAE,SAAS;gBAC7B,aAAa,CAAC,aAAa,EAAE,EAAE,iBAAiB,EAAE;gBAClD,YAAY;gBACZ,aAAa;YACjB;YAEA,4BAA4B;YAC5B,gBAAgB,CAAA,OAAQ;oBAAC;oBAAW;uBAAa;iBAAK;YAEtD,oBAAoB;YACpB,YAAY,CAAA,OAAQ,KAAK,GAAG,CAAC,CAAA;oBACzB,IAAI,IAAI,EAAE,KAAK,EAAE,SAAS,EAAE,OAAO;wBAAE,GAAG,GAAG;wBAAE,SAAS,IAAI,OAAO,GAAG,EAAE,MAAM;oBAAC;oBAC7E,IAAI,IAAI,EAAE,KAAK,EAAE,gBAAgB,EAAE,OAAO;wBAAE,GAAG,GAAG;wBAAE,SAAS,IAAI,OAAO,GAAG,EAAE,MAAM;oBAAC;oBACpF,OAAO;gBACX;QACJ,OAGK;YACD,MAAM,SAAS,IAAA,sOAAM;YACrB,MAAM,eAAe;gBAAE,GAAG,CAAC;gBAAE,IAAI;YAAO;YACxC,gBAAgB,CAAA,OAAQ;oBAAC;uBAAiB;iBAAK;YAE/C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;aAwCC,GAED,4BAA4B;YAC5B,YAAY,CAAA,OAAQ,KAAK,GAAG,CAAC,CAAA;oBACzB,sFAAsF;oBACtF,IAAI,EAAE,cAAc,IAAI,EAAE,IAAI,KAAK,aAAa,IAAI,EAAE,KAAK,EAAE,SAAS,EAAE;wBACpE,OAAO;4BACH,GAAG,GAAG;4BACN,SAAS,IAAI,OAAO,GAAG,EAAE,MAAM;4BAC/B,aAAa,CAAC,IAAI,WAAW,IAAI,CAAC,IAAI,EAAE,MAAM;wBAClD;oBACJ;oBAEA,gFAAgF;oBAChF,IAAI,EAAE,SAAS,IAAI,EAAE,IAAI,KAAK,aAAa,IAAI,EAAE,KAAK,EAAE,SAAS,EAAE;wBAC/D,OAAO;4BAAE,GAAG,GAAG;4BAAE,aAAa,CAAC,IAAI,WAAW,IAAI,CAAC,IAAI,EAAE,MAAM;wBAAC;oBACpE;oBAEA,uCAAuC;oBACvC,IAAI,EAAE,SAAS,IAAI,EAAE,IAAI,KAAK,YAAY,IAAI,EAAE,KAAK,EAAE,SAAS,EAAE;wBAC9D,OAAO;4BAAE,GAAG,GAAG;4BAAE,SAAS,IAAI,OAAO,GAAG,EAAE,MAAM;4BAAE,aAAa,CAAC,IAAI,WAAW,IAAI,CAAC,IAAI,EAAE,MAAM;wBAAC;oBACrG;oBAEA,0BAA0B;oBAC1B,IAAI,CAAC,EAAE,SAAS,IAAI,CAAC,EAAE,cAAc,IAAI,IAAI,EAAE,KAAK,EAAE,SAAS,EAAE;wBAC7D,MAAM,aAAa,EAAE,IAAI,KAAK,WAAW,IAAI,CAAC;wBAC9C,2DAA2D;wBAC3D,IAAI,EAAE,WAAW,KAAK,OAAO;4BACzB,OAAO;gCAAE,GAAG,GAAG;gCAAE,SAAS,IAAI,OAAO,GAAI,EAAE,MAAM,GAAG;4BAAY;wBACpE;oBACJ;oBAEA,+CAA+C;oBAC/C,IAAI,IAAI,IAAI,KAAK,mBAAmB;wBAChC,IAAI,EAAE,SAAS,EAAE,OAAO;4BAAE,GAAG,GAAG;4BAAE,SAAS,IAAI,OAAO,GAAG,EAAE,MAAM;wBAAC;wBAClE,IAAI,EAAE,cAAc,EAAE,OAAO;4BAAE,GAAG,GAAG;4BAAE,SAAS,IAAI,OAAO,GAAG,EAAE,MAAM;wBAAC;oBAC3E;oBAEA,OAAO;gBACX;YACA,4DAA4D;YAC5D,uFAAuF;YACvF,IAAI,EAAE,eAAe,IAAI,EAAE,IAAI,KAAK,WAAW;gBAC3C,MAAM,oBAAsC;oBACxC,IAAI,IAAA,sOAAM;oBACV,aAAa,aAAa,eAAe;oBACzC,aAAa,EAAE,WAAW;oBAC1B,YAAY,EAAE,UAAU;oBACxB,gBAAgB,EAAE,MAAM;oBACxB,mBAAmB,EAAE,SAAS;oBAC9B,YAAY,EAAE,UAAU,IAAI,IAAI,OAAO,OAAO;oBAC9C,UAAU;gBACd;gBACA,cAAc,CAAA,OAAQ;2BAAI;wBAAM;qBAAkB;YACtD;QACJ;QAIA,yBAAyB;QACzB,MAAM,IAAA,qNAAiB,EAAC;QACxB,MAAM;IACV;IAGA,MAAM,oBAAoB,OAAO;QAC7B,mBAAmB;QACnB,MAAM,KAAK,aAAa,IAAI,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;QAC3C,gBAAgB,CAAA,OAAQ,KAAK,MAAM,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;QAElD,sCAAsC;QACtC,IAAI,MAAM,GAAG,IAAI,KAAK,YAAY;YAC9B,MAAM,aAAa,GAAG,IAAI,KAAK,WAAW,CAAC,IAAI,GAAG,sBAAsB;YACxE,YAAY,CAAA,OAAQ,KAAK,GAAG,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,GAAG,SAAS,GAAG;wBAAE,GAAG,CAAC;wBAAE,SAAS,EAAE,OAAO,GAAI,GAAG,MAAM,GAAG;oBAAY,IAAI;QACxH;QACA,mBAAmB;QACnB,MAAM,IAAA,qNAAuB,EAAC;IAClC;IAEA,MAAM,oBAAoB,OAAO;QAC7B,gDAAgD;QAChD,QAAQ,GAAG,CAAC;IAChB;IAEA,kBAAkB;IAClB,MAAM,aAAa,OAAO;QACtB,YAAY,CAAA,OAAQ;mBAAI;gBAAM;aAAE;QAChC,MAAM,IAAA,iNAAa,EAAC;IACxB;IAEA,MAAM,sBAAsB,OAAO;QAC/B,YAAY,CAAA,OAAQ,KAAK,MAAM,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;QAC9C,MAAM,IAAA,iNAAa,EAAC;IACxB;IAEA,MAAM,gBAAgB,OAAO;QACzB,YAAY,CAAA,OAAQ,KAAK,GAAG,CAAC,CAAA,MAAO,IAAI,EAAE,KAAK,EAAE,EAAE,GAAG,IAAI;QAC1D,MAAM,IAAA,iNAAmB,EAAC;IAC9B;IAEA,qBAAqB;IACrB,MAAM,cAAc,OAAO;QACvB,cAAc,CAAA,OAAQ;mBAAI;gBAAM;aAAE;QAClC,MAAM,IAAA,kNAAc,EAAC;IACzB;IAEA,MAAM,iBAAiB,OAAO;QAC1B,cAAc,CAAA,OAAQ,KAAK,MAAM,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;QAChD,MAAM,IAAA,kNAAoB,EAAC;IAC/B;IAEA,MAAM,iBAAiB,OAAO,OAAe;QACzC,IAAI,CAAC,SAAS;QACd,MAAM,mBAAmB,WAAW,IAAI,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;QACvD,IAAI,CAAC,kBAAkB;QACvB,MAAM,mBAAmB;eAAK,iBAAiB,aAAa,IAAI,EAAE;YAAG;SAAQ;QAC7E,cAAc,CAAA,OAAQ,KAAK,GAAG,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,QAAQ;oBAAE,GAAG,CAAC;oBAAE,eAAe;gBAAiB,IAAI;QACjG,MAAM,IAAA,kNAAoB,EAAC;YAAE,GAAG,gBAAgB;YAAE,eAAe;QAAiB;IACtF;IAEA,MAAM,oBAAoB,OAAO,OAAe;QAC5C,MAAM,mBAAmB,WAAW,IAAI,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;QACvD,IAAI,CAAC,kBAAkB;QACvB,MAAM,mBAAmB,iBAAiB,aAAa,CAAC,MAAM,CAAC,CAAA,IAAK,MAAM;QAC1E,cAAc,CAAA,OAAQ,KAAK,GAAG,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,QAAQ;oBAAE,GAAG,CAAC;oBAAE,eAAe;gBAAiB,IAAI;QACjG,MAAM,IAAA,kNAAoB,EAAC;YAAE,GAAG,gBAAgB;YAAE,eAAe;QAAiB;IACtF;IAEA,uBAAuB;IACvB,MAAM,eAAe,OAAO;QACxB,cAAc,CAAA,OAAQ;mBAAI;gBAAM;aAAE;QAClC,MAAM,IAAA,mNAAe,EAAC;IAC1B;IAEA,MAAM,kBAAkB,OAAO;QAC3B,cAAc,CAAA,OAAQ,KAAK,GAAG,CAAC,CAAA,OAAQ,KAAK,EAAE,KAAK,EAAE,EAAE,GAAG,IAAI;QAC9D,MAAM,IAAA,mNAAqB,EAAC;IAChC;IAEA,MAAM,kBAAkB,OAAO;QAC3B,cAAc,CAAA,OAAQ,KAAK,MAAM,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;QAChD,MAAM,IAAA,mNAAqB,EAAC;IAChC;IAEA,MAAM,iBAAiB,CAAC,IAAY;QAChC,iCAAiC;QACjC,QAAQ,GAAG,CAAC,uBAAuB;IACvC;IAEA,oBAAoB;IACpB,MAAM,aAAa,OAAO;QACtB,kBAAkB,CAAA;YACd,MAAM,SAAS,KAAK,IAAI,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,KAAK,EAAE;YAC9C,IAAI,QAAQ,OAAO,KAAK,GAAG,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,KAAK,EAAE,GAAG,OAAO;YAC3D,OAAO;mBAAI;gBAAM;aAAK;QAC1B;QACA,MAAM,IAAA,qNAAiB,EAAC;IAC5B;IAEA,MAAM,gBAAgB,OAAO;QACzB,kBAAkB,CAAA,OAAQ,KAAK,MAAM,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;QACpD,MAAM,IAAA,uNAAmB,EAAC;IAC9B;IAEA,MAAM,cAAc;QAChB,IAAI;YACA,MAAM,OAAO,MAAM,IAAA,kNAAc;YAEjC,mDAAmD;YACnD,IAAI,QAAQ,CAAC,AAAC,KAAa,aAAa,EAAE;gBAEtC,yCAAyC;gBACzC,6DAA6D;gBAC7D,kFAAkF;gBAClF,YAAa,KAAK,QAAQ,IAAI,EAAE;gBAEhC,gBAAiB,KAAK,YAAY,IAAI,EAAE;gBACxC,cAAe,KAAK,UAAU,IAAI,EAAE;gBAEpC,IAAI,KAAK,UAAU,EAAE;oBACjB,cAAe,KAAK,UAAU,IAAI,EAAE;gBACxC;gBACA,IAAI,KAAK,cAAc,EAAE;oBACrB,kBAAmB,KAAK,cAAc,IAAI,EAAE;gBAChD;gBACA,IAAI,KAAK,WAAW,EAAE;oBAClB,eAAe,KAAK,WAAW;gBACnC;gBACA,OAAO,IAAI,CAAC,WAAW,yBAAyB;gBAChD;YACJ;QACJ,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,2BAA2B;QAC7C;IACJ;IACA,IAAA,uQAAS,EAAC;QACN;IACJ,GAAG,EAAE;IAEL,qBACI,mSAAC,eAAe,QAAQ;QAAC,OAAO;YAC5B;YAAa;YAAU;YAAc;YAAY;YAAY;YAC7D;YAAgB;YAAY;YAAqB;YAAa;YAC9D;YAAY;YAAe;YAAgB;YAAgB;YAC3D,+CAA+C;YAC/C;YACA;YACA;YACA;YACA;YACA;YACA;QACJ;kBACK;;;;;;AAMb;AAEO,MAAM,aAAa;IACtB,MAAM,UAAU,IAAA,wQAAU,EAAC;IAC3B,IAAI,CAAC,SAAS,MAAM,IAAI,MAAM;IAC9B,OAAO;AACX"}},
    {"offset": {"line": 622, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/lib/utils.ts"],"sourcesContent":["import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,GAAG,GAAG,MAAoB;IACxC,OAAO,IAAA,2NAAO,EAAC,IAAA,kMAAI,EAAC;AACtB"}},
    {"offset": {"line": 637, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/components/dashboard/RealisticAccountCard.tsx"],"sourcesContent":["\"use client\";\r\nimport { useFinance } from '@/context/FinanceContext';\r\nimport { Account } from '@/types';\r\nimport { Wallet, Building2, Banknote, CreditCard, Lock , PiggyBank } from 'lucide-react';\r\nimport { cn } from '@/lib/utils';\r\n\r\nexport default function RealisticAccountCard({ account }: { account: Account }) {\r\n  const { transactions } = useFinance();\r\n\r\n  // 1. Traemos el ahorro de las cuentas\r\n  const totalBalanceSafe = account.balanceSafe;\r\n  // 2. El \"Balance\" que viene de la BD ya incluye todo (porque decidimos no restarlo).\r\n  //    Así que el \"Disponible\" es el Total menos el Ahorro Reservado.\r\n  const totalBalance = account.balance;\r\n  const availableBalance = totalBalance - totalBalanceSafe;\r\n\r\n  const Icon = account.type === 'wallet' ? Wallet : \r\n               account.type === 'savings_virtual' ? PiggyBank :\r\n               account.type === 'cash' ? Banknote : \r\n               account.type === 'bond' ? CreditCard : Building2 ;\r\n\r\n  const cardColor = account.color || '#66667aff';\r\n\r\n  return (\r\n    <div \r\n        className=\"relative overflow-hidden rounded-xl p-4 bg-zinc-900 border border-zinc-800 shadow-md transition-all hover:scale-[1.02]\"\r\n        style={{ borderLeft: `4px solid ${cardColor}`,borderRight: `4px solid ${cardColor}` , backgroundColor:`${cardColor}26`}}\r\n    >\r\n      <div className=\"flex justify-between items-start mb-3\">\r\n        <div className=\"flex items-center gap-3\">\r\n            <div className=\"w-3 h-3 rounded-sm shadow-[0_0_10px_rgba(0,0,0,0.5)]\" style={{ backgroundColor: cardColor }} />\r\n            <div>\r\n                <h3 className=\"text-lg font-bold text-white leading-tight\">{account.name}</h3>\r\n                <p className=\"text-xs text-zinc-500 font-medium\">\r\n                   • {account.bank} • \r\n                </p>\r\n            </div>\r\n        </div>\r\n        <Icon className=\"text-zinc-600 opacity-50\" size={20} />\r\n      </div>\r\n\r\n      <div className=\"space-y-2\">\r\n         {/* Ahorro Reservado (Solo si hay) */}\r\n         {totalBalanceSafe > 0 && (\r\n            <div className=\"flex justify-between items-center bg-blue-900/20 px-2 py-1 rounded border border-blue-900/30\">\r\n                <div className=\"flex items-center gap-1 text-blue-400 text-xs\">\r\n                    <Lock size={10} /> <span>Reservado Ahorro</span>\r\n                </div>\r\n                <span className=\"text-blue-300 text-xs font-mono font-bold\">${totalBalanceSafe.toLocaleString()}</span>\r\n            </div>\r\n         )}\r\n\r\n         <div className=\"flex justify-between items-end border-t border-zinc-800 pt-2 mt-2\">\r\n             <div className=\"text-left\">\r\n                <p className=\"text-[10px] text-zinc-500 uppercase tracking-wider\">Total Banco</p>\r\n                <p className=\"text-xs text-zinc-400 font-mono\">${totalBalance.toLocaleString()}</p>\r\n             </div>\r\n             <div className=\"text-right\">\r\n                <p className=\"text-[10px] text-zinc-400 uppercase tracking-wider font-bold\">Disponible Real</p>\r\n                <p className={cn(\r\n                    \"text-xl font-mono font-bold tracking-tight\",\r\n                    availableBalance >= 0 ? \"text-emerald-400\" : \"text-rose-400\"\r\n                )}>\r\n                    ${availableBalance.toLocaleString('es-CO')}\r\n                </p>\r\n             </div>\r\n         </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}"],"names":[],"mappings":";;;;;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAJA;;;;;AAMe,SAAS,qBAAqB,EAAE,OAAO,EAAwB;IAC5E,MAAM,EAAE,YAAY,EAAE,GAAG,IAAA,6LAAU;IAEnC,sCAAsC;IACtC,MAAM,mBAAmB,QAAQ,WAAW;IAC5C,qFAAqF;IACrF,oEAAoE;IACpE,MAAM,eAAe,QAAQ,OAAO;IACpC,MAAM,mBAAmB,eAAe;IAExC,MAAM,OAAO,QAAQ,IAAI,KAAK,WAAW,qQAAM,GAClC,QAAQ,IAAI,KAAK,oBAAoB,kRAAS,GAC9C,QAAQ,IAAI,KAAK,SAAS,2QAAQ,GAClC,QAAQ,IAAI,KAAK,SAAS,qRAAU,GAAG,kRAAS;IAE7D,MAAM,YAAY,QAAQ,KAAK,IAAI;IAEnC,qBACE,mSAAC;QACG,WAAU;QACV,OAAO;YAAE,YAAY,CAAC,UAAU,EAAE,WAAW;YAAC,aAAa,CAAC,UAAU,EAAE,WAAW;YAAG,iBAAgB,GAAG,UAAU,EAAE,CAAC;QAAA;;0BAExH,mSAAC;gBAAI,WAAU;;kCACb,mSAAC;wBAAI,WAAU;;0CACX,mSAAC;gCAAI,WAAU;gCAAuD,OAAO;oCAAE,iBAAiB;gCAAU;;;;;;0CAC1G,mSAAC;;kDACG,mSAAC;wCAAG,WAAU;kDAA8C,QAAQ,IAAI;;;;;;kDACxE,mSAAC;wCAAE,WAAU;;4CAAoC;4CAC3C,QAAQ,IAAI;4CAAC;;;;;;;;;;;;;;;;;;;kCAI3B,mSAAC;wBAAK,WAAU;wBAA2B,MAAM;;;;;;;;;;;;0BAGnD,mSAAC;gBAAI,WAAU;;oBAEX,mBAAmB,mBACjB,mSAAC;wBAAI,WAAU;;0CACX,mSAAC;gCAAI,WAAU;;kDACX,mSAAC,+PAAI;wCAAC,MAAM;;;;;;oCAAM;kDAAC,mSAAC;kDAAK;;;;;;;;;;;;0CAE7B,mSAAC;gCAAK,WAAU;;oCAA4C;oCAAE,iBAAiB,cAAc;;;;;;;;;;;;;kCAIpG,mSAAC;wBAAI,WAAU;;0CACX,mSAAC;gCAAI,WAAU;;kDACZ,mSAAC;wCAAE,WAAU;kDAAqD;;;;;;kDAClE,mSAAC;wCAAE,WAAU;;4CAAkC;4CAAE,aAAa,cAAc;;;;;;;;;;;;;0CAE/E,mSAAC;gCAAI,WAAU;;kDACZ,mSAAC;wCAAE,WAAU;kDAA+D;;;;;;kDAC5E,mSAAC;wCAAE,WAAW,IAAA,uKAAE,EACZ,8CACA,oBAAoB,IAAI,qBAAqB;;4CAC9C;4CACG,iBAAiB,cAAc,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOtD"}},
    {"offset": {"line": 866, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/components/ui/button.tsx"],"sourcesContent":["import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-primary text-primary-foreground hover:bg-primary/90\",\n        destructive:\n          \"bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60\",\n        outline:\n          \"border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50\",\n        secondary:\n          \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        ghost:\n          \"hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-9 px-4 py-2 has-[>svg]:px-3\",\n        sm: \"h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5\",\n        lg: \"h-10 rounded-md px-6 has-[>svg]:px-4\",\n        icon: \"size-9\",\n        \"icon-sm\": \"size-8\",\n        \"icon-lg\": \"size-10\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nfunction Button({\n  className,\n  variant = \"default\",\n  size = \"default\",\n  asChild = false,\n  ...props\n}: React.ComponentProps<\"button\"> &\n  VariantProps<typeof buttonVariants> & {\n    asChild?: boolean\n  }) {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      data-slot=\"button\"\n      data-variant={variant}\n      data-size={size}\n      className={cn(buttonVariants({ variant, size, className }))}\n      {...props}\n    />\n  )\n}\n\nexport { Button, buttonVariants }\n"],"names":[],"mappings":";;;;;;;AACA;AACA;AAEA;;;;;AAEA,MAAM,iBAAiB,IAAA,4NAAG,EACxB,+bACA;IACE,UAAU;QACR,SAAS;YACP,SAAS;YACT,aACE;YACF,SACE;YACF,WACE;YACF,OACE;YACF,MAAM;QACR;QACA,MAAM;YACJ,SAAS;YACT,IAAI;YACJ,IAAI;YACJ,MAAM;YACN,WAAW;YACX,WAAW;QACb;IACF;IACA,iBAAiB;QACf,SAAS;QACT,MAAM;IACR;AACF;AAGF,SAAS,OAAO,EACd,SAAS,EACT,UAAU,SAAS,EACnB,OAAO,SAAS,EAChB,UAAU,KAAK,EACf,GAAG,OAIF;IACD,MAAM,OAAO,UAAU,6NAAI,GAAG;IAE9B,qBACE,mSAAC;QACC,aAAU;QACV,gBAAc;QACd,aAAW;QACX,WAAW,IAAA,uKAAE,EAAC,eAAe;YAAE;YAAS;YAAM;QAAU;QACvD,GAAG,KAAK;;;;;;AAGf"}},
    {"offset": {"line": 927, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/app/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { cookies } from 'next/headers';\r\nimport { signToken, verifyToken } from '@/lib/auth';\r\nimport { sendAuthEmail, sendRegistrationRequestEmail } from '@/lib/mail';\r\nimport { generateDemoData } from '@/lib/demoData';\r\n\r\n\r\n// --- GLOBAL PRISMA ---\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n// --- OBTENER USUARIO ACTUAL ---\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n    if (!token) return null;\r\n    \r\n    // 1. Verificar firma del token\r\n    const payload = await verifyToken(token);\r\n    if (!payload) return null;\r\n    try {\r\n        const user = await prisma.user.findUnique({ \r\n            where: { id: payload.id as string } \r\n        });\r\n        // Si no se encuentra el usuario en BD, retornamos null (inválido)\r\n        return user; \r\n    } catch (error) {\r\n        console.log(error );\r\n        return null;\r\n    }\r\n\r\n    //return await verifyToken(token);\r\n}\r\n\r\n// --- CREAR USUARIO (Para el botón Admin) ---\r\nexport async function createNewUser(name: string, email: string, householdId: string) {\r\n    const currentUser = await getCurrentUser();\r\n    \r\n    // Validación de seguridad básica: Solo User Master puede crear usuarios\r\n    if (currentUser?.email !== process.env.GMAIL_USER) {\r\n        return { success: false, message: 'No autorizado' };\r\n    }\r\n\r\n    try {\r\n        const existing = await prisma.user.findUnique({ where: { email } });\r\n        if (existing) return { success: false, message: 'El usuario ya existe.' };\r\n        \r\n        const existinHouseHold = await prisma.user.findMany({ where: { householdId } });\r\n        console.log(\"existinHouseHold \", existinHouseHold);\r\n        if (!existinHouseHold){\r\n            await prisma.account.createMany({\r\n                data: [\r\n                    { name: 'Dinero Efectivo', bank: 'Efectivo', type: 'wallet', owner: name, color: '#25ab28ff', householdId: householdId },\r\n                    { name: 'Ahorro Global', bank: 'Ahorro', type: 'savings_virtual', owner: name, color: '#fba300ff', householdId: householdId } \r\n                ]\r\n            });    \r\n        } \r\n        \r\n        await prisma.user.create({\r\n            data: {\r\n                email,\r\n                name,\r\n                householdId,\r\n                token: 'INIT', // Token inicial placeholder\r\n              }\r\n          });\r\n        \r\n        revalidatePath('/admin');\r\n        return { success: true, message: 'Usuario creado exitosamente.' };\r\n    } catch (error) {\r\n        return { success: false, message: 'Error creando usuario en BD.' };\r\n    }\r\n    \r\n}\r\n\r\n\r\n// --- AUTENTICACIÓN: PASO 1 (SOLICITAR CÓDIGO) ---\r\nexport async function requestLoginCode(email: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    if (!user) {\r\n        return { success: false, message: 'Usuario no encontrado. Debes solicitar registro.' };\r\n    }\r\n\r\n    const digits = Math.floor(10000000 + Math.random() * 90000000).toString();\r\n    const specials = \"%#-/*@?!+_\";\r\n    const specialChar = specials.charAt(Math.floor(Math.random() * specials.length));\r\n    const secureCode = digits + specialChar;\r\n    \r\n    await prisma.user.update({ where: { email }, data: { token: secureCode } });\r\n\r\n    try {\r\n        await sendAuthEmail(email, secureCode);\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Error mailing:\", error);\r\n        return { success: false, message: 'Error enviando correo.' };\r\n    }\r\n}\r\n\r\n// --- AUTENTICACIÓN: PASO 2 (LOGIN) ---\r\nexport async function loginAction(email: string, token: string) {\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n    \r\n    if (!user || !user.token) return { success: false, message: 'Código incorrecto.' };\r\n\r\n    const jwt = await signToken({ \r\n        id: user.id, \r\n        email: user.email, \r\n        householdId: user.householdId \r\n    });\r\n\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('auth_token', jwt, { \r\n        httpOnly: true, \r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60 * 24 * 30, \r\n        path: '/' \r\n    });\r\n\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- REGISTRO (SOLICITUD) ---\r\nexport async function requestRegistration(email: string, name: string, familyName: string) {\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) return { success: false, message: 'Correo ya registrado.' };\r\n\r\n    try {\r\n        // Enviamos nombre, email y familia al correo\r\n        await sendRegistrationRequestEmail(email, name, familyName);\r\n        return { success: true, message: 'Solicitud enviada al administrador.' };\r\n    } catch (e) {\r\n        return { success: false, message: 'Error de conexión.' };\r\n    }\r\n}\r\n\r\n// --- LOGOUT / DEMO ---\r\nexport async function setDemoModeAction() {\r\n    const cookieStore = await cookies();\r\n    \r\n    // 1. Establecer cookie de Demo (Importante: path '/')\r\n    cookieStore.set('is_demo_mode', 'true', { \r\n        path: '/',\r\n        httpOnly: true,\r\n        maxAge: 60 * 60 * 24 // 1 día\r\n    });\r\n    \r\n    // 2. Borrar token anterior si existe para evitar conflictos\r\n    cookieStore.delete('auth_token');\r\n    \r\n    return { success: true };\r\n}\r\n\r\nexport async function logoutAction() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n    cookieStore.delete('is_demo_mode');\r\n    return { success: true };\r\n}\r\n\r\n// --- OBTENER DATOS ---\r\nexport async function getFinanceData() {\r\n    const cookieStore = await cookies();\r\n    \r\n\r\n    // --- DEMO DATA ---\r\n    const isDemo = cookieStore.get('is_demo_mode')?.value === 'true';\r\n    if (isDemo) {\r\n        const demoData = generateDemoData();\r\n        return { \r\n            ...demoData,\r\n            isDemo: true, \r\n            currentUser: { email: 'Usuario Demo', householdId: 'demo' },\r\n            unauthorized: false\r\n        };\r\n    }\r\n\r\n    const user = await getCurrentUser();\r\n    \r\n    if (!user) {\r\n        return { unauthorized: true }; \r\n    }\r\n\r\n    // --- USER DATA ---\r\n    const householdId = user.householdId; \r\n    const accounts = await prisma.account.findMany({ where: { householdId } });\r\n    const categories = await prisma.category.findMany({ where: { householdId } });\r\n    const transactions = await prisma.transaction.findMany({\r\n        where: { householdId },\r\n        // NO poner aquí un filtro solo para 'expense'. \r\n        // Si tienes filtros de tipo, deben incluir 'income' para que se vea la entrada de la transferencia.\r\n        orderBy: { date: 'desc' },\r\n        include: { \r\n            account: { select: { name: true, color: true } },\r\n            category: { select: { name: true } }\r\n        }\r\n    });\r\n\r\n    const fixedRules = await prisma.fixedRule.findMany({ where: { householdId } });\r\n    const simulatorItems = await prisma.simulatorItem.findMany({ where: { householdId } });\r\n\r\n    return {\r\n        isDemo: false,\r\n        unauthorized: false,\r\n        currentUser: user,\r\n        accounts,\r\n        categories: categories.map(c => ({...c, subCategories: c.subCategories ? JSON.parse(c.subCategories) : []})),\r\n        transactions: transactions.map(t => ({...t, date: t.date.toISOString()})),\r\n        fixedRules,\r\n        simulatorItems\r\n    };\r\n}\r\n\r\n// --- CREACIONES Y UPDATES TRANSACTIONS ---\r\nexport async function createTransaction(data: any) {\r\n    const user = await getCurrentUser();\r\n    if (!user) return; \r\n    const householdId = user.householdId;\r\n    const date = new Date(data.date);\r\n    // 1. TRANSFERENCIA: CREA DOS MOVIMIENTOS\r\n    if (data.type === 'transfer') {\r\n        // Buscar/Crear categoría\r\n        let transferCat = await prisma.category.findFirst({ where: { householdId, name: 'Transferencia Propia' } });\r\n        if (!transferCat) {\r\n            transferCat = await prisma.category.create({ data: { householdId, name: 'Transferencia Propia', type: 'transfer', subCategories: JSON.stringify([]) } });\r\n        }\r\n\r\n        // A. SALIDA (Gasto - Cuenta Origen)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'expense', amount: data.amount, \r\n                accountId: data.accountId, \r\n                categoryId: transferCat.id, \r\n                description: `Transferencia a: ${data.destAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.relatedAccountId, didWithdraw: true \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.accountId }, data: { balance: { decrement: data.amount } } });\r\n\r\n        // B. ENTRADA (Ingreso - Cuenta Destino)\r\n        await prisma.transaction.create({ \r\n            data: { \r\n                householdId, type: 'income', amount: data.amount, \r\n                accountId: data.relatedAccountId, \r\n                categoryId: transferCat.id, \r\n                description: `Recibido de: ${data.originAccountName}`, // TEXTO EXACTO\r\n                date, isTransfer: true, relatedAccountId: data.accountId, didWithdraw: false \r\n            } \r\n        });\r\n        await prisma.account.update({ where: { id: data.relatedAccountId }, data: { balance: { increment: data.amount } } });\r\n    } \r\n    \r\n    // 2. GASTO / INGRESO NORMAL\r\n    else {\r\n\r\n        const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n        \r\n        // --- GASTO NORMAL ---\r\n        await prisma.transaction.create({\r\n            data: { \r\n                householdId, type: data.type, amount: data.amount, budgetedAmount: data.budgetedAmount,\r\n                accountId: data.accountId, categoryId: data.categoryId, description: data.description, date, \r\n                isFixed: data.isFixed || false, \r\n                isSavings: data.isSavings || false, \r\n                payWithSavings: data.payWithSavings || false,\r\n                didWithdraw: data.payWithSavings ? true : (data.didWithdraw ?? true)\r\n            }\r\n        });\r\n\r\n        /*if (shouldUpdateBalance) {\r\n            const multiplier = data.type === 'income' ? 1 : -1;\r\n            await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n        }*/\r\n\r\n\r\n        \r\n        // --- LÓGICA DE SALDOS ---\r\n\r\n        // A. CASO \"GASTAR DE AHORRO\" (Expense + payWithSavings)\r\n        if (data.payWithSavings && data.type === 'expense') {\r\n            // Restamos del balance total Y del balanceSafe de la cuenta\r\n            await prisma.account.update({ \r\n                where: { id: data.accountId }, \r\n                data: { \r\n                    balance: { decrement: data.amount },\r\n                    balanceSafe: { decrement: data.amount } \r\n                } \r\n            });\r\n            // Restamos también del Ahorro Global (Cuenta Virtual)\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) {\r\n                await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n            }\r\n        }\r\n        \r\n        // B. CASO \"ES AHORRO\" (Guardar dinero)\r\n        else if (data.isSavings) {\r\n             // 1. Si es INGRESO y es ahorro: Sube Balance Total y Sube BalanceSafe\r\n             if (data.type === 'income') {\r\n                await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        balance: { increment: data.amount },\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });\r\n                let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             \r\n             } \r\n             // 2. Si es GASTO (Sacar del bolsillo diario para guardar): El balance total NO cambia (el dinero sigue en la cuenta), pero sube el BalanceSafe\r\n             // NOTA: Si el usuario quiere que \"salga\" de la cuenta, debería usar Transferencia. Asumimos que \"Gasto -> Es Ahorro\" es apartar dinero.\r\n             else if (data.type === 'expense') {\r\n                 /*await prisma.account.update({ \r\n                    where: { id: data.accountId }, \r\n                    data: { \r\n                        // No tocamos balance total porque el dinero no se ha ido del banco, solo cambió de \"estado\"\r\n                        balanceSafe: { increment: data.amount } \r\n                    } \r\n                });*/\r\n                // ---> NUEVA LÓGICA: RETIRO FÍSICO PARA AHORRO <---\r\n                 if (data.didWithdraw) {\r\n                     // a. Restamos de la cuenta origen (Banco)\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balance: { decrement: data.amount } } // Solo decrementa balance total, no balanceSafe, porque salió del banco\r\n                    });\r\n\r\n                    // b. Buscamos (o creamos) la cuenta \"Dinero Efectivo\"\r\n                    let cashAccount = await prisma.account.findFirst({ \r\n                        where: { householdId, name: 'Dinero Efectivo' } // Buscamos por nombre o tipo 'wallet'\r\n                    });\r\n\r\n                    if (!cashAccount) {\r\n                        cashAccount = await prisma.account.create({\r\n                            data: {\r\n                                householdId,\r\n                                name: 'Dinero Efectivo',\r\n                                bank: 'Efectivo',\r\n                                type: 'wallet',\r\n                                color: '#10b981',\r\n                                owner: 'Casa'\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    // c. Sumamos a \"Dinero Efectivo\" como Ahorro (BalanceSafe)\r\n                    // Aquí el dinero entra físicamente y se marca como reservado\r\n                    await prisma.account.update({\r\n                        where: { id: cashAccount.id },\r\n                        data: {\r\n                            balance: { increment: data.amount },\r\n                            balanceSafe: { increment: data.amount }\r\n                        }\r\n                    });\r\n\r\n                 } else {\r\n                     // ---> LÓGICA ANTIGUA: AHORRO VIRTUAL (No sale del banco) <---\r\n                     await prisma.account.update({ \r\n                        where: { id: data.accountId }, \r\n                        data: { balanceSafe: { increment: data.amount } } \r\n                    });\r\n                 }\r\n\r\n                 // En AMBOS casos, el \"Ahorro Global\" (Espejo) aumenta\r\n                 let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n                 if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n                 await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n             }\r\n\r\n             \r\n        }\r\n\r\n        // C. CASO NORMAL (Gasto corriente o Ingreso corriente)\r\n        else {\r\n            const shouldUpdateBalance = data.type === 'expense' ? data.didWithdraw : true;\r\n            if (shouldUpdateBalance) {\r\n                const multiplier = data.type === 'income' ? 1 : -1;\r\n                await prisma.account.update({ where: { id: data.accountId }, data: { balance: { increment: data.amount * multiplier } } });\r\n            }\r\n        }\r\n\r\n        // Reglas Fijas y Crédito (Igual que antes)\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { householdId, description: data.description, categoryId: data.categoryId, budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || date.getDate(), isActive: true }\r\n            });\r\n        }\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');\r\n\r\n\r\n        // Lógica de Ahorro Global (Sumar o Restar)\r\n\r\n        /*\r\n        if (data.isSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (!savingsAcc) savingsAcc = await prisma.account.create({ data: { householdId, name: 'Bolsillo Ahorros Global', bank: 'Sistema', type: 'savings_virtual', owner: 'Familia', color: '#3b82f6' } });\r\n            await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { increment: data.amount } } });\r\n        }\r\n        if (data.payWithSavings) {\r\n            let savingsAcc = await prisma.account.findFirst({ where: { type: 'savings_virtual', householdId } });\r\n            if (savingsAcc) await prisma.account.update({ where: { id: savingsAcc.id }, data: { balance: { decrement: data.amount } } });\r\n        }\r\n\r\n        // Regla Fija\r\n        if (data.createFixedRule && data.type === 'expense') {\r\n            await prisma.fixedRule.create({\r\n                data: { \r\n                    householdId, \r\n                    description: data.description, \r\n                    categoryId: data.categoryId, \r\n                    \r\n                    budgetedAmount: data.budgetedAmount ? parseFloat(data.budgetedAmount) : data.amount, \r\n                    accountIdToCharge: data.accountId, \r\n                    dayOfMonth: data.dayOfMonth || date.getDate(), \r\n                    isActive: true }\r\n            });\r\n        }\r\n\r\n\r\n        // --- CRÉDITO AUTOMÁTICO ---\r\n        if (data.type === 'income' && data.isCredit && data.creditQuotaValue) {\r\n             let debtCat = await prisma.category.findFirst({ where: { householdId, type: 'expense', name: { contains: 'Deuda' } } });\r\n             if (!debtCat) debtCat = await prisma.category.create({ data: { householdId, name: 'Pago Deudas', type: 'expense', subCategories: JSON.stringify(['Cuota Crédito']) } });\r\n             await prisma.fixedRule.create({ data: { householdId, description: `Cuota: ${data.description}`, categoryId: debtCat.id, budgetedAmount: parseFloat(data.creditQuotaValue), accountIdToCharge: data.accountId, dayOfMonth: data.dayOfMonth || new Date().getDate(), isActive: true } });\r\n        }\r\n    }\r\n    revalidatePath('/');\r\n    revalidatePath('/admin');*/\r\n}\r\n\r\n// Funciones CRUD estándar\r\nexport async function createAccount(data: any) { const user = await getCurrentUser(); if(user) await prisma.account.create({ data: { ...data, householdId: user.householdId } }); revalidatePath('/'); }\r\nexport async function deleteAccount(id: string) { await prisma.account.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateAccount(data: any) { await prisma.account.update({ where: { id: data.id }, data: { name: data.name, bank: data.bank, type: data.type, color: data.color } }); revalidatePath('/'); }\r\nexport async function createCategory(data: any) { const user = await getCurrentUser(); if(user) await prisma.category.create({ data: { id: data.id, name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories || []), householdId: user.householdId }}); revalidatePath('/'); }\r\nexport async function deleteCategory(id: string) { await prisma.category.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function updateCategory(data: any) { await prisma.category.update({ where: { id: data.id }, data: { name: data.name, type: data.type, subCategories: JSON.stringify(data.subCategories) } }); revalidatePath('/'); }\r\nexport async function deleteTransaction(id: string) { const tx = await prisma.transaction.findUnique({ where: { id } }); if (!tx) return; await prisma.transaction.delete({ where: { id } }); if (tx.accountId && tx.didWithdraw && !tx.isTransfer) { const multiplier = tx.type === 'income' ? -1 : 1; await prisma.account.update({ where: { id: tx.accountId }, data: { balance: { increment: tx.amount * multiplier } } }); } revalidatePath('/'); }\r\nexport async function createFixedRule(data: any) { const user = await getCurrentUser(); if(user) await prisma.fixedRule.create({ data: { ...data, \r\n            description: data.description,\r\n            categoryId: data.categoryId,\r\n            accountIdToCharge: data.accountIdToCharge,\r\n            dayOfMonth: parseInt(data.dayOfMonth),householdId: user.householdId,budgetedAmount: parseFloat(data.budgetedAmount || '0'), staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null, isActive: true } }); revalidatePath('/admin'); revalidatePath('/'); }\r\nexport async function updateFixedRule(data: any) { await prisma.fixedRule.update({ where: { id: data.id }, data: { description: data.description, \r\n            // Actualizamos ambos\r\n            //staticAmount: data.staticAmount ? parseFloat(data.staticAmount) : null,\r\n            budgetedAmount: data.budgetedAmount, dayOfMonth: data.dayOfMonth, isActive: data.isActive } }); revalidatePath('/'); }\r\nexport async function deleteFixedRule(id: string) { await prisma.fixedRule.delete({ where: { id } }); revalidatePath('/'); }\r\nexport async function saveSimulatorItem(data: any) { const user = await getCurrentUser(); if(!user) return; const householdId = user.householdId; const existing = await prisma.simulatorItem.findUnique({ where: { id: data.id } }); if (existing) { await prisma.simulatorItem.update({ where: { id: data.id }, data: { name: data.name, amount: data.amount } }); } else { await prisma.simulatorItem.create({ data: { ...data, householdId } }); } revalidatePath('/simulator'); }\r\nexport async function deleteSimulatorItem(id: string) { await prisma.simulatorItem.delete({ where: { id } }); revalidatePath('/simulator'); }\r\n\r\n// --- SEED ---\r\nexport async function seedDatabase() {\r\n    const familyId = \"familia-gonzalez-marin\";\r\n    \r\n    await prisma.user.upsert({\r\n        where: { email: 'jhonattan.gonzalez.38@gmail.com' },\r\n        update: { householdId: familyId, name: 'Jhonattan' },\r\n        create: { email: 'jhonattan.gonzalez.38@gmail.com', token: 'INIT', householdId: familyId, name: 'Jhonattan' }\r\n    });\r\n\r\n    await prisma.user.upsert({\r\n        where: { email: 'marinthania13@gmail.com' },\r\n        update: { householdId: familyId, name: 'Thannia' },\r\n        create: { email: 'marinthania13@gmail.com', token: 'INIT', householdId: familyId, name: 'Thannia' }\r\n    });\r\n\r\n    const accCount = await prisma.account.count({ where: { householdId: familyId } });\r\n    if (accCount === 0) {\r\n        await prisma.account.createMany({\r\n            data: [\r\n                { name: 'Davivienda', bank: 'Davivienda', type: 'bank', owner: 'Jhonattan', color: '#ef4444', householdId: familyId },\r\n                { name: 'Nequi', bank: 'Nequi', type: 'bond', owner: 'Thannia', color: '#ec4899', householdId: familyId }\r\n            ]\r\n        });\r\n        await prisma.category.createMany({\r\n            data: [\r\n                { name: 'Salario', type: 'income', subCategories: JSON.stringify(['Nómina']), householdId: familyId },\r\n                { name: 'Alimentación', type: 'expense', subCategories: JSON.stringify(['Mercado']), householdId: familyId }\r\n            ]\r\n        });\r\n    }\r\n    revalidatePath('/');\r\n    return { success: true };\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;IAgKsB,eAAA,WAAA,GAAA,IAAA,oSAAA,EAAA,8CAAA,yRAAA,EAAA,KAAA,GAAA,+RAAA,EAAA"}},
    {"offset": {"line": 939, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/components/dashboard/AccountsSidebar.tsx"],"sourcesContent":["\"use client\";\r\nimport { useFinance } from '@/context/FinanceContext';\r\nimport RealisticAccountCard from './RealisticAccountCard';\r\nimport { X, Wallet, Home, Calculator, Settings, LogOut } from 'lucide-react';\r\nimport Link from 'next/link';\r\nimport { cn } from '@/lib/utils';\r\nimport { usePathname,useRouter } from 'next/navigation';\r\nimport { Button } from '@/components/ui/button';\r\nimport { logoutAction } from '@/app/actions';\r\n\r\ninterface Props {\r\n    isOpen: boolean;\r\n    onClose: () => void; // Para cerrar en móvil\r\n    className?: string;\r\n}\r\n\r\nexport default function AccountsSidebar({ isOpen, onClose, className }: Props) {\r\n    const { accounts, currentUser } = useFinance();\r\n    const visibleAccounts = accounts.filter(a => !a.isHidden);\r\n\r\n    // 1. Patrimonio Total (Suma de todos los balances brutos)\r\n    const totalPatrimony = visibleAccounts.reduce((sum, acc) => sum + acc.balance, 0);\r\n    \r\n    // 2. Total Ahorrado (Suma de los balanceSafe de cada cuenta)\r\n    const totalReservedSavings = visibleAccounts.reduce((sum, acc) => sum + (acc.balanceSafe || 0), 0);\r\n\r\n    \r\n    //const totalPatrimony = visibleAccounts.reduce((sum, acc) => sum + acc.balance, 0);\r\n    const totalAvailable = totalPatrimony - totalReservedSavings;\r\n\r\n    const pathname = usePathname();\r\n    const navClass = (path: string) => cn(\r\n        \"flex items-center gap-3 p-3 rounded-lg transition-colors font-medium text-sm\",\r\n        pathname === path ? \"bg-indigo-900/50 text-indigo-400 border border-indigo-500/30\" : \"text-zinc-400 hover:bg-zinc-900 hover:text-zinc-100\"\r\n    );\r\n\r\n    return (\r\n        <>\r\n            {/* FONDO OSCURO (SOLO MÓVIL) - Cierra el menú al hacer click afuera */}\r\n            <div\r\n                className={cn(\r\n                    \"fixed inset-0 bg-black/80 z-40 md:hidden transition-opacity duration-300\",\r\n                    isOpen ? \"opacity-100\" : \"opacity-0 pointer-events-none\"\r\n                )}\r\n                onClick={onClose}\r\n            />\r\n\r\n            {/* SIDEBAR REAL */}\r\n            <aside className={cn(\r\n                \"fixed top-0 left-0 bottom-0 z-50 w-[280px] bg-zinc-950 border-r border-zinc-800 flex flex-col transition-transform duration-300 ease-in-out shadow-2xl\",\r\n                // En móvil: Se mueve dentro/fuera de la pantalla. En Desktop: Siempre visible si el padre lo dice.\r\n\r\n                isOpen\r\n                    ? \"translate-x-0\"\r\n                    : (pathname === '/' ? \"-translate-x-full\" : \"-translate-x-full md:translate-x-0\"),\r\n\r\n                className\r\n            )}>\r\n\r\n                {/* CABECERA SIDEBAR */}\r\n                <div className=\"p-4 border-b border-zinc-900 flex justify-between items-center h-16\">\r\n                    <div className=\"font-bold text-lg bg-clip-text text-transparent bg-gradient-to-r from-indigo-400 to-emerald-400\">\r\n                        Finance Home\r\n                    </div>\r\n                    {/* Botón Cerrar (SOLO MÓVIL) */}\r\n                    <Button variant=\"ghost\" size=\"icon\" onClick={onClose} className=\"md:hidden text-zinc-400\">\r\n                        <X size={20} />\r\n                    </Button>\r\n                </div>\r\n\r\n                {/* CONTENIDO SCROLLABLE */}\r\n                <div className=\"flex-1 overflow-y-auto scrollbar-thin scrollbar-thumb-zinc-800\">\r\n\r\n                    {/* USUARIO */}\r\n                    {currentUser && (\r\n                        <div className=\"px-4 py-6 text-center border-b border-zinc-900/50\">\r\n                            <div className=\"w-12 h-12 bg-indigo-900/30 text-indigo-400 rounded-full flex items-center justify-center mx-auto mb-2 font-bold text-lg\">\r\n                                {currentUser.email.charAt(0).toUpperCase()}\r\n                            </div>\r\n                            <p className=\"text-xs text-zinc-500 truncate px-4\">{currentUser.email}</p>\r\n                            {currentUser.householdId === 'demo' && <span className=\"text-[10px] text-yellow-500 font-bold tracking-wider\">MODO DEMO</span>}\r\n                        </div>\r\n                    )}\r\n\r\n                    {/* BALANCE TOTAL */}\r\n                    <div className=\"p-4\">\r\n                        <div className=\"bg-zinc-900/50 rounded-xl p-4 border border-zinc-800/50 text-center\">\r\n                            <p className=\"text-[10px] text-zinc-500 uppercase tracking-widest font-bold\">Disponible</p>\r\n                            <p className={cn(\"text-2xl font-extrabold mt-1\", totalAvailable >= 0 ? \"text-emerald-400\" : \"text-rose-400\")}>\r\n                                ${totalAvailable.toLocaleString('es-CO')}\r\n                            </p>\r\n                            {totalReservedSavings > 0 && (\r\n                                <div className=\"mt-2 text-[10px] text-blue-400 bg-blue-900/10 py-1 px-2 rounded-full inline-block\">\r\n                                    🔒 Ahorro: ${totalReservedSavings.toLocaleString()}\r\n                                </div>\r\n                            )}\r\n                        </div>\r\n                    </div>\r\n\r\n                    {/* NAVEGACIÓN */}\r\n                    <nav className=\"px-4 space-y-1 mb-6\">\r\n                        <Link href=\"/\" onClick={() => window.innerWidth < 768 && onClose()} className={navClass('/')}>\r\n                            <Home size={18} /> Resumen\r\n                        </Link>\r\n                        <Link href=\"/simulator\" onClick={() => window.innerWidth < 768 && onClose()} className={navClass('/simulator')}>\r\n                            <Calculator size={18} /> Simulador\r\n                        </Link>\r\n                        <Link href=\"/admin\" onClick={() => window.innerWidth < 768 && onClose()} className={navClass('/admin')}>\r\n                            <Settings size={18} /> Configuración\r\n                        </Link>\r\n                    </nav>\r\n\r\n                    {/* LISTA DE CUENTAS */}\r\n                    <div className=\"px-4 pb-20\">\r\n                        <h3 className=\"text-xs font-bold text-zinc-600 uppercase tracking-widest mb-3 px-2\">Mis Cuentas</h3>\r\n                        <div className=\"space-y-3\">\r\n                            {visibleAccounts.length === 0 && <p className=\"text-center text-xs text-zinc-600\">Sin cuentas.</p>}\r\n                            {visibleAccounts.map(acc => (\r\n                                <RealisticAccountCard key={acc.id} account={acc} />\r\n                            ))}\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n\r\n                {/* FOOTER FIXED */}\r\n                <div className=\"p-4 border-t border-zinc-900 bg-zinc-950\">\r\n                    <Button\r\n                        variant=\"ghost\"\r\n                        className=\"w-full justify-start text-zinc-500 hover:text-red-400 hover:bg-red-950/10\"\r\n                        onClick={async () => { await logoutAction(); window.location.href = '/login'; }}\r\n                    >\r\n                        <LogOut className=\"mr-2 h-4 w-4\" /> Cerrar Sesión\r\n                    </Button>\r\n                </div>\r\n            </aside>\r\n        </>\r\n    );\r\n}"],"names":[],"mappings":";;;;;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AARA;;;;;;;;;;AAgBe,SAAS,gBAAgB,EAAE,MAAM,EAAE,OAAO,EAAE,SAAS,EAAS;IACzE,MAAM,EAAE,QAAQ,EAAE,WAAW,EAAE,GAAG,IAAA,6LAAU;IAC5C,MAAM,kBAAkB,SAAS,MAAM,CAAC,CAAA,IAAK,CAAC,EAAE,QAAQ;IAExD,0DAA0D;IAC1D,MAAM,iBAAiB,gBAAgB,MAAM,CAAC,CAAC,KAAK,MAAQ,MAAM,IAAI,OAAO,EAAE;IAE/E,6DAA6D;IAC7D,MAAM,uBAAuB,gBAAgB,MAAM,CAAC,CAAC,KAAK,MAAQ,MAAM,CAAC,IAAI,WAAW,IAAI,CAAC,GAAG;IAGhG,oFAAoF;IACpF,MAAM,iBAAiB,iBAAiB;IAExC,MAAM,WAAW,IAAA,sMAAW;IAC5B,MAAM,WAAW,CAAC,OAAiB,IAAA,uKAAE,EACjC,gFACA,aAAa,OAAO,iEAAiE;IAGzF,qBACI;;0BAEI,mSAAC;gBACG,WAAW,IAAA,uKAAE,EACT,4EACA,SAAS,gBAAgB;gBAE7B,SAAS;;;;;;0BAIb,mSAAC;gBAAM,WAAW,IAAA,uKAAE,EAChB,0JACA,mGAAmG;gBAEnG,SACM,kBACC,aAAa,MAAM,sBAAsB,sCAEhD;;kCAIA,mSAAC;wBAAI,WAAU;;0CACX,mSAAC;gCAAI,WAAU;0CAAkG;;;;;;0CAIjH,mSAAC,0LAAM;gCAAC,SAAQ;gCAAQ,MAAK;gCAAO,SAAS;gCAAS,WAAU;0CAC5D,cAAA,mSAAC,sPAAC;oCAAC,MAAM;;;;;;;;;;;;;;;;;kCAKjB,mSAAC;wBAAI,WAAU;;4BAGV,6BACG,mSAAC;gCAAI,WAAU;;kDACX,mSAAC;wCAAI,WAAU;kDACV,YAAY,KAAK,CAAC,MAAM,CAAC,GAAG,WAAW;;;;;;kDAE5C,mSAAC;wCAAE,WAAU;kDAAuC,YAAY,KAAK;;;;;;oCACpE,YAAY,WAAW,KAAK,wBAAU,mSAAC;wCAAK,WAAU;kDAAuD;;;;;;;;;;;;0CAKtH,mSAAC;gCAAI,WAAU;0CACX,cAAA,mSAAC;oCAAI,WAAU;;sDACX,mSAAC;4CAAE,WAAU;sDAAgE;;;;;;sDAC7E,mSAAC;4CAAE,WAAW,IAAA,uKAAE,EAAC,gCAAgC,kBAAkB,IAAI,qBAAqB;;gDAAkB;gDACxG,eAAe,cAAc,CAAC;;;;;;;wCAEnC,uBAAuB,mBACpB,mSAAC;4CAAI,WAAU;;gDAAoF;gDAClF,qBAAqB,cAAc;;;;;;;;;;;;;;;;;;0CAOhE,mSAAC;gCAAI,WAAU;;kDACX,mSAAC,4NAAI;wCAAC,MAAK;wCAAI,SAAS,IAAM,OAAO,UAAU,GAAG,OAAO;wCAAW,WAAW,SAAS;;0DACpF,mSAAC,gQAAI;gDAAC,MAAM;;;;;;4CAAM;;;;;;;kDAEtB,mSAAC,4NAAI;wCAAC,MAAK;wCAAa,SAAS,IAAM,OAAO,UAAU,GAAG,OAAO;wCAAW,WAAW,SAAS;;0DAC7F,mSAAC,iRAAU;gDAAC,MAAM;;;;;;4CAAM;;;;;;;kDAE5B,mSAAC,4NAAI;wCAAC,MAAK;wCAAS,SAAS,IAAM,OAAO,UAAU,GAAG,OAAO;wCAAW,WAAW,SAAS;;0DACzF,mSAAC,2QAAQ;gDAAC,MAAM;;;;;;4CAAM;;;;;;;;;;;;;0CAK9B,mSAAC;gCAAI,WAAU;;kDACX,mSAAC;wCAAG,WAAU;kDAAsE;;;;;;kDACpF,mSAAC;wCAAI,WAAU;;4CACV,gBAAgB,MAAM,KAAK,mBAAK,mSAAC;gDAAE,WAAU;0DAAoC;;;;;;4CACjF,gBAAgB,GAAG,CAAC,CAAA,oBACjB,mSAAC,gNAAoB;oDAAc,SAAS;mDAAjB,IAAI,EAAE;;;;;;;;;;;;;;;;;;;;;;;kCAOjD,mSAAC;wBAAI,WAAU;kCACX,cAAA,mSAAC,0LAAM;4BACH,SAAQ;4BACR,WAAU;4BACV,SAAS;gCAAc,MAAM,IAAA,gNAAY;gCAAI,OAAO,QAAQ,CAAC,IAAI,GAAG;4BAAU;;8CAE9E,mSAAC,yQAAM;oCAAC,WAAU;;;;;;gCAAiB;;;;;;;;;;;;;;;;;;;;AAM3D"}},
    {"offset": {"line": 1262, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/JhtG2/Jth/Git%20Repository/Home/finance-home/components/layout/MainLayout.tsx"],"sourcesContent":["\"use client\";\r\n\r\nimport { useState } from 'react';\r\nimport { usePathname } from 'next/navigation';\r\nimport AccountsSidebar from '@/components/dashboard/AccountsSidebar';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Menu, PanelLeftClose, PanelLeftOpen } from 'lucide-react';\r\nimport { cn } from '@/lib/utils';\r\nimport { useFinance } from '@/context/FinanceContext';\r\n\r\nexport default function MainLayout({ children }: { children: React.ReactNode }) {\r\n    const pathname = usePathname();\r\n    const isLoginPage = pathname === '/login';\r\n    const { currentUser } = useFinance();\r\n\r\n    // Estado del Sidebar\r\n    // - true: Abierto (Visible en Desktop empujando contenido / Visible en Móvil como overlay)\r\n    // - false: Cerrado (Oculto en ambos)\r\n    const [isSidebarOpen, setIsSidebarOpen] = useState(true);\r\n\r\n    if (isLoginPage) {\r\n        return <main className=\"w-full min-h-screen bg-black\">{children}</main>;\r\n    }\r\n\r\n    return (\r\n        <div className=\"min-h-screen bg-black text-white relative\">\r\n            \r\n            {/* SIDEBAR COMPONENTE */}\r\n            {/* En Desktop: Si isSidebarOpen es falso, lo ocultamos visualmente (hidden md:hidden) para liberar espacio */}\r\n            <div className={cn(\r\n                \"fixed inset-y-0 left-0 z-50 w-[280px]\", \r\n                !isSidebarOpen && \"hidden\" // Si está cerrado, lo quitamos del DOM visualmente\r\n            )}>\r\n                <AccountsSidebar \r\n                    isOpen={isSidebarOpen} \r\n                    onClose={() => setIsSidebarOpen(false)} // Función para que el móvil pueda cerrarse solo\r\n                />\r\n            </div>\r\n\r\n            {/* CONTENIDO PRINCIPAL */}\r\n            <div className={cn(\r\n                \"flex flex-col min-h-screen transition-all duration-300 ease-in-out\",\r\n                // MARGEN DINÁMICO DESKTOP: Si el sidebar está abierto, dejamos 280px a la izquierda. Si no, 0.\r\n                isSidebarOpen ? \"md:pl-[280px]\" : \"md:pl-0\"\r\n            )}>\r\n                \r\n                {/* HEADER SUPERIOR (STICKY) */}\r\n                <header className=\"sticky top-0 z-40 h-16 border-b border-zinc-800 bg-black/80 backdrop-blur flex items-center px-4 justify-between\">\r\n                    \r\n                    <div className=\"flex items-center gap-3\">\r\n                        {/* BOTÓN TOGGLE (HAMBURGUESA / COLAPSAR) */}\r\n                        <Button \r\n                            variant=\"ghost\" \r\n                            size=\"icon\" \r\n                            onClick={() => setIsSidebarOpen(!isSidebarOpen)}\r\n                            className=\"text-zinc-400 hover:text-white hover:bg-zinc-800\"\r\n                        >\r\n                            {/* Icono cambia según estado */}\r\n                            {isSidebarOpen ? <PanelLeftClose /> : <Menu />}\r\n                        </Button>\r\n                        \r\n                        {/* TÍTULO MÓVIL (En desktop lo dice el sidebar) */}\r\n                        <span className={cn(\r\n                            \"font-bold text-lg bg-clip-text text-transparent bg-gradient-to-r from-indigo-400 to-emerald-400\",\r\n                            isSidebarOpen ? \"md:opacity-0\" : \"opacity-100\" // Ocultar título en desktop si sidebar está abierto (ya lo tiene el sidebar)\r\n                        )}>\r\n                            Finance Home\r\n                        </span>\r\n                    </div>\r\n\r\n                    {/* USUARIO (DERECHA) */}\r\n                    {currentUser && (\r\n                         <div className=\"text-xs text-zinc-500 font-mono\">\r\n                            {currentUser.householdId === 'demo' ? 'DEMO' : 'FAMILIA'}\r\n                         </div>\r\n                    )}\r\n                </header>\r\n\r\n                {/* AREA DE CONTENIDO REAL */}\r\n                <main className=\"flex-1 p-4 md:p-8 overflow-x-hidden w-full max-w-[1600px] mx-auto\">\r\n                    {children}\r\n                </main>\r\n            </div>\r\n        </div>\r\n    );\r\n}"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AARA;;;;;;;;;AAUe,SAAS,WAAW,EAAE,QAAQ,EAAiC;IAC1E,MAAM,WAAW,IAAA,sMAAW;IAC5B,MAAM,cAAc,aAAa;IACjC,MAAM,EAAE,WAAW,EAAE,GAAG,IAAA,6LAAU;IAElC,qBAAqB;IACrB,2FAA2F;IAC3F,qCAAqC;IACrC,MAAM,CAAC,eAAe,iBAAiB,GAAG,IAAA,sQAAQ,EAAC;IAEnD,IAAI,aAAa;QACb,qBAAO,mSAAC;YAAK,WAAU;sBAAgC;;;;;;IAC3D;IAEA,qBACI,mSAAC;QAAI,WAAU;;0BAIX,mSAAC;gBAAI,WAAW,IAAA,uKAAE,EACd,yCACA,CAAC,iBAAiB,SAAS,mDAAmD;;0BAE9E,cAAA,mSAAC,2MAAe;oBACZ,QAAQ;oBACR,SAAS,IAAM,iBAAiB;;;;;;;;;;;0BAKxC,mSAAC;gBAAI,WAAW,IAAA,uKAAE,EACd,sEACA,+FAA+F;gBAC/F,gBAAgB,kBAAkB;;kCAIlC,mSAAC;wBAAO,WAAU;;0CAEd,mSAAC;gCAAI,WAAU;;kDAEX,mSAAC,0LAAM;wCACH,SAAQ;wCACR,MAAK;wCACL,SAAS,IAAM,iBAAiB,CAAC;wCACjC,WAAU;kDAGT,8BAAgB,mSAAC,qSAAc;;;;iEAAM,mSAAC,+PAAI;;;;;;;;;;kDAI/C,mSAAC;wCAAK,WAAW,IAAA,uKAAE,EACf,mGACA,gBAAgB,iBAAiB,cAAc,6EAA6E;;kDAC7H;;;;;;;;;;;;4BAMN,6BACI,mSAAC;gCAAI,WAAU;0CACX,YAAY,WAAW,KAAK,SAAS,SAAS;;;;;;;;;;;;kCAM3D,mSAAC;wBAAK,WAAU;kCACX;;;;;;;;;;;;;;;;;;AAKrB"}}]
}